readRDS('~/Documents/RoCA/data/gene.set/human_slim_annotation.rds')
?p.adjust
63000/5
56561/7
dir()
dir('input/')
setwd("~/Documents/RoCA/template/qc/identify_outlier")
require(RoCA)
CreateReport('identify_outlier.yaml')
library(RoCA)
CreateReport('identify_outlier_2.yml')
CreateReport('identify_outlier_2.yml')
CreateReport('identify_outlier.yaml')
CreateReport('identify_outlier.yaml')
require('RoCA')
CreateReport('identify_outlier.yaml')
CreateReport('identify_outlier.yaml')
name.yaml <- 'identify_outlier.yaml';
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'gplots', 'RoCA', 'awsomics', 'DEGandMore');
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table'); #
## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }
## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));
## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template
prms <- yml$parameter;
## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]);
## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
IdentifyOutlierByCorr<-function(d, RMX=0.99, NMN=4, NSD=3) {
# d     Data matrix, rows are genes or other variables and columns are samples
# RMX   Maximal mean correlation coefficient for a sample to be an outlier
# NMN   Minimal number of samples
# NSD   Number of standard deviation
if (NMN < 3) NMN<-3;
if (ncol(d) < NMN) NA else {
corr<-lapply(1:ncol(d), function(i) cor(d[, i], d[, -i], use='pair'));
names(corr)<-colnames(d);
ms<-sapply(corr, mean);
nsd<-sapply(1:length(ms), function(i) (ms[i]-mean(ms[-i]))/sd(ms[-i]));
names(nsd)<-colnames(d);
out<-list(outlier=nsd[nsd<=-1*abs(NSD) & ms<RMX], nsd=nsd, mean=ms, corr=corr,
parameters=c(RMX=RMX, NMN=NMN, NSD=NSD));
}
}
# Run IdentifyOutlierByCorr() function recursively until no more outliers were identified or there are no enough samples
IdentifyOutlierByCorr.2<-function(d, RMX=0.99, NMN=4, NSD=3) {
# d     Data matrix, rows are genes or other variables and columns are samples
# RMX   Maximal mean correlation coefficient for a sample to be an outlier
# NMN   Minimal number of samples
# NSD   Number of standard deviation
if (ncol(d) < NMN) NA else {
out <- list(IdentifyOutlierByCorr(d, RMX, NMN, NSD));
d <- d[, !(colnames(d) %in% names(out[[1]][[1]]))];
while (length(out[[length(out)]][[1]])>0 & ncol(d)>=NMN) { # outlier identified, is there more
out[[length(out)+1]]<-IdentifyOutlierByCorr(d, RMX, NMN, NSD);
d <- d[, !(colnames(d) %in% names(out[[length(out)]][[1]]))];
}
names(out)<-paste('Round', 1:length(out), sep='');
nsd<-lapply(out, function(x) x$nsd);
mns<-lapply(out, function(x) x$mean);
summ<-cbind(Round=rep(1:length(nsd), sapply(nsd, length)), NSD=as.vector(unlist(nsd)), Mean=as.vector(unlist(mns)));
summ<-data.frame(Sample=as.vector(unlist(lapply(nsd, names))), round(summ, 6), stringsAsFactors = FALSE);
summ$Outlier<-summ$NSD< -1*abs(NSD) & summ$Mean<RMX
ind <- sapply(unique(summ$Sample), function(nm) {
i <- which(summ$Sample==nm);
if (length(i)==1) i else {
j <- summ$Round[i];
i[j==max(j)][1];
};
});
summ <- summ[ind, , drop=FALSE];
summ <- summ[order(summ$Round), , drop=FALSE]
list(summary=summ, all=out);
}
}
out <- lapply(grps, function(g)
IdentifyOutlierByCorr.2(expr[, g, drop=FALSE], RMX=prms$max.corr, NMN=prms$min.n, NSD=prms$n.sd));
name.yaml <- 'identify_outlier.yaml';
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'gplots', 'RoCA', 'awsomics', 'DEGandMore');
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table'); #
## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }
## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));
## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template
prms <- yml$parameter;
## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]);
## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
expr <- ImportTable(DownloadFile(yml$input$data, path.input));
anno <- ImportTable(DownloadFile(yml$input$annotation, path.input));
grps <- ImportList(DownloadFile(yml$input$group, path.input));
gset <- ImportList(DownloadFile(yml$input$geneset, path.input));
anno <- anno[rownames(anno) %in% rownames(expr), , drop=FALSE];
expr <- expr[rownames(anno), , drop=FALSE];
grps <- lapply(grps, function(x) x[x %in% colnames(expr)]);
expr <- expr[, colnames(expr) %in% unlist(grps, use.names=FALSE), drop=FALSE];
if (nrow(expr) < 4) stop('Error: less than 4 genes, cannot continue\n');
if (ncol(expr) < 4) stop('Error: less than 4 samples, cannot continue\n');
smp2grp<-rep(names(grps), sapply(grps, length));
names(smp2grp)<-unlist(grps, use.names=FALSE);
gset.src<-sort(unique(gset[[1]]$Source));
if (prms$min.n < 4) {
prms$min.n <- 4;
warning('Warning: minimal number of replicates per group cannot be less than 4; value is reset\n');
}
library(RoCA)
CreateReport('identify_outlier.yaml')
CreateReport('identify_outlier.yaml')
CreateReport('identify_outlier.yaml')
CreateReport('identify_outlier.yaml')
CreateReport('identify_outlier.yaml')
CreateReport('identify_outlier.yaml')
CreateReport('identify_outlier.yaml')
CreateReport('identify_outlier.yaml')
CreateReport('identify_outlier.yaml')
CreateReport('identify_outlier.yaml')
CreateReport('identify_outlier.yaml')
CreateReport('identify_outlier.yaml')
name.yaml <- 'identify_outlier.yaml';
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'gplots', 'RoCA', 'awsomics', 'DEGandMore');
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table'); #
## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }
## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));
## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template
prms <- yml$parameter;
## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]);
## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
expr <- ImportTable(DownloadFile(yml$input$data, path.input));
anno <- ImportTable(DownloadFile(yml$input$annotation, path.input));
grps <- ImportList(DownloadFile(yml$input$group, path.input));
gset <- ImportList(DownloadFile(yml$input$geneset, path.input));
anno <- anno[rownames(anno) %in% rownames(expr), , drop=FALSE];
expr <- expr[rownames(anno), , drop=FALSE];
grps <- lapply(grps, function(x) x[x %in% colnames(expr)]);
expr <- expr[, colnames(expr) %in% unlist(grps, use.names=FALSE), drop=FALSE];
if (nrow(expr) < 4) stop('Error: less than 4 genes, cannot continue\n');
if (ncol(expr) < 4) stop('Error: less than 4 samples, cannot continue\n');
smp2grp<-rep(names(grps), sapply(grps, length));
names(smp2grp)<-unlist(grps, use.names=FALSE);
gset.src<-sort(unique(gset[[1]]$Source));
if (prms$min.n < 4) {
prms$min.n <- 4;
warning('Warning: minimal number of replicates per group cannot be less than 4; value is reset\n');
}
IdentifyOutlierByCorr<-function(d, RMX=0.99, NMN=4, NSD=3) {
# d     Data matrix, rows are genes or other variables and columns are samples
# RMX   Maximal mean correlation coefficient for a sample to be an outlier
# NMN   Minimal number of samples
# NSD   Number of standard deviation
if (NMN < 3) NMN<-3;
if (ncol(d) < NMN) NA else {
corr<-lapply(1:ncol(d), function(i) cor(d[, i], d[, -i], use='pair'));
names(corr)<-colnames(d);
ms<-sapply(corr, mean);
nsd<-sapply(1:length(ms), function(i) (ms[i]-mean(ms[-i]))/sd(ms[-i]));
names(nsd)<-colnames(d);
out<-list(outlier=nsd[nsd<=-1*abs(NSD) & ms<RMX], nsd=nsd, mean=ms, corr=corr,
parameters=c(RMX=RMX, NMN=NMN, NSD=NSD));
}
}
# Run IdentifyOutlierByCorr() function recursively until no more outliers were identified or there are no enough samples
IdentifyOutlierByCorr.2<-function(d, RMX=0.99, NMN=4, NSD=3) {
# d     Data matrix, rows are genes or other variables and columns are samples
# RMX   Maximal mean correlation coefficient for a sample to be an outlier
# NMN   Minimal number of samples
# NSD   Number of standard deviation
if (ncol(d) < NMN) NA else {
out <- list(IdentifyOutlierByCorr(d, RMX, NMN, NSD));
d <- d[, !(colnames(d) %in% names(out[[1]][[1]]))];
while (length(out[[length(out)]][[1]])>0 & ncol(d)>=NMN) { # outlier identified, is there more
out[[length(out)+1]]<-IdentifyOutlierByCorr(d, RMX, NMN, NSD);
d <- d[, !(colnames(d) %in% names(out[[length(out)]][[1]]))];
}
names(out)<-paste('Round', 1:length(out), sep='');
nsd<-lapply(out, function(x) x$nsd);
mns<-lapply(out, function(x) x$mean);
summ<-cbind(Round=rep(1:length(nsd), sapply(nsd, length)), NSD=as.vector(unlist(nsd)), Mean=as.vector(unlist(mns)));
summ<-data.frame(Sample=as.vector(unlist(lapply(nsd, names))), round(summ, 6), stringsAsFactors = FALSE);
summ$Outlier<-summ$NSD< -1*abs(NSD) & summ$Mean<RMX
ind <- sapply(unique(summ$Sample), function(nm) {
i <- which(summ$Sample==nm);
if (length(i)==1) i else {
j <- summ$Round[i];
i[j==max(j)][1];
};
});
summ <- summ[ind, , drop=FALSE];
summ <- summ[order(summ$Round), , drop=FALSE]
list(summary=summ, all=out);
}
}
out <- lapply(grps, function(g)
IdentifyOutlierByCorr.2(expr[, g, drop=FALSE], RMX=prms$max.corr, NMN=prms$min.n, NSD=prms$n.sd));
na <- sapply(out, function(x) identical(NA, x));
if (length(na[na]) > 0) {
out[na] <- lapply(grps[na], function(g) {
x <- IdentifyOutlierByCorr.2(expr, RMX=prms$max.corr, NMN=prms$min.n, NSD=prms$n.sd);
x[[1]] <- x[[1]][x[[1]][, 1] %in% g, , drop=FALSE];
x;
});
};
smm <- lapply(out, function(x) x$summary);
wth <- lapply(1:length(out), function(i) rep(!na[i], nrow(out[[i]][[1]])));
grp <- rep(names(smm), sapply(smm, nrow));
rnm <- lapply(smm, function(smm) smm[[1]]);
smm <- data.frame(Group=grp, do.call('rbind', smm), Within=unlist(wth, use.names=FALSE), stringsAsFactors = FALSE);
rownames(smm) <- unlist(rnm, use.names=FALSE);
fn.stat<-CreateDatatable(smm, paste(yml$output, 'stat_table.html', sep='/'), rownames = FALSE);
outliers<-smm[smm$Outlier, , drop=FALSE];
grps.filtered<-lapply(grps, function(g) g[!(g %in% outliers$Sample)]);
saveRDS(out, paste(path.r, 'outlier.rds', sep='/'));
par(mar=c(5,5,2,2));
col <- rep('#0000FF88', nrow(smm));
col[smm[, 6] & smm[, 7]] <- '#FF000088';
col[smm[, 6] & !smm[, 7]] <- '#FFBBBB88';
plot(smm$Mean, smm$NSD, pch=19, col=col, cex=2, cex.lab=1.5, xlim=range(smm$Mean), xlab="Average correlation coefficient", ylab="Number of standard deviations");
abline(v=prms$max.corr, h=-1*abs(prms$n.sd), lty=2, lwd=2, col='darkgrey');
points(smm$Mean, smm$NSD, cex=.2);
legend('topleft', pch=19, col=c('#0000FF88', '#FF000088', '#FFBBBB88'), bty='n',
legend=c('Non-outlier', 'Outlier (group)', 'Outlier (global)'))
outliers.all <- outliers;
outliers <- outliers[outliers[, 7], , drop=FALSE];
if (nrow(outliers) > 0) {
d0<-lapply(outliers$Sample, function(s) expr[, grps.filtered[[smp2grp[s]]], drop=FALSE]);
d1<-lapply(outliers$Sample, function(s) expr[, s]);
names(d0)<-names(d1)<-outliers$Sample;
fn<-sapply(1:nrow(outliers), function(i) {
id<-outliers$Sample[i];
fn<-paste(path.fig, '/', id, '.png', sep='');
r<-sapply(1:ncol(d0[[i]]), function(j) cor(d0[[i]][, j], rowMeans(d0[[i]][, -j, drop=FALSE])));
ind<-which(r==max(r))[1];
x<-cbind(rowMeans(d0[[i]]), d1[[i]]);
y<-cbind(rowMeans(d0[[i]][, -ind]), d0[[i]][, ind]);
png(fn, w=800, h=400);
par(mar=c(5,5,2,2), mfrow=c(1, 2));
plot(x, pch=19, cex=0.5, col='#88888888', xlim=c(min(x), max(x)), ylim=c(min(x), max(x)),
xlab='Others', ylab=id, cex.lab=1.5);
abline(0, 1, col=4);
plot(y, pch=19, cex=0.5, col='#88888888', xlim=c(min(x), max(x)), ylim=c(min(x), max(x)),
xlab='Others', ylab=colnames(d0[[i]])[ind], cex.lab=1.5);
abline(0, 1, col=4);
if (dev.cur()!=1) dev.off();
pdf(sub('.png$', '.pdf', fn), w=8, h=4);
par(mar=c(5,5,2,2), mfrow=c(1, 2));
plot(x, pch=19, cex=0.5, col='#88888888', xlim=c(min(x), max(x)), ylim=c(min(x), max(x)), xlab='Others',
ylab=id, cex.lab=1.5);
abline(0, 1, col=4);
plot(y, pch=19, cex=0.5, col='#88888888', xlim=c(min(x), max(x)), ylim=c(min(x), max(x)),
xlab='Others', ylab=colnames(d0[[i]])[ind], cex.lab=1.5);
abline(0, 1, col=4);
if (dev.cur()!=1) dev.off();
fn;
});
fn<-sub(yml$output, '', fn);
fn<-sub('^/', '', fn);
lns<-paste('  - [', outliers$Sample, '](', fn, ')', sep='');
lns<-paste(lns, collapse='\n');
} else {
lns<-'  - No outliers were identified'
}
if (nrow(outliers) < 3) {
if (nrow(outliers) == 0) lns<-'No outliers found' else lns<-'No enough outliers for clustering analysis';
par(mar=c(0,0,0,0));
plot(0, type='n', axes=FALSE, xlab='', ylab='');
text(1, 0, pos=1, label=lns, cex=1.5, col='darkgreen');
} else {
dff<-sapply(1:nrow(outliers), function(i) d1[[i]]-rowMeans(d0[[i]]));
colnames(dff)<-outliers$Sample;
hc<-hclust(as.dist(1-cor(dff)));
plot(hc, main='Differential expression: outlier vs. non-outlier', xlab='Outlier', sub='');
abline(h=1-prms$cut.corr, lty=2, col='#0000FF88');
ct<-cutree(hc, h=1-prms$cut.corr);
g<-split(names(ct), ct);
g<-g[sapply(g, length)>1];
if (length(g) == 0) lns<-'No outliers can be grouped together.' else {
lns<-as.vector(sapply(g, function(g) paste(g, collapse='; ')));
lns<-paste('  -', lns);
lns<-paste(lns, collapse='\n');
}
}
if (nrow(outliers) == 0) lns<-'No outliers found' else {
# select DEGs
tops<-lapply(1:nrow(outliers), function(i) {
dff<-d1[[i]]-rowMeans(d0[[i]]);
nsd<-dff/apply(d0[[i]], 1, sd);
deg<-dff[abs(nsd)>=abs(prms$difference$nsd)];
deg <- deg[!is.na(deg)];
deg<-list(hi=deg[deg>0], lo=deg[deg<0]);
deg<-lapply(deg, function(d) d[rev(order(abs(d)))]);
deg<-lapply(deg, function(d) {
if (length(d) > prms$difference$min) {
d<-d[1:min(prms$difference$max, length(d))];
if (abs(prms$difference$mean > abs(d[prms$difference$min]))) d[1:prms$difference$min] else
d[abs(d) > abs(prms$difference$mean)];
} else d;
});
});
names(tops)<-outliers$Sample;
# Prepare HTML tables
tbls<-lapply(1:length(tops), function(i) lapply(tops[[i]], function(d) {
x0<-d0[[i]][names(d), , drop=FALSE];
x1<-d1[[i]][names(d)];
dff<-x1-rowMeans(x0);
sd<-apply(x0, 1, sd);
stat<-round(cbind(x1, rowMeans(x0), dff, dff/sd), 4);
colnames(stat)<-c(outliers$Sample[i], 'Non_Outliers', 'Change', 'NSD');
cbind(anno[rownames(stat), ], stat);
}));
names(tbls)<-names(tops)<-outliers$Sample;
# Write tables to HTML
fn<-lapply(names(tbls), function(nm) {
f<-paste(path.tbl, paste(nm, '_', c('Higher', 'Lower'), '.html', sep=''), sep='/')
CreateDatatable(tbls[[nm]][[1]], f[1], caption = nm);
CreateDatatable(tbls[[nm]][[2]], f[2], caption = nm);
f;
});
# Write summary table
fn<-t(sapply(fn, function(f) sub(paste(yml$output, '/', sep=''), '', f)));
n<-t(sapply(tops, function(x) sapply(x, length)));
rownames(n)<-rownames(fn)<-outliers$Sample;
colnames(n)<-colnames(fn)<-c('Higher in outlier', 'Low in outlier');
tbl<-t(sapply(rownames(n), function(nm) paste('[', n[nm, ], '](', fn[nm, ], ')', sep='')));
dimnames(tbl)<-dimnames(n);
lns<-kable(tbl, row.names=TRUE, align=c('c', 'c'));
}
path.gsea<-paste(path.tbl, 'gsea', sep='/');
if (!file.exists(path.gsea)) dir.create(path.gsea, recursive = TRUE);
if (nrow(outliers) == 0) ln.hi<-ln.lo<-'No outliers found' else {
gses<-lapply(names(tops), function(nm) {
cat(nm, '\n');
gse<-lapply(tops[[nm]], function(gs) TestGSE(names(gs), rownames(anno), gset[[2]])[[1]]);
hi<-WrapGSE(gse[[1]], gset[[1]], paste(path.gsea, paste(nm, 'Higher', sep='_'), sep='/'));
lo<-WrapGSE(gse[[2]], gset[[1]], paste(path.gsea, paste(nm, 'Lower' , sep='_'), sep='/'));
list(hi, lo);
});
fn.hi<-sapply(gses, function(g) g[[1]]$file[gset.src]);
fn.lo<-sapply(gses, function(g) g[[2]]$file[gset.src]);
fn.hi<-sub(paste(yml$output, '/', sep=''), '', fn.hi);
fn.lo<-sub(paste(yml$output, '/', sep=''), '', fn.lo);
n.hi<-sapply(gses, function(g) sapply(g[[1]]$formatted[gset.src], nrow));
n.lo<-sapply(gses, function(g) sapply(g[[2]]$formatted[gset.src], nrow));
tbl.hi<-t(matrix(paste('[', n.hi, '](', fn.hi, ')', sep=''), nc=nrow(outliers)));
tbl.lo<-t(matrix(paste('[', n.lo, '](', fn.lo, ')', sep=''), nc=nrow(outliers)));
dimnames(tbl.hi)<-dimnames(tbl.lo)<-list(outliers$Sample, gset.src);
ln.hi<-kable(tbl.hi, align = rep('c', ncol(tbl.hi)));
ln.lo<-kable(tbl.lo, align = rep('c', ncol(tbl.lo)));
}
path.gsea<-paste(path.tbl, 'gsea', sep='/');
if (!file.exists(path.gsea)) dir.create(path.gsea, recursive = TRUE);
nrow(outliers) == 0
gses<-lapply(names(tops), function(nm) {
cat(nm, '\n');
gse<-lapply(tops[[nm]], function(gs) TestGSE(names(gs), rownames(anno), gset[[2]])[[1]]);
hi<-WrapGSE(gse[[1]], gset[[1]], paste(path.gsea, paste(nm, 'Higher', sep='_'), sep='/'));
lo<-WrapGSE(gse[[2]], gset[[1]], paste(path.gsea, paste(nm, 'Lower' , sep='_'), sep='/'));
list(hi, lo);
});
names(tops)
nm <- names(tops)[1]
nm
gse<-lapply(tops[[nm]], function(gs) TestGSE(names(gs), rownames(anno), gset[[2]])[[1]]);
length(gs)
gs <- tops[[nm]][[1]]
gs
length(gs)
TestGSE(names(gs), rownames(anno), gset[[2]][[1]])
dim(anno)
head(anno)
names(gs)
gse<-lapply(tops[[nm]], function(gs) TestGSE(names(gs), rownames(anno), gset[[2]])[[1]]);
gse<-lapply(tops[[nm]], function(gs) {
TestGSE(names(gs), rownames(anno), gset[[2]])[[1]];
});
gse<-lapply(tops[[nm]], function(gs) { print(1);
TestGSE(names(gs), rownames(anno), gset[[2]])[[1]];
});
gs <- tops[[1]]
gs
x <- names(gs)
x
gs <- tops[[1]]
length(gs)
x <- names(gs[[1]])
head(x)
length(x)
y <- rownames(anno)
head(y)
length(x)
length(y)
z <- intersect(x, y)
length(z)
a <- gset[[2]][[1]]
length(a)
naems(a)
names(a)
names(gset)
gset[[2]][1:2]
head(gst[[1]])
head(gset[[1]])
library("org.Hs.eg.db", lib.loc="~/Library/R/3.3/library")
x <- org.Hs.egSYMBOL
# Get the gene symbol that are mapped to an entrez gene identifiers
mapped_genes <- mappedkeys(x)
# Convert to a list
xx <- as.list(x[mapped_genes])
l <- gset[[2]]
length(l)
a <- rep(names(l), sapply(l, length))
b <- unlist(l, use.names=FALSE)
length(a)
length(b)
c <- xx[b]
head(c)
x <- unlist(xx)
names(x) <- names(xx)
head(x)
c <- x[b]
head(c)
names(c) <- a
length(c[is.na(c)])
c <- c[!is.na(c)]
length(c)
x <- split(as.vector(c), names(c))
length(x)
x[1:2]
a <- gset[[1]]
a <- a[rownames(a) %in% names(x), ]
dim(a)
b <- b[rownames(a)]
require('RoCA')
CreateReport('identify_outlier.yaml')
