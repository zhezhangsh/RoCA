---
title: "Summary of FLASH2 outputs"
author: "`r if (exists('yml')) yml$analyst else 'Jim Zhang'`"
date: "`r Sys.Date()`"
output:
  html_document:
    number_sections: yes
    self_contained: no
    toc: yes
    toc_float:
      collapsed: no
---

<div style="border:black 1px solid; padding: 0.5cm 0.5cm">
**Introduction** This analysis compares a set of paired end **FASTQ** files processed by the **[FLASH2](https://github.com/dstreett/FLASH2)** program, which combines pairs of overlapping reads to generate longer, single-end reads. **Flash2** processes read pairs based on the following 3 scenarios:

  - Non-overlapping. When the DNA fragments are longer than 2 times of the read length, the paired reads have no overlapping. Therefore, the paired reads will be written separately into 2 fastq files, just like the way they were saved in the original pair of fastq files.
  - Innie merging. When the DNA fragments are longer than the read length, but shorter than 2 times of the read length, the paired reads are partially overlapped. The paired reads are merged into a longer read and saved to a different fastq file as a single-ended read. The new read includes the full sequences of both reads, with more or less overlapping in th middle. If the reads disagree on the overlapping sequence, the base call with higher quality score will be used.
  - Outie merging. When the DNA fragments are short than the read length, the paired reads both sequenced the fragment and overlap to each other at the beginning of both reads. The overlapping part will be saved as a short, single-ended read in the same fastq file of the innie merging reads. The non-overlapping parts of the reads, including all or part of the adaptors, will be discarded. The disagreement within the overlapping sequence will also be determined by base call quality.
</div>

&nbsp;

```{r global_setup, eval=TRUE, include=FALSE}
name.yaml <- 'summarize_flash2.yaml'; 
name.packages <- c('rmarkdown', 'knitr', 'kableExtra', 'yaml', 'DT', 'htmlwidgets', 'RoCA', 'awsomics', 'PROseqR'); 
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table'); # <full.path.to.subfolder>=<subfolder.name>

## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));

## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
  if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
    yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template

prms <- yml$parameter;

## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]); 

## Automatical figure/table ordering
OrderFigure(reset=TRUE);
OrderTable(reset=TRUE);

## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
```

```{r load_data, include=FALSE}
fns <- ImportTable(DownloadFile(yml$input$flash2, path.input));
log <- apply(fns, 1, function(f) ParseFlash2(f[1], f[2]));

cnt <- t(sapply(log, function(x) x[[1]]));
pct <- apply(cnt, 2, function(c) 100*c/cnt[, 1]);
colnames(pct) <- paste(colnames(pct), '(%)', sep='');
CreateDatatable(cbind(cnt, round(pct, 4)), paste(path.tbl, 'summary_count.html', sep='/'));
saveRDS(cbind(cnt, pct), paste(path.r, 'summary_count.rds', sep='/'));

rng <- range(unlist(lapply(log, function(x) as.numeric(names(x[[2]])))));
len <- sapply(log, function(x) x[[2]][as.character(rng[1]:rng[2])]);
len[is.na(len)] <- 0;
rng <- rng - max(0, yml$parameter$barcode);
rownames(len) <- as.character(rng[1]:rng[2]);
CreateDatatable(cbind('Length'=as.numeric(rownames(len)), len), paste(path.tbl, 'length_count.html', sep='/'), rownames = FALSE);
saveRDS(len, paste(path.r, 'length_count.rds', sep='/'));

por <- apply(len, 2, function(l) 100*l/sum(l));
CreateDatatable(cbind('Length'=as.numeric(rownames(por)), round(por, 4)), paste(path.tbl, 'length_percent.html', sep='/'), rownames = FALSE);
saveRDS(por, paste(path.r, 'length_percent.rds', sep='/'));
```

`r home.url`

# Description

`r WriteDescription(yml$description)`

`r home.url`

# Results

## Summary of read count

Total number of reads in different categories according to **FLASH2**.

> Click [here](table/summary_count.html) to view summary table.

<div style="color:darkblue">
`r OrderTable()` Percentages of read pairs in each **FLASH2** category. "_Combined_" equals to the sum of **_Innie_** and **_Outie_**.
</div>

`r kable(cbind(cnt[, 1, drop=FALSE], round(pct[, -1], 4))) %>% kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE)`
  
## Summary of read length

Length of single end reads generated by **FLASH2**, subtracting the `r yml$parameter$barcode` base(s) of barcode.

> Click [here](table/length_count.html) to view read counts by length table.

> Click [here](table/length_percent.html) to view read percentages by length table.

```{r length_percent, include=TRUE, fig.width=9.6, fig.height=6.4, out.width='960px'}
par(mar=c(5,5,2,2));
col <- terrain.colors(ncol(por));
barplot(t(por)/ncol(por), be=FALSE, space=rep(0, nrow(por)), border=NA, las=3, col=col, names.arg = rep('', nrow(por)));
args <- seq(rng[1], rng[2], 4);
axis(1, at=(args-rng[1])+0, label=args, las=3);
title(xlab='Read length', ylab='Average percentages in all libraries', cex.lab=1.5);
legend('topright', pch=15, col=col, bty='n', cex=1, legend=colnames(por));
lines((1:nrow(por))-0.5, rowMeans(por), lwd=2);
# plot(rowSums(por)/ncol(por), type='l');
```

`r OrderFigure()` Average percentages of reads with given length among all merged reads.

```{r length_clustering, include=TRUE}
hcl <- hclust(as.dist(1-cor(por)));
plot(hcl, main='', ylab='1 - correlation coefficient', cex.lab=1.25, xlab='', sub='');

```

`r OrderFigure()` Similarity of read length distribution.

# Session information

```{r session_info, echo=FALSE}
sessionInfo(); 
```

`r home.url`

***
_END OF DOCUMENT_
