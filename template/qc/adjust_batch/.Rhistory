i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
v[as.integer(names(s))]<-s;
s
v
v<-rep(0, length(cigar));
v
s
length(s)
v<-rep(0, length(cigar));
n<-lapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
if (length(s)>0) v[as.integer(names(s))]<-s;
v
});
n
n<-sapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
if (length(s)>0) v[as.integer(names(s))]<-s;
v
});
n
n[1,1]
n[1, ]
n[2, ]
class(n)
n[, 1]
i
devtools::install_github("zhezhangsh/DEGandMore");
devtools::install_github("zhezhangsh/RoCA");
devtools::install_github("zhezhangsh/RoCA");
devtools::install_github("zhezhangsh/CHOPseq");
devtools::install_github("zhezhangsh/CHOPseq");
devtools::install_github("zhezhangsh/Rnaseq");
devtools::install_github("zhezhangsh/awsomics");
devtools::install_github("zhezhangsh/rchive");
devtools::install_github("zhezhangsh/GtUtility");
library(RoCA)
CreateReport('~/Desktop/sample_normal.yml')
download.file('https://raw.githubusercontent.com/zhezhangsh/RoCA/master/template/demo/sample_normal/sample_normal.yml', 'sample_normal.yml')
dir()
RoCA::CreateReport('sample_normal.yml')
RoCA::CreateReport('sample_normal.yml')
if (is.null(names(exon))) names(exon)<-1:length(exon);
prop.test(0, 1700, 0.002)
relist
?relist
rm(list=ls())
ls()
.libPaths()
library("RoCA", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
InstallDependency()
InstallDependency
detach("package:RoCA", unload=TRUE)
library("RoCA", lib.loc="~/Library/R/3.2/library")
InstallDependency
detach("package:RoCA", unload=TRUE)
InstallDependency(TRUE)
library("RoCA", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
InstallDependency(TRUE)
detach("package:RoCA", unload=TRUE)
library("RoCA", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
?readGAlignments
library(GenomicAlignments)
?readGAlignments
bamfile <- system.file("extdata", "ex1.bam", package="Rsamtools",
mustWork=TRUE)
gal1 <- readGAlignments(bamfile)
gal1
names(gal1)
library(GenomicAlignments)
galp1 <- readGAlignmentPairs(bamfile)
head(galp1)
names(galp1)
---
param <- ScanBamParam(flag=scanBamFlag(isProperPair=TRUE,
isDuplicate=FALSE,
isSecondaryAlignment=FALSE))
galp2 <- readGAlignmentPairs(bamfile, use.names=TRUE, param=param)
galp2
head(galp2)
head(names(galp2))
param <- ScanBamParam(tag=c("MF", "Aq", "NM", "UQ", "H0", "H1"),
what=c('flag', 'mapq', 'cigar', "isize")
)
galp2 <- readGAlignmentPairs(bamfile, use.names=TRUE, param=param)
galp2
param <- ScanBamParam(tag=c("MF", "Aq", "NM", "UQ", "H0", "H1"),
what='cigar')
galp2 <- readGAlignmentPairs(bamfile, use.names=TRUE, param=param)
galp2
x<-galp2
str(x)
class(x$first)
class(x@first)
class(x@second)
class(x@last)
class(x)
a<-x@first
a
param <- ScanBamParam(
what=c('flag', 'mapq', 'cigar', "isize")
)
x <- readGAlignmentPairs(bamfile, use.names=TRUE, param=param)
a<-x@first
a
a$flag
a@flag
a[, 'flag']
b<- elementMetadata(a)
b
table(b[, 1])
x <- readGAlignmentPairs(bamfile, use.names=TRUE)
a<-x@first
a
a@cigar
a
x
countOverlaps(x, a)
countOverlaps(x, a)->y
length(x)
length(y)
table(y)
str(a)
seqlengths(a)
seqlengths(x)
install.packages('servr')
getwd()
library(devtools)
?install_github
install_github('zhezhangsh/RoCA/R', quick=TRUE)
require('GenomicAlignments')
require(chipseq)
q()
library(RoCA)
LoadPackage('Agri')
LoadPackage('AnnotationDbi')
getwd()
setwd('~/Documents/RoCA/template/qc/rnaseq_sample/')
dir()
count.all <- lapply(yml$input$count, function(c) ImportTable(DownloadFile(c, path.input)));
anno <- ImportTable(DownloadFile(yml$input$annotation, path.input));
smpl <- ImportTable(DownloadFile(yml$input$sample, path.input));
if (class(count.all) != 'list') {
count.all <- list('AllRead'=count.all);
}
id1 <- Reduce('intersect', lapply(count.all, rownames));
id2 <- Reduce('intersect', lapply(count.all, colnames));
anno <- anno[rownames(anno) %in% id1, , drop=FALSE];
smpl <- smpl[rownames(smpl) %in% id2, , drop=FALSE];
count.all <- lapply(count.all, function(c) c[rownames(anno), rownames(smpl), drop=FALSE]);
ct <- count.all[[1]];
if (nrow(ct) < 3) stop("Error: cannot proceed with this analysis with less than 3 genes\n");
if (ncol(ct) < 3) stop("Error: cannot proceed with this analysis with less than 3 samples\n");
count.sum1 <- sapply(count.all, function(c) colSums(c, na.rm=TRUE));
count.sum2 <- sapply(count.all, function(c) rowSums(c, na.rm=TRUE));
gn.len <- anno[, prms$annotation$length];
names(gn.len) <- rownames(anno);
name.yaml <- 'rnaseq_sample.yaml';
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'vioplot', 'fpc',
'GenomicRanges', 'RoCA', 'Rnaseq', 'awsomics', 'DEGandMore');
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table'); # <full.path.to.subfolder>=<subfolder.name>
## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }
## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));
## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template
prms <- yml$parameter;
## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]);
## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
count.all <- lapply(yml$input$count, function(c) ImportTable(DownloadFile(c, path.input)));
anno <- ImportTable(DownloadFile(yml$input$annotation, path.input));
smpl <- ImportTable(DownloadFile(yml$input$sample, path.input));
if (class(count.all) != 'list') {
count.all <- list('AllRead'=count.all);
}
id1 <- Reduce('intersect', lapply(count.all, rownames));
id2 <- Reduce('intersect', lapply(count.all, colnames));
anno <- anno[rownames(anno) %in% id1, , drop=FALSE];
smpl <- smpl[rownames(smpl) %in% id2, , drop=FALSE];
count.all <- lapply(count.all, function(c) c[rownames(anno), rownames(smpl), drop=FALSE]);
ct <- count.all[[1]];
if (nrow(ct) < 3) stop("Error: cannot proceed with this analysis with less than 3 genes\n");
if (ncol(ct) < 3) stop("Error: cannot proceed with this analysis with less than 3 samples\n");
count.sum1 <- sapply(count.all, function(c) colSums(c, na.rm=TRUE));
count.sum2 <- sapply(count.all, function(c) rowSums(c, na.rm=TRUE));
gn.len <- anno[, prms$annotation$length];
names(gn.len) <- rownames(anno);
dim(ct)
x <- NormLoess(ct)
dim(x)
head(x)
install_github('zhezhangsh/DEGandMore')
dim(ct)
head(gn.len)
norm <- NormalizeRNAseq(ct, gn.len);
head(norm[[10]])
dir()
CreateReport('rnaseq_sample.yaml')
ls()
ct1 <- norm[length(norm)][[1]]+1;
chrx <- prms$chromosome$f;
chry <- prms$chromosome$m;
id.x <- rownames(anno)[anno[, prms$annotation$chromosome]==chrx];
id.y <- rownames(anno)[anno[, prms$annotation$chromosome]==chry];
id.x <- id.x[!is.na(id.x)];
id.y <- id.y[!is.na(id.y)];
ct.x <- ct1[id.x, , drop=FALSE];
ct.y <- ct1[id.y, , drop=FALSE];
ct.x <- ct.x[rowSums(ct.x) > 0, , drop=FALSE];
ct.y <- ct.y[rowSums(ct.y) > 0, , drop=FALSE];
km.x <- pamk(colMeans(log2(ct.x+1)), krange=1:min(5, ncol(ct.x)));
km.y <- pamk(colMeans(log2(ct.y+1)), krange=1:min(5, ncol(ct.y)));
str(km.x)
str(km.y)
colMeans(log2(ct.x+1))
colMeans(log2(ct.y+1))
colMeans(log2(ct.y+1))->a
barplot(a)
x <- cbind(colMeans(log2(ct.x+1)), colMeans(log2(ct.y+1)))
x
pamk(x)
str(km.x)
str(km.y)
hist(x[, 1])
hist(x[, 2])
ct1 <- norm[length(norm)][[1]]+1;
chrx <- prms$chromosome$f;
chry <- prms$chromosome$m;
id.x <- rownames(anno)[anno[, prms$annotation$chromosome]==chrx];
id.y <- rownames(anno)[anno[, prms$annotation$chromosome]==chry];
id.x <- id.x[!is.na(id.x)];
id.y <- id.y[!is.na(id.y)];
ct.x <- ct1[id.x, , drop=FALSE];
ct.y <- ct1[id.y, , drop=FALSE];
ct.x <- ct.x[rowSums(ct.x) > 0, , drop=FALSE];
ct.y <- ct.y[rowSums(ct.y) > 0, , drop=FALSE];
msg <- '';
if (nrow(ct.x)>=5 & nrow(ct.y)>=5) {
#km.x <- pamk(colMeans(log2(ct.x+1)), krange=1:min(5, ncol(ct.x)));
#km.y <- pamk(colMeans(log2(ct.y+1)), krange=1:min(5, ncol(ct.y)));
nc.x <- km.x$nc;
nc.y <- km.y$nc;
if (nc.x==2 & nc.y==2) msg <- 'Samples can be classified into 2 groups by both X and Y genes.' else if (nc.x==2)
msg <- 'Samples can be classified into 2 groups only by X genes.' else if (nc.y==2)
msg <- 'Samples can be classified into 2 groups only by Y genes.' else
msg <- 'Samples cannot be classified into 2 groups by neither X nor Y genes.'
km.xy <-
fig.h <- 8;
} else {
msg <- 'There are not enough X/Y genes with detectable expression to make valid gender prediction.';
fig.h <- 1;
}
km.xy <- pamk(cbind(colMeans(log2(ct.x+1)), colMeans(log2(ct.y+1))), krange=1:min(5, ncol(ct.x)));
str(km.xy)
prd <- split(rownames(x), km.xy$pamobject$clustering);
prd
ms <- sapply(prd, function(prd) colMeans(x[prd, 1]));
ms <- sapply(prd, function(prd) colMeans(x[prd, ]));
ms
cor(ms)
ms
prd
if (fig.h==8) {
x <- cbind(colMeans(log2(ct.x+1)), colMeans(log2(ct.y+1)));
if (nc.xy == 2) {
prd <- split(rownames(x), km.xy$pamobject$clustering);
ms <- sapply(prd, function(prd) colMeans(x[prd, ]));
prd.xy <- rep('NA', nrow(x));
names(prd.xy) <- rownames(x);
if (ms[1,1]>ms[1,2] & ms[2,1]<ms[2,2]) {
prd.xy[prd[[1]]] <- 'F';
prd.xy[prd[[2]]] <- 'M';
}
if (ms[1,1]<ms[1,2] & ms[2,1]>ms[2,2]) {
prd.xy[prd[[1]]] <- 'M';
prd.xy[prd[[2]]] <- 'F';
}
} else prd.xy <- rep('NA', nrow(x));
} else prd.xy <- rep('NA', nrow(x));
#   if (nc.x==2) {
#     prd <- split(rownames(x), km.x$pamobject$clustering);
#     ms <- sapply(prd, function(prd) mean(x[prd, 1]));
#     prd.x <- rep('F', nrow(x));
#     names(prd.x) <- rownames(x);
#     if (ms[1] > ms[2]) prd.x[prd[[2]]] <- 'M' else prd.x[prd[[1]]] <- 'M';
#   } else prd.x <- rep('NA', nrow(x));
#   if (nc.y==2) {
#     prd <- split(rownames(x), km.y$pamobject$clustering);
#     ms <- sapply(prd, function(prd) mean(x[prd, 2]));
#     prd.y <- rep('F', nrow(x));
#     names(prd.y) <- rownames(x);
#     if (ms[1] > ms[2]) prd.y[prd[[1]]] <- 'M' else prd.y[prd[[2]]] <- 'M';
#   } else prd.y <- rep('NA', nrow(x));
#
col <- rep('darkgrey', nrow(x));
col[prd.xy=='M' & prd.xy=='M'] <- 'blue';
col[prd.xy=='F' & prd.xy=='F'] <- 'red';
par(mar=c(5,5,2,2));
plot(x[, 1], x[, 2], pch='*', col=col, cex=min(4, max(0.5, 64/nrow(x))), xlab="Log2(Read_Count+1), average of X genes",
ylab="Log2(Read_Count+1), average of Y genes", cex.lab=1.25);
legend('topright', pch='*', col=c('red', 'blue', 'darkgrey'), bty='n',
legend=c('Predicted to be female', 'Predicted to be male', 'Undetermined'));
title(main="Gender prediction", cex.main=1.5);
tbl <- data.frame(Mean_X_Genes = x[, 1], Pred_X_Genes = prd.x,
Mean_Y_Genes = x[, 2], Pred_Y_Genes = prd.y, smpl[rownames(x), ]);
} else {
par(mar=c(0,0,0,0));
plot(0, type='n', axes=FALSE, xlab='', ylab='');
text(1, 0, pos=1, label='No gender prediction can be made:\n not enough X/Y genes with detectable expression.', cex=1.5);
tbl <- matrix(nr=1, nc=1, dimnames = list(NA, 'No gender prediction available'));
}
fn <- CreateDatatable(FormatNumeric(tbl), paste(path.tbl, 'gender_prediction.html', sep='/'));
if (fig.h==8) {
x <- cbind(colMeans(log2(ct.x+1)), colMeans(log2(ct.y+1)));
if (nc.xy == 2) {
prd <- split(rownames(x), km.xy$pamobject$clustering);
ms <- sapply(prd, function(prd) colMeans(x[prd, ]));
prd.xy <- rep('NA', nrow(x));
names(prd.xy) <- rownames(x);
if (ms[1,1]>ms[1,2] & ms[2,1]<ms[2,2]) {
prd.xy[prd[[1]]] <- 'F';
prd.xy[prd[[2]]] <- 'M';
}
if (ms[1,1]<ms[1,2] & ms[2,1]>ms[2,2]) {
prd.xy[prd[[1]]] <- 'M';
prd.xy[prd[[2]]] <- 'F';
}
} else prd.xy <- rep('NA', nrow(x));
#   if (nc.x==2) {
#     prd <- split(rownames(x), km.x$pamobject$clustering);
#     ms <- sapply(prd, function(prd) mean(x[prd, 1]));
#     prd.x <- rep('F', nrow(x));
#     names(prd.x) <- rownames(x);
#     if (ms[1] > ms[2]) prd.x[prd[[2]]] <- 'M' else prd.x[prd[[1]]] <- 'M';
#   } else prd.x <- rep('NA', nrow(x));
#   if (nc.y==2) {
#     prd <- split(rownames(x), km.y$pamobject$clustering);
#     ms <- sapply(prd, function(prd) mean(x[prd, 2]));
#     prd.y <- rep('F', nrow(x));
#     names(prd.y) <- rownames(x);
#     if (ms[1] > ms[2]) prd.y[prd[[1]]] <- 'M' else prd.y[prd[[2]]] <- 'M';
#   } else prd.y <- rep('NA', nrow(x));
#
col <- rep('darkgrey', nrow(x));
col[prd.xy=='M' & prd.xy=='M'] <- 'blue';
col[prd.xy=='F' & prd.xy=='F'] <- 'red';
par(mar=c(5,5,2,2));
plot(x[, 1], x[, 2], pch='*', col=col, cex=min(4, max(0.5, 64/nrow(x))), xlab="Log2(Read_Count+1), average of X genes",
ylab="Log2(Read_Count+1), average of Y genes", cex.lab=1.25);
legend('topright', pch='*', col=c('red', 'blue', 'darkgrey'), bty='n',
legend=c('Predicted to be female', 'Predicted to be male', 'Undetermined'));
title(main="Gender prediction", cex.main=1.5);
tbl <- data.frame(Mean_X_Genes = x[, 1], Pred_X_Genes = prd.x,
Mean_Y_Genes = x[, 2], Pred_Y_Genes = prd.y, smpl[rownames(x), ]);
} else {
par(mar=c(0,0,0,0));
plot(0, type='n', axes=FALSE, xlab='', ylab='');
text(1, 0, pos=1, label='No gender prediction can be made:\n not enough X/Y genes with detectable expression.', cex=1.5);
tbl <- matrix(nr=1, nc=1, dimnames = list(NA, 'No gender prediction available'));
}
fn <- CreateDatatable(FormatNumeric(tbl), paste(path.tbl, 'gender_prediction.html', sep='/'));
ct1 <- norm[length(norm)][[1]]+1;
chrx <- prms$chromosome$f;
chry <- prms$chromosome$m;
id.x <- rownames(anno)[anno[, prms$annotation$chromosome]==chrx];
id.y <- rownames(anno)[anno[, prms$annotation$chromosome]==chry];
id.x <- id.x[!is.na(id.x)];
id.y <- id.y[!is.na(id.y)];
ct.x <- ct1[id.x, , drop=FALSE];
ct.y <- ct1[id.y, , drop=FALSE];
ct.x <- ct.x[rowSums(ct.x) > 0, , drop=FALSE];
ct.y <- ct.y[rowSums(ct.y) > 0, , drop=FALSE];
msg <- '';
if (nrow(ct.x)>=5 & nrow(ct.y)>=5) {
#   km.x <- pamk(colMeans(log2(ct.x+1)), krange=1:min(5, ncol(ct.x)));
#   km.y <- pamk(colMeans(log2(ct.y+1)), krange=1:min(5, ncol(ct.y)));
#   nc.x <- km.x$nc;
#   nc.y <- km.y$nc;
#   if (nc.x==2 & nc.y==2) msg <- 'Samples can be classified into 2 groups by both X and Y genes.' else if (nc.x==2)
#     msg <- 'Samples can be classified into 2 groups only by X genes.' else if (nc.y==2)
#       msg <- 'Samples can be classified into 2 groups only by Y genes.' else
#         msg <- 'Samples cannot be classified into 2 groups by neither X nor Y genes.'
km.xy <- pamk(cbind(colMeans(log2(ct.x+1)), colMeans(log2(ct.y+1))), krange=1:min(5, ncol(ct.x)));
nc.xy <- km.xy$nc;
if (nc.xy == 2) msg <- 'Samples can be classified into 2 groups by X/Y genes.' else
msg <- 'Samples cannot be classified into 2 groups by X/Y genes.'
fig.h <- 8;
} else {
msg <- 'There are not enough X/Y genes with detectable expression to make valid gender prediction.';
fig.h <- 1;
}
if (fig.h==8) {
x <- cbind(colMeans(log2(ct.x+1)), colMeans(log2(ct.y+1)));
if (nc.xy == 2) {
prd <- split(rownames(x), km.xy$pamobject$clustering);
ms <- sapply(prd, function(prd) colMeans(x[prd, ]));
prd.xy <- rep('NA', nrow(x));
names(prd.xy) <- rownames(x);
if (ms[1,1]>ms[1,2] & ms[2,1]<ms[2,2]) {
prd.xy[prd[[1]]] <- 'F';
prd.xy[prd[[2]]] <- 'M';
}
if (ms[1,1]<ms[1,2] & ms[2,1]>ms[2,2]) {
prd.xy[prd[[1]]] <- 'M';
prd.xy[prd[[2]]] <- 'F';
}
} else prd.xy <- rep('NA', nrow(x));
#   if (nc.x==2) {
#     prd <- split(rownames(x), km.x$pamobject$clustering);
#     ms <- sapply(prd, function(prd) mean(x[prd, 1]));
#     prd.x <- rep('F', nrow(x));
#     names(prd.x) <- rownames(x);
#     if (ms[1] > ms[2]) prd.x[prd[[2]]] <- 'M' else prd.x[prd[[1]]] <- 'M';
#   } else prd.x <- rep('NA', nrow(x));
#   if (nc.y==2) {
#     prd <- split(rownames(x), km.y$pamobject$clustering);
#     ms <- sapply(prd, function(prd) mean(x[prd, 2]));
#     prd.y <- rep('F', nrow(x));
#     names(prd.y) <- rownames(x);
#     if (ms[1] > ms[2]) prd.y[prd[[1]]] <- 'M' else prd.y[prd[[2]]] <- 'M';
#   } else prd.y <- rep('NA', nrow(x));
#
col <- rep('darkgrey', nrow(x));
col[prd.xy=='M' & prd.xy=='M'] <- 'blue';
col[prd.xy=='F' & prd.xy=='F'] <- 'red';
par(mar=c(5,5,2,2));
plot(x[, 1], x[, 2], pch='*', col=col, cex=min(4, max(0.5, 64/nrow(x))), xlab="Log2(Read_Count+1), average of X genes",
ylab="Log2(Read_Count+1), average of Y genes", cex.lab=1.25);
legend('topright', pch='*', col=c('red', 'blue', 'darkgrey'), bty='n',
legend=c('Predicted to be female', 'Predicted to be male', 'Undetermined'));
title(main="Gender prediction", cex.main=1.5);
tbl <- data.frame(Mean_X_Genes = x[, 1], Pred_X_Genes = prd.x,
Mean_Y_Genes = x[, 2], Pred_Y_Genes = prd.y, smpl[rownames(x), ]);
} else {
par(mar=c(0,0,0,0));
plot(0, type='n', axes=FALSE, xlab='', ylab='');
text(1, 0, pos=1, label='No gender prediction can be made:\n not enough X/Y genes with detectable expression.', cex=1.5);
tbl <- matrix(nr=1, nc=1, dimnames = list(NA, 'No gender prediction available'));
}
fn <- CreateDatatable(FormatNumeric(tbl), paste(path.tbl, 'gender_prediction.html', sep='/'));
if (fig.h==8) {
x <- cbind(colMeans(log2(ct.x+1)), colMeans(log2(ct.y+1)));
if (nc.xy == 2) {
prd <- split(rownames(x), km.xy$pamobject$clustering);
ms <- sapply(prd, function(prd) colMeans(x[prd, ]));
prd.xy <- rep('NA', nrow(x));
names(prd.xy) <- rownames(x);
if (ms[1,1]>ms[1,2] & ms[2,1]<ms[2,2]) {
prd.xy[prd[[1]]] <- 'F';
prd.xy[prd[[2]]] <- 'M';
}
if (ms[1,1]<ms[1,2] & ms[2,1]>ms[2,2]) {
prd.xy[prd[[1]]] <- 'M';
prd.xy[prd[[2]]] <- 'F';
}
} else prd.xy <- rep('NA', nrow(x));
#   if (nc.x==2) {
#     prd <- split(rownames(x), km.x$pamobject$clustering);
#     ms <- sapply(prd, function(prd) mean(x[prd, 1]));
#     prd.x <- rep('F', nrow(x));
#     names(prd.x) <- rownames(x);
#     if (ms[1] > ms[2]) prd.x[prd[[2]]] <- 'M' else prd.x[prd[[1]]] <- 'M';
#   } else prd.x <- rep('NA', nrow(x));
#   if (nc.y==2) {
#     prd <- split(rownames(x), km.y$pamobject$clustering);
#     ms <- sapply(prd, function(prd) mean(x[prd, 2]));
#     prd.y <- rep('F', nrow(x));
#     names(prd.y) <- rownames(x);
#     if (ms[1] > ms[2]) prd.y[prd[[1]]] <- 'M' else prd.y[prd[[2]]] <- 'M';
#   } else prd.y <- rep('NA', nrow(x));
#
col <- rep('darkgrey', nrow(x));
col[prd.xy=='M' & prd.xy=='M'] <- 'blue';
col[prd.xy=='F' & prd.xy=='F'] <- 'red';
par(mar=c(5,5,2,2));
plot(x[, 1], x[, 2], pch='*', col=col, cex=min(4, max(0.5, 64/nrow(x))), xlab="Log2(Read_Count+1), average of X genes",
ylab="Log2(Read_Count+1), average of Y genes", cex.lab=1.25);
legend('topright', pch='*', col=c('red', 'blue', 'darkgrey'), bty='n',
legend=c('Predicted to be female', 'Predicted to be male', 'Undetermined'));
title(main="Gender prediction", cex.main=1.5);
tbl <- data.frame(Mean_X_Genes = x[, 1], Mean_Y_Genes = x[, 2], Gender_Prediction = prd.xy, smpl[rownames(x), ]);
} else {
par(mar=c(0,0,0,0));
plot(0, type='n', axes=FALSE, xlab='', ylab='');
text(1, 0, pos=1, label='No gender prediction can be made:\n not enough X/Y genes with detectable expression.', cex=1.5);
tbl <- matrix(nr=1, nc=1, dimnames = list(NA, 'No gender prediction available'));
}
fn <- CreateDatatable(FormatNumeric(tbl), paste(path.tbl, 'gender_prediction.html', sep='/'));
CreateReport('rnaseq_sample.yaml')
name.yaml <- 'adjust_batch.yaml';
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'gplots', 'sva', 'limma'', 'RoCA', 'awsomics');
rm(list=ls())
setwd('../adjust_batch/')
CreateReport('adjust_batch.yaml')
ls()
