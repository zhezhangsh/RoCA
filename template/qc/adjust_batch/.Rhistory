ct <- count.all[[1]];
if (nrow(ct) < 3) stop("Error: cannot proceed with this analysis with less than 3 genes\n");
if (ncol(ct) < 3) stop("Error: cannot proceed with this analysis with less than 3 samples\n");
count.sum1 <- sapply(count.all, function(c) colSums(c, na.rm=TRUE));
count.sum2 <- sapply(count.all, function(c) rowSums(c, na.rm=TRUE));
gn.len <- anno[, prms$annotation$length];
names(gn.len) <- rownames(anno);
dim(ct)
x <- NormLoess(ct)
dim(x)
head(x)
install_github('zhezhangsh/DEGandMore')
dim(ct)
head(gn.len)
norm <- NormalizeRNAseq(ct, gn.len);
head(norm[[10]])
dir()
CreateReport('rnaseq_sample.yaml')
ls()
ct1 <- norm[length(norm)][[1]]+1;
chrx <- prms$chromosome$f;
chry <- prms$chromosome$m;
id.x <- rownames(anno)[anno[, prms$annotation$chromosome]==chrx];
id.y <- rownames(anno)[anno[, prms$annotation$chromosome]==chry];
id.x <- id.x[!is.na(id.x)];
id.y <- id.y[!is.na(id.y)];
ct.x <- ct1[id.x, , drop=FALSE];
ct.y <- ct1[id.y, , drop=FALSE];
ct.x <- ct.x[rowSums(ct.x) > 0, , drop=FALSE];
ct.y <- ct.y[rowSums(ct.y) > 0, , drop=FALSE];
km.x <- pamk(colMeans(log2(ct.x+1)), krange=1:min(5, ncol(ct.x)));
km.y <- pamk(colMeans(log2(ct.y+1)), krange=1:min(5, ncol(ct.y)));
str(km.x)
str(km.y)
colMeans(log2(ct.x+1))
colMeans(log2(ct.y+1))
colMeans(log2(ct.y+1))->a
barplot(a)
x <- cbind(colMeans(log2(ct.x+1)), colMeans(log2(ct.y+1)))
x
pamk(x)
str(km.x)
str(km.y)
hist(x[, 1])
hist(x[, 2])
ct1 <- norm[length(norm)][[1]]+1;
chrx <- prms$chromosome$f;
chry <- prms$chromosome$m;
id.x <- rownames(anno)[anno[, prms$annotation$chromosome]==chrx];
id.y <- rownames(anno)[anno[, prms$annotation$chromosome]==chry];
id.x <- id.x[!is.na(id.x)];
id.y <- id.y[!is.na(id.y)];
ct.x <- ct1[id.x, , drop=FALSE];
ct.y <- ct1[id.y, , drop=FALSE];
ct.x <- ct.x[rowSums(ct.x) > 0, , drop=FALSE];
ct.y <- ct.y[rowSums(ct.y) > 0, , drop=FALSE];
msg <- '';
if (nrow(ct.x)>=5 & nrow(ct.y)>=5) {
#km.x <- pamk(colMeans(log2(ct.x+1)), krange=1:min(5, ncol(ct.x)));
#km.y <- pamk(colMeans(log2(ct.y+1)), krange=1:min(5, ncol(ct.y)));
nc.x <- km.x$nc;
nc.y <- km.y$nc;
if (nc.x==2 & nc.y==2) msg <- 'Samples can be classified into 2 groups by both X and Y genes.' else if (nc.x==2)
msg <- 'Samples can be classified into 2 groups only by X genes.' else if (nc.y==2)
msg <- 'Samples can be classified into 2 groups only by Y genes.' else
msg <- 'Samples cannot be classified into 2 groups by neither X nor Y genes.'
km.xy <-
fig.h <- 8;
} else {
msg <- 'There are not enough X/Y genes with detectable expression to make valid gender prediction.';
fig.h <- 1;
}
km.xy <- pamk(cbind(colMeans(log2(ct.x+1)), colMeans(log2(ct.y+1))), krange=1:min(5, ncol(ct.x)));
str(km.xy)
prd <- split(rownames(x), km.xy$pamobject$clustering);
prd
ms <- sapply(prd, function(prd) colMeans(x[prd, 1]));
ms <- sapply(prd, function(prd) colMeans(x[prd, ]));
ms
cor(ms)
ms
prd
if (fig.h==8) {
x <- cbind(colMeans(log2(ct.x+1)), colMeans(log2(ct.y+1)));
if (nc.xy == 2) {
prd <- split(rownames(x), km.xy$pamobject$clustering);
ms <- sapply(prd, function(prd) colMeans(x[prd, ]));
prd.xy <- rep('NA', nrow(x));
names(prd.xy) <- rownames(x);
if (ms[1,1]>ms[1,2] & ms[2,1]<ms[2,2]) {
prd.xy[prd[[1]]] <- 'F';
prd.xy[prd[[2]]] <- 'M';
}
if (ms[1,1]<ms[1,2] & ms[2,1]>ms[2,2]) {
prd.xy[prd[[1]]] <- 'M';
prd.xy[prd[[2]]] <- 'F';
}
} else prd.xy <- rep('NA', nrow(x));
} else prd.xy <- rep('NA', nrow(x));
#   if (nc.x==2) {
#     prd <- split(rownames(x), km.x$pamobject$clustering);
#     ms <- sapply(prd, function(prd) mean(x[prd, 1]));
#     prd.x <- rep('F', nrow(x));
#     names(prd.x) <- rownames(x);
#     if (ms[1] > ms[2]) prd.x[prd[[2]]] <- 'M' else prd.x[prd[[1]]] <- 'M';
#   } else prd.x <- rep('NA', nrow(x));
#   if (nc.y==2) {
#     prd <- split(rownames(x), km.y$pamobject$clustering);
#     ms <- sapply(prd, function(prd) mean(x[prd, 2]));
#     prd.y <- rep('F', nrow(x));
#     names(prd.y) <- rownames(x);
#     if (ms[1] > ms[2]) prd.y[prd[[1]]] <- 'M' else prd.y[prd[[2]]] <- 'M';
#   } else prd.y <- rep('NA', nrow(x));
#
col <- rep('darkgrey', nrow(x));
col[prd.xy=='M' & prd.xy=='M'] <- 'blue';
col[prd.xy=='F' & prd.xy=='F'] <- 'red';
par(mar=c(5,5,2,2));
plot(x[, 1], x[, 2], pch='*', col=col, cex=min(4, max(0.5, 64/nrow(x))), xlab="Log2(Read_Count+1), average of X genes",
ylab="Log2(Read_Count+1), average of Y genes", cex.lab=1.25);
legend('topright', pch='*', col=c('red', 'blue', 'darkgrey'), bty='n',
legend=c('Predicted to be female', 'Predicted to be male', 'Undetermined'));
title(main="Gender prediction", cex.main=1.5);
tbl <- data.frame(Mean_X_Genes = x[, 1], Pred_X_Genes = prd.x,
Mean_Y_Genes = x[, 2], Pred_Y_Genes = prd.y, smpl[rownames(x), ]);
} else {
par(mar=c(0,0,0,0));
plot(0, type='n', axes=FALSE, xlab='', ylab='');
text(1, 0, pos=1, label='No gender prediction can be made:\n not enough X/Y genes with detectable expression.', cex=1.5);
tbl <- matrix(nr=1, nc=1, dimnames = list(NA, 'No gender prediction available'));
}
fn <- CreateDatatable(FormatNumeric(tbl), paste(path.tbl, 'gender_prediction.html', sep='/'));
if (fig.h==8) {
x <- cbind(colMeans(log2(ct.x+1)), colMeans(log2(ct.y+1)));
if (nc.xy == 2) {
prd <- split(rownames(x), km.xy$pamobject$clustering);
ms <- sapply(prd, function(prd) colMeans(x[prd, ]));
prd.xy <- rep('NA', nrow(x));
names(prd.xy) <- rownames(x);
if (ms[1,1]>ms[1,2] & ms[2,1]<ms[2,2]) {
prd.xy[prd[[1]]] <- 'F';
prd.xy[prd[[2]]] <- 'M';
}
if (ms[1,1]<ms[1,2] & ms[2,1]>ms[2,2]) {
prd.xy[prd[[1]]] <- 'M';
prd.xy[prd[[2]]] <- 'F';
}
} else prd.xy <- rep('NA', nrow(x));
#   if (nc.x==2) {
#     prd <- split(rownames(x), km.x$pamobject$clustering);
#     ms <- sapply(prd, function(prd) mean(x[prd, 1]));
#     prd.x <- rep('F', nrow(x));
#     names(prd.x) <- rownames(x);
#     if (ms[1] > ms[2]) prd.x[prd[[2]]] <- 'M' else prd.x[prd[[1]]] <- 'M';
#   } else prd.x <- rep('NA', nrow(x));
#   if (nc.y==2) {
#     prd <- split(rownames(x), km.y$pamobject$clustering);
#     ms <- sapply(prd, function(prd) mean(x[prd, 2]));
#     prd.y <- rep('F', nrow(x));
#     names(prd.y) <- rownames(x);
#     if (ms[1] > ms[2]) prd.y[prd[[1]]] <- 'M' else prd.y[prd[[2]]] <- 'M';
#   } else prd.y <- rep('NA', nrow(x));
#
col <- rep('darkgrey', nrow(x));
col[prd.xy=='M' & prd.xy=='M'] <- 'blue';
col[prd.xy=='F' & prd.xy=='F'] <- 'red';
par(mar=c(5,5,2,2));
plot(x[, 1], x[, 2], pch='*', col=col, cex=min(4, max(0.5, 64/nrow(x))), xlab="Log2(Read_Count+1), average of X genes",
ylab="Log2(Read_Count+1), average of Y genes", cex.lab=1.25);
legend('topright', pch='*', col=c('red', 'blue', 'darkgrey'), bty='n',
legend=c('Predicted to be female', 'Predicted to be male', 'Undetermined'));
title(main="Gender prediction", cex.main=1.5);
tbl <- data.frame(Mean_X_Genes = x[, 1], Pred_X_Genes = prd.x,
Mean_Y_Genes = x[, 2], Pred_Y_Genes = prd.y, smpl[rownames(x), ]);
} else {
par(mar=c(0,0,0,0));
plot(0, type='n', axes=FALSE, xlab='', ylab='');
text(1, 0, pos=1, label='No gender prediction can be made:\n not enough X/Y genes with detectable expression.', cex=1.5);
tbl <- matrix(nr=1, nc=1, dimnames = list(NA, 'No gender prediction available'));
}
fn <- CreateDatatable(FormatNumeric(tbl), paste(path.tbl, 'gender_prediction.html', sep='/'));
ct1 <- norm[length(norm)][[1]]+1;
chrx <- prms$chromosome$f;
chry <- prms$chromosome$m;
id.x <- rownames(anno)[anno[, prms$annotation$chromosome]==chrx];
id.y <- rownames(anno)[anno[, prms$annotation$chromosome]==chry];
id.x <- id.x[!is.na(id.x)];
id.y <- id.y[!is.na(id.y)];
ct.x <- ct1[id.x, , drop=FALSE];
ct.y <- ct1[id.y, , drop=FALSE];
ct.x <- ct.x[rowSums(ct.x) > 0, , drop=FALSE];
ct.y <- ct.y[rowSums(ct.y) > 0, , drop=FALSE];
msg <- '';
if (nrow(ct.x)>=5 & nrow(ct.y)>=5) {
#   km.x <- pamk(colMeans(log2(ct.x+1)), krange=1:min(5, ncol(ct.x)));
#   km.y <- pamk(colMeans(log2(ct.y+1)), krange=1:min(5, ncol(ct.y)));
#   nc.x <- km.x$nc;
#   nc.y <- km.y$nc;
#   if (nc.x==2 & nc.y==2) msg <- 'Samples can be classified into 2 groups by both X and Y genes.' else if (nc.x==2)
#     msg <- 'Samples can be classified into 2 groups only by X genes.' else if (nc.y==2)
#       msg <- 'Samples can be classified into 2 groups only by Y genes.' else
#         msg <- 'Samples cannot be classified into 2 groups by neither X nor Y genes.'
km.xy <- pamk(cbind(colMeans(log2(ct.x+1)), colMeans(log2(ct.y+1))), krange=1:min(5, ncol(ct.x)));
nc.xy <- km.xy$nc;
if (nc.xy == 2) msg <- 'Samples can be classified into 2 groups by X/Y genes.' else
msg <- 'Samples cannot be classified into 2 groups by X/Y genes.'
fig.h <- 8;
} else {
msg <- 'There are not enough X/Y genes with detectable expression to make valid gender prediction.';
fig.h <- 1;
}
if (fig.h==8) {
x <- cbind(colMeans(log2(ct.x+1)), colMeans(log2(ct.y+1)));
if (nc.xy == 2) {
prd <- split(rownames(x), km.xy$pamobject$clustering);
ms <- sapply(prd, function(prd) colMeans(x[prd, ]));
prd.xy <- rep('NA', nrow(x));
names(prd.xy) <- rownames(x);
if (ms[1,1]>ms[1,2] & ms[2,1]<ms[2,2]) {
prd.xy[prd[[1]]] <- 'F';
prd.xy[prd[[2]]] <- 'M';
}
if (ms[1,1]<ms[1,2] & ms[2,1]>ms[2,2]) {
prd.xy[prd[[1]]] <- 'M';
prd.xy[prd[[2]]] <- 'F';
}
} else prd.xy <- rep('NA', nrow(x));
#   if (nc.x==2) {
#     prd <- split(rownames(x), km.x$pamobject$clustering);
#     ms <- sapply(prd, function(prd) mean(x[prd, 1]));
#     prd.x <- rep('F', nrow(x));
#     names(prd.x) <- rownames(x);
#     if (ms[1] > ms[2]) prd.x[prd[[2]]] <- 'M' else prd.x[prd[[1]]] <- 'M';
#   } else prd.x <- rep('NA', nrow(x));
#   if (nc.y==2) {
#     prd <- split(rownames(x), km.y$pamobject$clustering);
#     ms <- sapply(prd, function(prd) mean(x[prd, 2]));
#     prd.y <- rep('F', nrow(x));
#     names(prd.y) <- rownames(x);
#     if (ms[1] > ms[2]) prd.y[prd[[1]]] <- 'M' else prd.y[prd[[2]]] <- 'M';
#   } else prd.y <- rep('NA', nrow(x));
#
col <- rep('darkgrey', nrow(x));
col[prd.xy=='M' & prd.xy=='M'] <- 'blue';
col[prd.xy=='F' & prd.xy=='F'] <- 'red';
par(mar=c(5,5,2,2));
plot(x[, 1], x[, 2], pch='*', col=col, cex=min(4, max(0.5, 64/nrow(x))), xlab="Log2(Read_Count+1), average of X genes",
ylab="Log2(Read_Count+1), average of Y genes", cex.lab=1.25);
legend('topright', pch='*', col=c('red', 'blue', 'darkgrey'), bty='n',
legend=c('Predicted to be female', 'Predicted to be male', 'Undetermined'));
title(main="Gender prediction", cex.main=1.5);
tbl <- data.frame(Mean_X_Genes = x[, 1], Pred_X_Genes = prd.x,
Mean_Y_Genes = x[, 2], Pred_Y_Genes = prd.y, smpl[rownames(x), ]);
} else {
par(mar=c(0,0,0,0));
plot(0, type='n', axes=FALSE, xlab='', ylab='');
text(1, 0, pos=1, label='No gender prediction can be made:\n not enough X/Y genes with detectable expression.', cex=1.5);
tbl <- matrix(nr=1, nc=1, dimnames = list(NA, 'No gender prediction available'));
}
fn <- CreateDatatable(FormatNumeric(tbl), paste(path.tbl, 'gender_prediction.html', sep='/'));
if (fig.h==8) {
x <- cbind(colMeans(log2(ct.x+1)), colMeans(log2(ct.y+1)));
if (nc.xy == 2) {
prd <- split(rownames(x), km.xy$pamobject$clustering);
ms <- sapply(prd, function(prd) colMeans(x[prd, ]));
prd.xy <- rep('NA', nrow(x));
names(prd.xy) <- rownames(x);
if (ms[1,1]>ms[1,2] & ms[2,1]<ms[2,2]) {
prd.xy[prd[[1]]] <- 'F';
prd.xy[prd[[2]]] <- 'M';
}
if (ms[1,1]<ms[1,2] & ms[2,1]>ms[2,2]) {
prd.xy[prd[[1]]] <- 'M';
prd.xy[prd[[2]]] <- 'F';
}
} else prd.xy <- rep('NA', nrow(x));
#   if (nc.x==2) {
#     prd <- split(rownames(x), km.x$pamobject$clustering);
#     ms <- sapply(prd, function(prd) mean(x[prd, 1]));
#     prd.x <- rep('F', nrow(x));
#     names(prd.x) <- rownames(x);
#     if (ms[1] > ms[2]) prd.x[prd[[2]]] <- 'M' else prd.x[prd[[1]]] <- 'M';
#   } else prd.x <- rep('NA', nrow(x));
#   if (nc.y==2) {
#     prd <- split(rownames(x), km.y$pamobject$clustering);
#     ms <- sapply(prd, function(prd) mean(x[prd, 2]));
#     prd.y <- rep('F', nrow(x));
#     names(prd.y) <- rownames(x);
#     if (ms[1] > ms[2]) prd.y[prd[[1]]] <- 'M' else prd.y[prd[[2]]] <- 'M';
#   } else prd.y <- rep('NA', nrow(x));
#
col <- rep('darkgrey', nrow(x));
col[prd.xy=='M' & prd.xy=='M'] <- 'blue';
col[prd.xy=='F' & prd.xy=='F'] <- 'red';
par(mar=c(5,5,2,2));
plot(x[, 1], x[, 2], pch='*', col=col, cex=min(4, max(0.5, 64/nrow(x))), xlab="Log2(Read_Count+1), average of X genes",
ylab="Log2(Read_Count+1), average of Y genes", cex.lab=1.25);
legend('topright', pch='*', col=c('red', 'blue', 'darkgrey'), bty='n',
legend=c('Predicted to be female', 'Predicted to be male', 'Undetermined'));
title(main="Gender prediction", cex.main=1.5);
tbl <- data.frame(Mean_X_Genes = x[, 1], Mean_Y_Genes = x[, 2], Gender_Prediction = prd.xy, smpl[rownames(x), ]);
} else {
par(mar=c(0,0,0,0));
plot(0, type='n', axes=FALSE, xlab='', ylab='');
text(1, 0, pos=1, label='No gender prediction can be made:\n not enough X/Y genes with detectable expression.', cex=1.5);
tbl <- matrix(nr=1, nc=1, dimnames = list(NA, 'No gender prediction available'));
}
fn <- CreateDatatable(FormatNumeric(tbl), paste(path.tbl, 'gender_prediction.html', sep='/'));
CreateReport('rnaseq_sample.yaml')
name.yaml <- 'adjust_batch.yaml';
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'gplots', 'sva', 'limma'', 'RoCA', 'awsomics');
rm(list=ls())
setwd('../adjust_batch/')
CreateReport('adjust_batch.yaml')
ls()
dir()
s <- readRDS('sample_gas1.rds')
s
s[1:2, ]
name.yaml <- 'adjust_batch.yaml';
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'gplots', 'sva', 'limma', 'RoCA', 'awsomics');
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table'); # <full.path.to.subfolder>=<subfolder.name>
## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }
## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));
## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template
prms <- yml$parameter;
## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]);
## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
# Load input data
mtr<-ImportTable(DownloadFile(yml$input$matrix, path = path.input)); # full data matrix; columns are samples/rows are variables
smp<-ImportTable(DownloadFile(yml$input$sample, path = path.input)); # sample description; rows must match columns of data matrix
mtr<-as.matrix(mtr);
CreateDatatable(smp, paste(path.tbl, 'sample.html', sep='/'))
saveRDS(mtr, paste(path.input, TrimPath(yml$input$matrix), sep='/'));
saveRDS(smp, paste(path.input, TrimPath(yml$input$sample), sep='/'));
# Match sample IDs
smp<-smp[rownames(smp) %in% colnames(mtr), , drop=FALSE];
mtr<-mtr[, rownames(smp)];
if (nrow(smp) < 2) stop('Not enough samples to perform the analysis.\n');
# Make all columns factors
for (i in 1:ncol(smp)) if (!is.numeric(smp[[i]])) smp[[i]]<-as.factor(as.vector(smp[[i]]));
# Variable names
v0<-yml$parameter$interest; # variable(s) of interest
v1<-yml$parameter$batch; # known batch effect variable(s)
v0<-v0[v0 %in% colnames(smp)];
v1<-v1[v1 %in% colnames(smp)];
if (length(v0) < 1) stop('No variable of interest was specified. \n');
nlvl<-sapply(colnames(smp), function(nm) length(unique(as.vector(smp[, nm]))));
clss<-sapply(1:ncol(smp), function(i) class(smp[[i]]));
tbl<-data.frame(Sample_feature=colnames(smp), Type=clss, Num_level=nlvl, Variable_of_interest=colnames(smp) %in% v0, Batch_effect=colnames(smp) %in% v1);
# building models
mod.nll <- model.matrix(~1, data=smp); # null model
mod.int <- model.matrix(formula(paste('~', paste(v0, collapse=' + '))), data=smp); # model of variable of interest
##################################################################################
sv<-sva(mtr, mod.int, mod.nll, n.sv=yml$parameter$nsv, B=yml$parameter$iteration);
##################################################################################
sv[[1]]<-matrix(sv[[1]], nr=nrow(smp)); # make sure it's a matrix
colnames(sv[[1]])<-paste('SV', 1:ncol(sv[[1]]), sep='');
# correlation between sample feature and surrogate variable
nl<-sapply(1:ncol(smp), function(i) length(unique(as.vector(smp[[i]]))));
s<-smp[, nl>1 & nl<nrow(smp), drop=FALSE];
p<-sapply(colnames(s), function(nm) apply(sv$sv, 2, function(x) {
y<-smp[[nm]];
if (class(y)=='factor') summary(aov(x~as.factor(smp[[nm]])))[[1]][1, 5] else cor.test(x, y)$p.value[[1]]
}));
p<-matrix(p, nc=ncol(s), nr=ncol(sv$sv));
dimnames(p)<-list(paste('SV', 1:nrow(p), sep=''), colnames(s));
fn1<-paste(path, 'sample-sv.html', sep='/');
str(sv)
sv[[1]]
sv0<-lapply(v0, function(v) rownames(p)[p[, v]<=yml$parameter$anova])
sv0<-sort(unique(unlist(sv0, use.names=FALSE)));
# unadjusted and adjusted p values from F test
p0<-f.pvalue(mtr, mod.int, mod.nll);
i<-which(rownames(p) %in% sv0);
if (length(i)==0) p1<-f.pvalue(mtr, cbind(mod.int, sv[[1]]), cbind(mod.nll, sv[[1]])) else
p1<-f.pvalue(mtr, cbind(mod.int, sv[[1]][, -i, drop=FALSE]), cbind(mod.nll, sv[[1]][, -i, drop=FALSE]))
stat<-cbind(p0, p.adjust(p0, method='BH'), p1, p.adjust(p1, method='BH'));
colnames(stat)<-c('pF', 'FDR', 'pF_SV', 'FDR_SV');
# Make scatter plot
x<--1*log10(stat[, c(1, 3)]);
x[x==Inf]<-1+max(x[x<Inf]);
par(mar=c(5,5,2,2));
plot(x, pch=19, col='#88888888', xlab='-Log10(p), Original', ylab='-Log10(p), Adjusted', cex.lab=2, xlim=range(x), ylim=range(x));
abline(0, 1, col='darkblue', lty=2);
out<-list(model=list(null=mod.nll, full=mod.int), surrogate=sv, anova=p, statistics=stat);
saveRDS(out, file=paste(path.r, 'surrogate_variable.rds', sep='/'));
# if no known sample feature is related to batch effect, pick one of the surrogate variable
if (length(v1)==0) {
sv0<-rownames(p)[apply(p[, v0, drop=FALSE], 1, function(x) min(x)>yml$parameter$anova)];
if (length(sv0)>0) {
v<-sv[[1]][, sv0, drop=FALSE];
l<-paste('There is no sample feature known to cause batch effect in the data. However, There were ', length(sv0),
' surrogate variable(s) having no signficant association with any variable of interest. ',
'So the data was adjusted by these variables using the [limma](https://www.ncbi.nlm.nih.gov/pubmed/25605792) method.',
sep='');
} else {
v<-sv[[1]];
l<-paste('There was neither sample feature known to cause batch effect in data, nor surrogate variables having no siginficant ',
'association with the variable(s) of interest. Therefore, the data was adjusted for all ', `r nrow(p)`, ' surrogate variables ',
'using the [limma](https://www.ncbi.nlm.nih.gov/pubmed/25605792) method.', sep='');
}
} else {
v<-as.vector(smp[, v1[1]]);
l<-paste('Since sample feature, _', v1, '_, was known to cause batch effect in the data, ',
'the original data matrix was then adjusted to remove its effect using the ',
'[_ComBat_](http://biostatistics.oxfordjournals.org/content/8/1/118.abstract) method if it is a categoral variable ',
'or the limma method if it is a numerical variable', sep='');
}
v1
x<-smp[[v1[1]]];
x
smp
class(x)
x
adj<-ComBat(mtr, x, mod.nll, TRUE, FALSE);
x <- as.factor(x)
adj<-ComBat(mtr, x, mod.nll, TRUE, FALSE);
p2<-f.pvalue(adj, mod.int, mod.nll);
saveRDS(adj, file=paste(path.r, 'batch_adjusted.rds', sep='/'));
stat<-cbind(stat, p_Adj=p2, FDR_Adj=p.adjust(p2, method='BH'));
out$statistics<-stat;
out$adjusted<-adj;
saveRDS(out, file=paste(path.r, 'surrogate_variable.rds', sep='/'));
x<--1*log10(stat[, c(1, 5)]);
x[x==Inf]<-1+max(x[x<Inf]);
par(mar=c(5,5,2,2));
plot(x, pch=19, col='#88888888', xlab='-Log10(p), Original', ylab='-Log10(p), Adjusted', cex.lab=2, xlim=range(x), ylim=range(x));
abline(0, 1, col='darkblue', lty=2);
# figure caption
l<-'the y-axis p values were based on the data adjusted by';
if (length(v1)>0) l<- paste(l, 'the known batch effect variable using the _ComBat_ (categoral) or _limma_ (numeric) method.') else
l<-paste(l, 'surrogate variables not siginicantly associated to variable(s) of interest using the _limma_ method.')
length(p2)
hist(p2, br=100)
min(p2)
adj[p2==min(p2), ]
barplot(adj[p2==min(p2), ])
barplot(adj[p2==min(p2), ], col=rep(1:8, each=4))
barplot(adj[p2==min(p2), ], col=rep(1:8, each=4), las=3)
a <- adj[p<=0.001, ]
dim(a)
a <- adj[p<=0.0001, ]
dim(a)
a <- adj[p<=0.00001, ]
dim(a)
a <- adj[p2<=0.00001, ]
dim(a)
a <- adj[p2<=0.0001, ]
dim(a)
a <- adj[p2<=0.001, ]
dim(a)
a <- t(scale(t(a)))
heatmap(a, Colv=NA, scale='none')
heatmap(-a, Colv=NA, scale='none')
dim(e)
dim(mtr)
d <- mtr[1, ]
f
x
f <- as.factor(rep(1:8, each=4))
f
f
d
x
d
d <- as.vector(d)
d
f
f0 <- rep(1:4, 8)
f0 <- as.factor(f0)
f0
aov(d~f+error(f0))
aov(d~f+Error(f0))
summary(aov(d~f+Error(f0)))
summary(p2)
aov <- apply(mtr, 1, function(x) summary(aov(x~f+Error(f0))))
a <- aov[[1]]
a
a[[1]]
a[[2]]
p1 <- lapply(aov, function(x) x[[2]])
p1[[1]]
p1 <- sapply(p1, function(x) x[1, 5])
p1 <- sapply(p1, function(x) x[[1]][1, 5])
min(p1)
plot(-log10(p1), -log10(p2))
abline(0, 1, col=2)
??combat
??ComBat
require(sva)
?ComBat
x <- rep(c(1, 2, 2), 6)
x
x[16:18] <- c(2,1,2)
cbind(rownames(smp), x)
