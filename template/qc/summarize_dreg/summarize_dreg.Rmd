---
title: "Summary of dREG peak calling"
author: "`r if (exists('yml')) yml$analyst else 'Jim Zhang'`"
date: "`r Sys.Date()`"
output:
  html_document:
    number_sections: yes
    self_contained: no
    toc: yes
    toc_float:
      collapsed: no
---

<div style="border:black 1px solid; padding: 0.5cm 0.5cm">

**Introduction** This report is a summary of outputs from the **[dREG](https://github.com/Danko-Lab/dREG)** program that predicts transcription regulatory regions by identifying peaks from PRO-seq, GRO-seq, or similar types of sequencing data. dREG is an R package and its _peak_calling_ function outputs a _list_ containing 6 items. Two of these items are required for analysis:

  - _peak_bed_: a table including locations and scores of dREG "narrow" peaks
  - _peak_broad_: a table including locations and minimum/maximum/mean scores of broad dREG peaks; each broad peak combines nearby narrow peaks.
  
Through this report, location, length, and score of both types of peaks will be summarized across multiple samples, and top peaks will be selected for follow-up analysis based on score distribution.

</div>

&nbsp;

```{r global_setup, include=FALSE}
name.yaml <- 'summarize_dreg.yaml'; 
name.packages <- c('rmarkdown', 'knitr', 'kableExtra', 'yaml', 'DT', 'htmlwidgets', 'pander',
                   'mixtools', 'vioplot', 'GenomicRanges'); 
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table'); # <full.path.to.subfolder>=<subfolder.name>

## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));

## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
  if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
    yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template

prms <- yml$parameter;

## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]); 

## Automatical figure/table ordering
OrderFigure(reset=TRUE);
OrderTable(reset=TRUE);

## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
```

`r home.url`

# Description

`r WriteDescription(yml$description)`

`r home.url`

```{r load_peak, include=FALSE}
fns <- ImportTable(DownloadFile(yml$input$peak, path.input));
chr <- ImportVector(DownloadFile(yml$input$chromosome, path.input));
pks <- lapply(1:nrow(fns), function(i) {
  p1 <- ImportTable(DownloadFile(fns[i, 1], path.input));
  p1 <- GRanges(p1$chr, IRanges(p1$start, p1$end), score=p1$score, prob=p1$prob, center=p1$center,
                seqlengths = chr);
  names(p1) <- 1:length(p1);
  
  p2 <- ImportTable(DownloadFile(fns[i, 2], path.input));
  p2 <- GRanges(p2$chr, IRanges(p2$start, p2$end), min=p2$min, max=p2$max, mean=p2$mean, sum=p2$sum,
                stdev=p2$stdev, count=p2$count, seqlengths = chr); 
  names(p2) <- 1:length(p2);
  
  list(narrow=p1, broad=p2);
});
names(pks) <- rownames(fns);
```

# Results

## Peak summary

Summary of peak length and dREG scores.

```{r summary, include=FALSE}
num <- sapply(pks, function(x) sapply(x, length));
len <- sapply(pks, function(x) sapply(x, function(x) mean(width(x))));
mn1 <- sapply(pks, function(x) mean(x[[1]]$score));
mn2 <- sapply(pks, function(x) mean(x[[2]]$max));
den <- sapply(pks, function(x) sapply(x, function(x) length(x)/(sum(chr[seqlevels(x)])/10^6)));

smm <- cbind(t(num), round(t(den), 1), round(t(len), 1), round(mn1, 3), round(mn2, 3));
colnames(smm) <- c('Num_Narrow', 'Num_Broad', 'Num_Narrow (Mb)', 'Num_Broad (Mb)', 
                   'Wid_Narrow', 'Wid_Broad', 'Mean_Narrow', 'Mean_Broad');
tbl <- data.frame('Sample'=rownames(smm), smm, stringsAsFactors = FALSE);

saveRDS(smm, paste0(path.r, '/peak_summary.rds'));

fns <- sapply(names(pks), function(nm) {
  p1 <- pks[[nm]]$narrow;
  p2 <- pks[[nm]]$broad;
  
  f <- paste0('width_vs_score_', nm, '.png');
  png(paste(path.fig, f, sep='/'), w=3000, h=1500, units = 'px', res=300);
  par(mar=c(5,5,3,3), mfrow=c(1,2));
  plot(width(p1), p1$score, xlab='Peak width', ylab='dREG score', main='Narrow peak',
       cex.lab=1.5, cex.main=2, pch=19, cex=0.5, col='#88888888', 
       xlim=c(0, max(width(p1))), ylim=c(0, max(p1$score)));
  plot(width(p2), p2$max, xlab='Peak width', ylab='Maximum dREG score', main='Broad peak',
       cex.lab=1.5, cex.main=2, pch=19, cex=0.5, col='#88888888');
  dev.off();
  f; 
});
tbl$Sample <- paste0('[', tbl[, 1], '](figure/', fns, ')');
```

<div style="color:darkblue">
`r OrderTable()` Summary of narrow and broad peaks identified from each sample by dREG. Click sample ID to view plot of peak width and dREG score.

  - _Num_Narrow_ and _Num_Broad_: total number of peaks
  - _Num_Narrow (Mb)_ and _Num_Broad (Mb)_: number of peaks per million bases
  - _Wid_Narrow_ and _Wid_Broad_: average width of peaks
  - _Mean_Narrow_: average of dREG scores of narrow peaks
  _ _Mean_Broad_:: average of maximum dREG scores of broad peaks
 
  
</div>

`r kable(tbl, row.names=FALSE) %>% kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE)`

```{r width, include=TRUE, fig.width=9.6, fig.height=4, out.width='960px'}
wd1 <- lapply(pks, function(p) width(p[[1]]));
wd2 <- lapply(pks, function(p) width(p[[2]]));

rg1 <- c(min(sapply(wd1, min)), max(sapply(wd1, max)));
rg2 <- c(min(sapply(wd2, min)), max(sapply(wd2, max)));

par(mfrow=c(1, 2), mar=c(6, 4, 2, 1));

plot(0, type='n', xlim=c(0, 1+length(pks)), ylim=c(0, rg1[2]), xlab='', ylab='Peak width', xaxt='n',
     main='Narrow peak', cex.main=1.5, xaxs='i');
for (i in 1:length(pks)) 
  vioplot(wd1[[i]], at=i, add=TRUE, rectCol='darkgrey', border='gold', colMed='lightblue', col='#239B56');
axis(1, at=1:length(pks), label=names(pks), las=3);

plot(0, type='n', xlim=c(0, 1+length(pks)), ylim=c(0, rg2[2]), xlab='', ylab='Peak width', xaxt='n',
     main='Broad peak', cex.main=1.5);
for (i in 1:length(pks)) 
  vioplot(wd2[[i]], at=i, add=TRUE, rectCol='darkgrey', border='gold', colMed='lightblue', col='#239B56');
axis(1, at=1:length(pks), label=names(pks), las=3);
```

<div style="color:darkblue">
`r OrderFigure()` Distribution of peak width by samples.
</div>

```{r score, include=TRUE, fig.width=9.6, fig.height=4, out.width='960px'}
sc1 <- lapply(pks, function(p) p[[1]]$score);
sc2 <- lapply(pks, function(p) p[[2]]$max);

rg1 <- c(min(sapply(sc1, min)), max(sapply(sc1, max)));
rg2 <- c(min(sapply(sc2, min)), max(sapply(sc2, max)));

par(mfrow=c(1, 2), mar=c(6, 4, 2, 1));

plot(0, type='n', xlim=c(0, 1+length(pks)), ylim=c(0, rg1[2]), xlab='', ylab='Peak score', xaxt='n',
     main='Narrow peak', cex.main=1.5, xaxs='i');
for (i in 1:length(pks)) 
  vioplot(sc1[[i]], at=i, add=TRUE, rectCol='darkgrey', border='gold', colMed='lightblue', col='#3498DB');
axis(1, at=1:length(pks), label=names(pks), las=3);

plot(0, type='n', xlim=c(0, 1+length(pks)), ylim=c(0, rg2[2]), xlab='', ylab='Peak score', xaxt='n',
     main='Broad peak', cex.main=1.5);
for (i in 1:length(pks)) 
  vioplot(sc2[[i]], at=i, add=TRUE, rectCol='darkgrey', border='gold', colMed='lightblue', col='#3498DB');
axis(1, at=1:length(pks), label=names(pks), las=3);
```

<div style="color:darkblue">
`r OrderFigure()` Distribution of peak score by samples. Maximum dREG scores were used for broad peaks.
</div>

`r home.url`

## Peak selection

Broad peaks were selected using a modeling procedure to exclude peaks with low dREG scores, so are likely false positives. The procedure assumes there are 3 classes of dREG peaks, each with approximately normally distributed dREG scores. 

  - **Class I** peaks have the lowest dREG scores, most likely are false positives, and can be considered as background
  - **Class II** peaks have intermediate dREG scores significantly higher than the background, and probably correspond to regulatory regions in poised status.
  - **Class III** peaks have the highest dREG scores, and are likely the sites in stable status.
  
The means and standard deviations of the dREG scores of these classes were estimated via EM algorithm, and were used to classify peaks: class I peaks are separated from class II and III peaks by 3 standard deviations from its mean, and class II and class III are separated from each other by the value between the 2 normal distributions.

```{r peak_modeling, include=FALSE}
scoreModel <- function(s) {
  den <- density(s, bw=0.1); # Create a low resolution density distribution based on dREG scores
  smp <- sample(den$x, 25000, TRUE, den$y); # create data values following the density distribution
  mdl <- normalmixEM(smp, k=3); # fit a trimodel distribution
  out <- cbind(Mean=mdl$mu, SD=mdl$sigma, Lambda=mdl$lambda);
  out <- out[order(out[, 1]), ];
  fq2 <- dnorm(seq(out[2, 1], out[3, 1], length.out=1000), out[2, 1], out[2, 2]);
  fq3 <- dnorm(seq(out[2, 1], out[3, 1], length.out=1000), out[3, 1], out[3, 2]);
  ind <- c(max(which(fq2>fq3)), min(which(fq2<fq3)));
  cf2 <- mean(seq(out[2, 1], out[3, 1], length.out=1000)[ind[1]:ind[2]]);
  cf1 <- out[1, 1]+3*out[1, 2];

  list(input=s, sample=smp, stat=out, cutoff=c(cf1, cf2));
}

mdl <- lapply(pks, function(p) scoreModel(p[[2]]$max));
```

```{r classification, include=FALSE}
plotDist <- function(s, mns, sds, lam, cut, title='') {
  par(mar=c(5,5,2,2));
  col <- c('#F39C12', '#EC7063', '#B03A2E');
  
  den <- density(s);
  xs  <- den$x;
  ys  <- den$y;
  
  plot(den, xlim=range(den$x), ylim=c(0, 1.1*max(den$y)), ylab='Frequency', xlab='dREG score', main=title,
       col='darkgrey', xaxs='i', yaxs='i', cex.lab=2, cex.main=1.5);
  
  xs1 <- xs[xs<=cut[1]];
  ys1 <- ys[xs<=cut[1]];
  polygon(c(min(xs1), xs1, max(xs1)), c(0, ys1, 0), col=col[1], border=NA);

  xs3 <- xs[xs>=cut[2]];
  ys3 <- ys[xs>=cut[2]];
  polygon(c(min(xs3), xs3, max(xs3)), c(0, ys3, 0), col=col[3], border=NA);

  xs2 <- c(xs1[length(xs1)], xs[xs>cut[1] & xs<cut[2]], xs3[1]);
  ys2 <- c(ys1[length(ys1)], ys[xs>cut[1] & xs<cut[2]], ys3[1]);
  polygon(c(max(xs1), xs2, min(xs3)), c(0, ys2, 0), col=col[2], border=NA);
  
  for (i in 1:length(mns)) {
    x <- seq(mns[i]-6*sds[i], mns[i]+6*sds[i], length.out = 2000);
    lines(x, dnorm(x, mns[i], sds[i])*lam[i], lty=1, col='#DDDDDDDD');
  }
}

fns <- sapply(names(mdl), function(nm) {
  m <- mdl[[nm]];
  f <- paste0('classification_', nm, '.png');
  
  png(paste(path.fig, f, sep='/'), w=1800, h=1200, units = 'px', res=300);
  plotDist(m$sample, m$stat[, 1], m$stat[, 2], m$stat[, 3], m$cutoff, nm);
  dev.off();
  f; 
});

smm <- t(sapply(mdl, function(m) c(as.vector(m$stat[, 1:2]), m$cutoff)));
smm <- cbind(round(smm, 3), t(sapply(mdl, function(m) {
  v <- m$input;
  c <- m$cutoff;
  c(length(v[v<=c[1]]), length(v[v>c[1] & v<c[2]]), length(v[v>=c[2]])) 
})));
colnames(smm) <- c('Mean_I', 'Mean_II', 'Mean_III', 'SD_I', 'SD_II', 'SD_III', 'I-II', 'II-III',
                   'Num_I', 'Num_II', 'Num_III');
saveRDS(smm, paste(path.r, 'classification_summary.rds', sep='/'));
tbl <- data.frame('Sample'=rownames(smm), smm, stringsAsFactors = FALSE);
colnames(tbl) <- c('Sample', 'Mean_I', 'Mean_II', 'Mean_III', 'SD_I', 'SD_II', 'SD_III', 'I-II', 'II-III',
                   'Num_I', 'Num_II', 'Num_III');
tbl[, 1] <- paste0('[', tbl[, 1], '](figure/', fns, ')');
```


<div style="color:darkblue">
`r OrderTable()` Summary of broad peak classification, including dREG score means and standard deviations of all 3 classes; the cutoff values that separate 3 classes; and the number of peaks in each class. 
</div>

`r kable(tbl, row.names=FALSE) %>% kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE)`

```{r score_dist, include=TRUE, fig.width=6.4, fig.height=4, out.width='640px'}
d <- smm[, c(1, 7, 2, 8, 3)];
colnames(d) <- c('Class I', 'I - II', 'Class II', 'II - III', 'Class III');
barplot(d, be=TRUE, col=topo.colors(nrow(d)), ylab='dREG score');
legend('topleft', bty='n', pch=16, col=topo.colors(nrow(d)), legend=rownames(d), cex=0.6);
```

<div style="color:darkblue">
`r OrderFigure()` Overview of classification values: class means and cutoff values between classes.
</div>

```{r classes, include=FALSE}
brd <- lapply(names(pks), function(nm) {
  x <- pks[[nm]]$broad;
  y <- x$max;
  z <- mdl[[nm]]$cutoff;
  c <- rep('I', length(y));
  c[y>z[1]] <- "II";
  c[y>=z[2]] <- 'III';
  x$class <- c;
  x; 
}); 
names(brd) <- names(pks);
saveRDS(brd, paste(path.r, 'peak_classified.rds', sep='/'));
```

## Peak overlapping

The overlapping of peaks in multiple samples indicates the similarity of samples and commonness of peaks. 

```{r peak_olverlapping, include=TRUE, fig.width=6, fig.height=6, out.width='600px'}
c23 <- lapply(brd, function(b) b[b$class=='II' | b$class=='III']);
num <- min(sapply(c23, length));
c23 <- lapply(c23, function(x) x[rev(order(x$max))][1:num]);

olp <- sapply(1:length(c23), function(i) sapply(1:length(c23), function(j) {
  c <- countOverlaps(c23[[i]], c23[[j]], ignore.strand=TRUE);
  length(c[c>0]);
}));
olp <- t(olp);
rownames(olp) <- colnames(olp) <- names(pks);

pct <- 100*olp/num;
PlotColoredBlock(pct, round(min(pct)), 100, key = 'Overlapping%');
```

<div style="color:darkblue">
`r OrderFigure()` The percentage of top class II/III peaks of one sample (Row) that are overlapped to top peaks of each of the other samples (Column). Top peaks are `r num` broad peaks with the highest dREG scores. The number is the fewest class II/III peaks identified from any samples. Therefore, the bias caused by the difference in peak numbers was removed.
</div>

```{r count_overlapping, include=FALSE}
c2 <- lapply(brd, function(c) c[c$class=='II']);
c3 <- lapply(brd, function(c) c[c$class=='III']);
c23 <- lapply(brd, function(c) c[c$class=='II' | c$class=='III']);

loc <- sapply(list(c2, c3, c23), function(c) {
  ttl <- Reduce('c', c);
  cov <- coverage(ttl);
  cov[cov>1] <- 1;
  loc <- lapply(names(cov), function(chr) GRanges(chr, IRanges(start(cov[[chr]]), end(cov[[chr]])))[runValue(cov[[chr]])>0]);
  suppressWarnings({loc <- Reduce('c', loc)});
  cnt <- sapply(c, function(c) pmin(1, countOverlaps(loc, c)));
  elementMetadata(loc) <- cbind(Total=rowSums(cnt), cnt);
  loc;
}); 

cnt <- sapply(loc, function(l) sapply(1:length(pks), function(i) length(l[l$Total==i])));
cnt <- t(cnt);
rownames(cnt) <- c('II only', 'III only', 'II and III');
colnames(cnt) <- paste('N =', 1:ncol(cnt));

saveRDS(loc, paste(path.r, 'overlapping_loci.rds', sep='/'));

out <- lapply(loc, function(l) {
  x <- data.frame(Chr=as.vector(seqnames(l)), Start=start(l), End=end(l), Width=width(l), stringsAsFactors = FALSE);
  cbind(x, as.matrix(elementMetadata(l)));
});
CreateDatatable(out[[1]], paste(path.tbl, 'loci_count_2.html', sep='/'))->x;
CreateDatatable(out[[2]], paste(path.tbl, 'loci_count_3.html', sep='/'))->x;
CreateDatatable(out[[3]], paste(path.tbl, 'loci_count_both.html', sep='/'))->x;

tbl <- data.frame(Type=rownames(cnt), cnt, stringsAsFactors = FALSE);
colnames(tbl) <- c('Type', colnames(cnt));
tbl[[1]] <- paste0('[', tbl[[1]], '](table/', c('loci_count_2.html', 'loci_count_3.html', 'loci_count_both.html'), ')');
```


<div style="color:darkblue">
`r OrderTable()` Number of genomic locations covered by broad peaks of 1 to all samples. The first row counts class II peaks only, the second row class III only, and the third row counts both classes. Click links to see full list of loci.
</div>

`r kable(tbl, row.names=FALSE) %>% kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE)`

# Download

```{r write_out, include=FALSE}
fn1 <- sapply(names(brd), function(nm) {
  tbl <- brd[[nm]];
  tbl <- data.frame(chr=as.vector(seqnames(tbl)), start=start(tbl), end=end(tbl), width=width(tbl),
                    as.matrix(elementMetadata(tbl)), stringsAsFactors = FALSE);
  f <- paste0(path.tbl, '/classified_', nm, '.csv');
  write.csv(tbl, f);
  f;
});
zip(paste0(path.tbl, '/classified_peak.zip'), fn1, zip='zip');

names(loc) <- c('IIonly', 'IIIonly', 'both');
fn2 <- sapply(names(loc), function(nm) {
  tbl <- loc[[nm]];
  met <- as.matrix(elementMetadata(tbl));
  tbl <- data.frame(Chr=as.vector(seqnames(tbl)), Start=start(tbl), End=end(tbl), Width=width(tbl),
                    stringsAsFactors = FALSE);
  tbl <- cbind(tbl, met);
                    
  f <- paste0(path.tbl, '/overlap_', nm, '.csv');
  write.csv(tbl, f);
  f;
});
zip(paste0(path.tbl, '/overlapping_loci.zip'), fn2, zip='zip');
```

**Peak classification**: 

  - [R](R/peak_classified.rds)
  - [Text](table/classified_peak.zip)
  
**Peak overlapping**:

  - [R](R/overlapping_loci.rds)
  - [Text](overlapping_loci.zip)

***

# Appendix 

Check out the **[RoCA home page](http://zhezhangsh.github.io/RoCA)** for more information.  

## Reproduce this report

To reproduce this report: 

  1. Find the data analysis template you want to use and an example of its pairing YAML file  [here](https://github.com/zhezhangsh/RoCA/wiki/Templates-and-examples) and download the YAML example to your working directory

  2. To generate a new report using your own input data and parameter, edit the following items in the YAML file:

    - _output_        : where you want to put the output files
    - _home_          : the URL if you have a home page for your project
    - _analyst_       : your name
    - _description_   : background information about your project, analysis, etc.
    - _input_         : where are your input data, read instruction for preparing them
    - _parameter_     : parameters for this analysis; read instruction about how to prepare input data

  3. Run the code below within ***R Console*** or ***RStudio***, preferablly with a new R session:

```{r reproduce_report, eval=FALSE, echo=TRUE}
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

CreateReport(filename.yaml);  # filename.yaml is the YAML file you just downloaded and edited for your analysis
```

If there is no complaint, go to the _output_ folder and open the ***index.html*** file to view report. 

## Session information

```{r session_info, echo=FALSE}
sessionInfo(); 
```

`r home.url`

***
_END OF DOCUMENT_

