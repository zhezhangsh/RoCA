---
title: "Analysis of techinal replicates"
author: "`r if (exists('yml')) yml$analyst else 'Jim Zhang'`"
date: "`r Sys.Date()`"
output:
  html_document:
    number_sections: yes
    self_contained: no
    toc: yes
    toc_float:
      collapsed: no
---

<div style="border:black 1px solid; padding: 0.5cm 0.5cm">

**Introduction** This procedure uses high-dimentional data (transcriptome, proteome, ...) to evaluate how similar techinal replicates are to each other comparing to biological replicates. Technical replicates can be defined by the experiment design at different stages, from multiple cell culture colonies from the same donor to the same RNA-seq library sequenced by multiple flowcells. The inputs of this procedure include a data matrix and a matching table of sample manifest. 

</div>

&nbsp;

```{r global_setup, eval=TRUE, include=FALSE}
name.yaml <- 'technical_replicate.yaml'; 
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'RoCA', 'awsomics', 
                   'gplots', 'data.tree', 'networkD3'); 
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table'); # <full.path.to.subfolder>=<subfolder.name>

## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));

## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
  if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
    yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template

prms <- yml$parameter;

## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]); 

## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
```

`r home.url` 

# Description

`r WriteDescription(yml$description)`

```{r load_data, include=FALSE}
mtrx <- ImportTable(DownloadFile(yml$input$matrix, path.input)); 
smpl <- ImportTable(DownloadFile(yml$input$sample, path.input));

if (class(mtrx) != 'matrix') mtrx <- as.matrix(mtrx); 
for (i in 1:ncol(smpl)) smpl[[i]] <- as.vector(smpl[[i]]); 

smpl <- smpl[rownames(smpl) %in% colnames(mtrx), , drop=FALSE];
mtrx <- mtrx[, rownames(smpl), drop=FALSE];
grps <- split(smpl, as.vector(smpl[[2]]))[unique(as.vector(smpl[[2]]))];
grps <- lapply(grps, function(g) split(g, g[[1]])[unique(as.vector(g[[1]]))]);
smpl <- lapply(grps, function(g) do.call('rbind', g)); 
smpl <- do.call('rbind', smpl); 
rownames(smpl) <- unlist(lapply(grps, function(g) lapply(g, rownames))); 
```

`r home.url`

# Summary statistics

- Total number of variables: _`r nrow(mtrx)`_
- Total number of technical replicates: _`r nrow(smpl)`_
- Total number of biological replicates: _`r length(unique(smpl[[1]]))`_
- Total number of sample groups: _`r length(grps)`_
- Technical replicates were run in batches? _`r ncol(smpl)>2`_

Click [here](table/sample.html) to view full sample manifest.

<div align='center'>
```{r sample_structure, include=TRUE, out.width='600px'}
smpl$pathString <- paste('AllSamples', smpl$Group, smpl$Sample, rownames(smpl), sep='|');
smpl.tree <- as.Node(smpl, pathDelimiter = "|");
smpl.list <- ToListExplicit(smpl.tree, unname = TRUE);
radialNetwork(smpl.list, height = 600, width = 600, nodeColour = '#f88', textColour = '#44f');
```
</div>

<div style="color:darkblue; padding:0 2cm">
**Figure 1.** Hierarchical structure of sample groups, biological replicates, and technical replications. 
</div>

`r home.url` 

# Analysis

## Principal components analysis

Principal Components Analysis (PCA) is an unsupervised analysis that converts a large number of correlated variables into a smaller set of uncorrelated variables called principal components (PCs). Each principal component accounts for certain percentage of total variability of a data set so the PCs can be ordered by their percentages. In general, samples closer to each other within the PCA space are more similar to each other. 

<div align='center'>
```{r plot_pca, include=TRUE, out.width='800px'}
pca <- prcomp(t(mtrx)); 

X <- pca$x[,1];
Y <- pca$x[,2];
per <- round(summary(pca)$importance[2, 1:2]*100, 2);
pca$importance <- summary(pca)$importance;

cl1 <- GetBluePinkOGramColors(length(unique(smpl[[1]])));
names(cl1) <- unique(smpl[[1]]); 
cl1 <- cl1[smpl[[1]]]; 

cl2 <- GetColors(length(unique(smpl[[2]])), 'grey-black');
names(cl2) <- unique(smpl[[2]]);
cl2 <- cl2[smpl[[2]]];

layout(matrix(1:2, nrow=1), width=c(3,1));
par(mai=c(1,1,.25,.25));

cx<-max(0.5, min(3, 96/length(X)))
plot(X, Y, col=cl2, pch=17, cex=cx, xlim=c(min(X)*1.1, max(X)*1.1), ylim=c(min(Y)*1.1, max(Y)*1.1), 
     xlab=paste('PC1', ', ', per[1], '%', sep=''), ylab=paste('PC2', ', ', per[2], '%', sep=''), cex.lab=1.5);
points(X, Y, cex=1.05*cx, col=cl1, lwd=1, pch=2);
text(X, Y, label=1:length(X), col='white', cex=sample(seq(0.2, 0.3, 0.01), length(X), replace = TRUE)*cx);

par(mai=c(1, 0, 0.25, 0));
plot(0, type='n', xlim=c(0, 100), ylim=c(1, 100), axes=FALSE, bty='n', xaxs='i', yaxs='i', xlab='', ylab='');

w<-strwidth(1:length(X), cex=1.2);
w0<-1.2*80/max(w, 80);
h0<-1.2*(100/length(X))/4.0;
cex<-min(1.2, w0, h0); 

points(rep(5, length(X)), 100-(1:length(X))*4.0*cex, col=cl1, pch=19, cex=1.5*cex);
text(5+cex*5, 100-(1:length(X))*4.0*cex, labels=colnames(mtrx), adj=0, col=cl1, pch=19, cex=cex);
text(rep(5, length(labels)), 100-(1:length(X))*4.0*cex, labels=1:length(X), col='white', cex=0.8*cex);
```
</div>

<div style="color:darkblue; padding:0 1cm">
**Figure 2.** This figure plots the top two PCs that account for `r sum(per[1:2])`% of the total variance of the data matrix. Techincal replicates of the same biological sample have the same border color and biological replicates of the same sample group have the same filled color.
</div>

`r home.url` 

## Hierarchical clustering

Another way to measure sample similarity is calculate the pairwise correlation between any 2 samples. Unsupervised clustering of all samples can be performed using the pairwise correlation coefficients. More similar samples have the higher correlation coefficient and share the lower node on the clustering tree. 

<div align='center'>
```{r plot_heatmap, include=TRUE, out.width='800px'}
corr <- cor(mtrx); 
heatmap(-corr, ColSideColors = cl1, RowSideColors = cl1); 
```
</div>

<div style="color:darkblue; padding:0 2cm">
**Figure 3.** This figure color-coded the correlation between all pairs of samples. Redder blocks represent higher correlation coefficients. Samples are clustered and ordered in rows and columns. Technical replicates of the same biological samples have the same row/column sidebar color. Click [here](table/correlation.html) to view correlation coefficients between all pairs of samples.
</div>

`r home.url` 

## Technical vs. biological replicates

We usually expect that technical replicates of the same biological sample have more similarity to each other than biological replicates to each other. Pairwise correlation coefficients between different types of replications are compared in this analysis.

```{r correlation_analysis, include=TRUE, fig.width=8, fig.height=6, out.width='800px'}
crr <- lapply(rownames(smpl), function(id) {
  s1 <- smpl[smpl[[1]]==smpl[id, 1] & rownames(smpl)!=id, , drop = FALSE]; 
  if (nrow(s1) == 0) r1 <- c() else r1 <- as.vector(cor(mtrx[, id, drop=FALSE], mtrx[, rownames(s1), drop=FALSE])); 
  names(r1) <- rownames(s1); 
  
  s2 <- smpl[smpl[, 1]!=smpl[id, 1] & smpl[, 2]==smpl[id, 2], ];
  if (ncol(smpl) > 3) s2 <- s2[s2[, 3]==smpl[id, 3], , drop=FALSE];
  if (nrow(s2) == 0) r2 <- c() else r2 <- as.vector(cor(mtrx[, id], mtrx[, rownames(s2)])); 
  names(r2) <- rownames(s2); 
  
  list(technical=r1, biological=r2); 
}); 
names(crr) <- rownames(smpl); 

mx <- max(unlist(crr)); 
mn <- min(unlist(crr));
rg <- c(floor(100*mn)/100, ceiling(100*mx)/100);

m1 <- sapply(crr, function(x) mean(x[[1]]));
m2 <- sapply(crr, function(x) mean(x[[2]]));

nm <- names(crr); 

ht <- 5/length(nm)/max(strheight(nm, units = 'in'))
wd <- 1/max(strwidth(nm, units = 'in'));
cx <- min(1.5, 200/length(crr)); 

s <- split(rownames(smpl), smpl[[1]])[unique(smpl[[1]])]; 
n <- sapply(s, length); 

par(mai=c(1.5, 1, 0.25, 0.25)); 
plot(0, type='n', xlim=c(0, 1+length(crr)), ylim=rg, xaxt='n', xlab='', ylab='Correlation coefficient', cex.lab=2,
     xaxs='i', yaxs='i');
mtext(nm, side=1, las=3, outer=FALSE, line=0.1, at=1:length(crr), col=cl1, cex=max(c(ht, wd)));
abline(v=1:length(crr), lwd=1, lty=2, col='#66666666');
abline(v=cumsum(n[-length(n)])+0.5, col='black', lty=1, lwd=1.5); 

for (i in 1:length(crr)) {
  x <- crr[[i]][[1]]; 
  y <- crr[[i]][[2]]; 
  
  segments(i, min(y), i, max(y), lwd=2, col='darkgrey');
  segments(i, min(x), i, max(x), lwd=2, col='darkgrey'); 
  
  points(rep(i, length(y)), y, pch=20, col='gold', cex=1); 
  points(rep(i, length(x)), x, pch=18, col='purple', cex=1); 
}
```

<div style="color:darkblue; padding:0 1cm">
**Figure 4.** For each technical replicate, this figure compares its correlation to the other technical replicates of the sample and the other biological replicates in the same sample group (batch effect removed) on a vertical line. The purple diamonds are correlation coefficients between pairwises of technical replications and the yellow circles are correlation coefficients between pairwises of biological replications. Usually, it is expected that the later have lower values. 
</div>

`r home.url` 

## Scatter plots

<div align='center'>
```{r scatter_plot, include=TRUE, fig.width=8, fig.height=8, out.width='800px'}
srt <- lapply(crr, function(x) rev(sort(x[[1]]))[1]); 
val <- as.vector(unlist(srt)); 
ind <- which(val==max(val))[1]; 
mx1 <- c(names(srt)[ind], names(srt[[ind]])); 

srt <- lapply(crr, function(x) sort(x[[1]])[1]); 
val <- as.vector(unlist(srt)); 
ind <- which(val==min(val))[1]; 
mn1 <- c(names(srt)[ind], names(srt[[ind]])); 

srt <- lapply(crr, function(x) rev(sort(x[[2]]))[1]); 
val <- as.vector(unlist(srt)); 
ind <- which(val==max(val))[1]; 
mx2 <- c(names(srt)[ind], names(srt[[ind]])); 

srt <- lapply(crr, function(x) sort(x[[2]])[1]); 
val <- as.vector(unlist(srt)); 
ind <- which(val==min(val))[1]; 
mn2 <- c(names(srt)[ind], names(srt[[ind]])); 

ids <- list('Technical, highest'=mx1, 'Technical, lowest'=mn1, 'Biological, highest'=mx2, 'Biological, lowest'=mn2); 

par(mfrow=c(2, 2), mar=c(4, 4, 2, 2));
for (i in 1:4) {
  x <- mtrx[, ids[[i]]]; 
  plot(x[, 1], x[, 2], xlim=range(x), ylim=range(x), pch=19, col='#88888888', cex=0.75, 
       xlab=colnames(x)[1], ylab=colnames(x)[2], main=names(ids)[i], cex.main=1.5); 
  abline(0, 1, col='blue'); 
}
```
</div>

<div style="color:darkblue; padding:0 1cm">
**Figure 5.** Pairs of technical or biological replicates having the highest or lowest correlation. 
</div>

```{r save, include=FALSE}
CreateDatatable(smpl, paste(path.tbl, 'sample.html', sep='/'))
CreateDatatable(corr, paste(path.tbl, 'correlation.html', sep='/'))

saveRDS(corr, paste(path.r, 'correlation_all.rds', sep='/')); 
saveRDS(crr, paste(path.r, 'correlation_pair.rds', sep='/')); 
```

`r home.url` 

# Session information

```{r session_info, echo=FALSE}
sessionInfo(); 
```

`r home.url`

***
_END OF DOCUMENT_
