---
title: 'Network analysis using the igraph package'
author: "Jim Zhang"
date: '`r Sys.Date()`'
output:
  html_document:
    number_sections: yes
    self_contained: yes
    toc: yes
  pdf_document:
    toc: no
---

<div style="border:black 1px solid; padding: 0.5cm 0.5cm">
**Introduction** "[**igraph**](http://igraph.org) is a collection of network analysis tools with the emphasis on efficiency, portability and ease of use. igraph is open source and free. igraph can be programmed in R, Python and C/C++."

This procedure will identify sub-networks from a given network, using three clustering algorithms implemented by **igraph**: **[fast greedy](http://www.arxiv.org/abs/cond-mat/0408187)**, **[walktrap](http://arxiv.org/abs/physics/0512106)**, and **[edge betweenness](https://arxiv.org/abs/cond-mat/0308217)**. The sub-networks will be further analyzed by enrichment analysis for their functional annotation. 
</div>

&nbsp;

```{r global_setup, eval=TRUE, include=FALSE}
name.yaml <- 'igraph.yaml'; 
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'RCurl', 'GenomicRanges', 'RoCA', 
                   'awsomics', 'igraph', 'DEGandMore'); 
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table');

## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));

if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
	if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
		yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template

prms <- yml$parameter;

f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]); 

home.url <- Link2Home(yml$home);
```

`r home.url` 

&nbsp;

```{r load_data, eval=TRUE, include=FALSE}
############################################################################################################
#####################################  Loading packages and data   #########################################
############################################################################################################
prs <- ImportTable(DownloadFile(yml$input$pairs, path = path.input));
igrph <- graph_from_data_frame(prs[, 1:2], FALSE);

if (file.exists(yml$input$background) | url.exists(yml$input$background)) 
  bgd <- ImportVector(DownloadFile(yml$input$background, path = path.input)) else 
    bgd <- NULL;
set.mpp <- ImportList(DownloadFile(yml$input$mapping, path = path.input));
set.ann <- ImportTable(DownloadFile(yml$input$annotation, path = path.input));

set.num <- sapply(set.mpp, length);
set.mpp <- set.mpp[set.num>=prms$enrichment$size.min&set.num<=prms$enrichment$size.max];

set.ann <- set.ann[rownames(set.ann) %in% names(set.mpp), , drop=FALSE]; 
set.mpp <- set.mpp[rownames(set.ann)]; 

cnm <- colnames(prs); 
if ('weight' %in% tolower(cnm)) wgt <- prs[, which(tolower(cnm)=='weight')[1]] else wgt <- rep(1, nrow(prs));

ngb <- table(c(as.vector(prs[, 1]), as.vector(prs[, 2]))); 
msz <- yml$parameter$cluster$size;
noi <- yml$parameter$cluster$core;

# Summarize graph
nds <- c(as.vector(prs[,1]), as.vector(prs[, 2])); 
num <- table(nds);
num.edge <- length(E(igrph));
num.node <- length(V(igrph)); 

set.all  <- unlist(set.mpp, use.names=FALSE);
bgd <- unique(bgd[bgd %in% set.all]); 
if (length(bgd) == 0) bgd <- unique(set.all);

inc.node <- intersect(names(V(igrph)), set.all);
############################################################################################################
```

```{r functions, include=FALSE}
label.hub <- function(label, cluster, count) {
  top <- lapply(cluster, function(c) rev(sort(count[c]))[1]);
  top <- as.vector(unlist(lapply(top, function(x) names(x)[x==x[1]]))); 
  label[top] <- top; 
  label; 
};
plot.full.graph <- function(graph, cluster, label, title) {
  V(graph)$label <- as.vector(label[V(graph)$name]);
  plot(graph, mark.groups = by(seq_along(cluster$membership), cluster$membership, invisible), 
     vertex.size=3, mark.shape = 0.75, mark.expand = 15);
  title(main=title, cex.main=1.5); 
};
plot.sub.graph <- function(graph, member, title) {
  gr <- induced.subgraph(graph, member); 
  V(gr)$label <- V(gr)$name;
  plot(gr, vertex.size=4); 
  title(main=title, cex.main=1.5); 
};
run.ora <- function(cluster.list, mapping, background, annotation, method, dir) {
  ora <- lapply(cluster.list, function(cl) OraWrapper(cl, mapping, background, 1));
  ora <- lapply(ora, function(o) o[order(o[, 6]), ]);
  ora <- lapply(ora, function(o) cbind(ID=rownames(o), o, annotation[rownames(o), ])); 
  names(ora) <- paste('Cluster', 1:length(ora), sep='_'); 
  saveRDS(ora, paste(path.r, '/ORA_', method, '.rds', sep='')); 
  ind <- which(tolower(colnames(ora[[1]]))=='url'); 
  if (length(ind)>0) {
    ora <- lapply(ora, function(o) {
      o[[1]] <- AddHref(o[[1]], o[, ind]); 
      o[, -ind]; 
    })
  }; 
  ora <- lapply(ora, function(o) o[o[, 'PValue']<0.05, ])
  fn <- sapply(1:length(cluster.list), function(i) {
    fn <- paste('ORA_', method, '_', names(ora)[i], '.html', sep=''); 
    CreateDatatable(ora[[i]], paste(dir, fn, sep='/'), rownames = FALSE, 
                    caption = paste(method, '; Cluster_', i, sep='')); 
    paste('table', fn, sep='/'); 
  });
  list(file=fn, top=lapply(ora, function(o) o[1, ])); 
}; 
summarize.cluster <- function(cluster.list, ora, ll) {
  tp <- do.call('rbind', ora[[2]]); 
  ll <- ll[ll!=''];
  cr <- lapply(cluster.list, function(c) intersect(c, ll)); 
  cr <- as.vector(sapply(cr, function(x) paste(x, collapse="; ")));
  cls <- paste('[Cluster_', 1:length(cluster.list), '](', ora[[1]], ')', sep='');
  tbl <- data.frame(Cluster=cls, Size=sapply(cluster.list, length), Core_Member=cr, Top_Set=tp[[1]],
                    Top_OddsRatio=tp$OddsRatio, Top_PValue=tp$PValue, Top_FDR=tp$FDR, 
                    stringsAsFactors = FALSE);
  ind <- which(tolower(colnames(tp))=='name');
  tbl; 
};
summarize.node <- function(cluster.list, pairs, ora, tbl) {
  fn <- sapply(1:length(cluster.list), function(i) {
    c  <- cluster.list[[i]];
    pr <- pairs[pairs[, 1] %in% c & pairs[, 2] %in% c, , drop=FALSE];
    nm <- table(c(pr[, 1], pr[, 2]));
    nm <- rev(sort(nm));
    fn <- sub('.html', '.txt', ora[[1]][i]);
    write.table(cbind(Node=names(nm), Link=as.vector(nm)), paste(path, fn, sep='/'), sep='\t', 
                row.names = FALSE, col.names = TRUE, quote = FALSE);
    fn;
  });
  
  tbl$Size <- paste('[', tbl$Size, '](', fn, ')', sep='');
  tbl;
}
```

# Summary

The full network includes **`r num.node`** nodes and **`r num.edge`** edges (**`r round(num.edge/num.node, 2)`** edges per nodes).  For enrichment analysis, **`r length(inc.node)`** nodes in the network can be mapped to one or more node sets, while there are totally **`r length(unique(set.all))`** unique nodes in all node sets. The background of the enrichment analysis has **`r length(bgd)`** nodes. The maximum number of edges a node has is **`r max(num)`** and **`r length(num[num==1])`** (**`r round(100*length(num[num==1])/length(num), 2)`%**) nodes have only one edge. 

<div align='center'>
```{r hist_num_edge, include=TRUE, fig.width=6, fig.height=4.8, out.width='600px'}
par(mar=c(5,5,2,2));
hist(num, xlab='Number of edges per node', ylab='Count of nodes', cex.lab=2, main='', col='lightgrey');
```
</div>

<div style="color:darkblue; padding:0 3cm">
**Figure 1.** Number of edges per nodes.
</div>

```{r clustering_analysis, include=FALSE}
cluster.fg <- cluster_fast_greedy(igrph, weights = wgt);
cluster.wt <- cluster_walktrap(igrph, weights = wgt);
cluster.eb <- cluster_edge_betweenness(igrph, weights = wgt);

clusters <- list(fast_greedy=cluster.fg, walk_trap=cluster.wt, edge_betweenness=cluster.eb);
clts     <- lapply(clusters, function(c) {
  m <- membership(c); 
  c <- split(names(m), m);
  c[sapply(c, length)>=msz]
});

lbl <- V(igrph)$name;
names(lbl) <- lbl;
if (noi > 0) lbl[lbl %in% names(ngb)[ngb<noi]] <- '';
```

# Clustering analysis with different algorithms

## Fast greedy

<div align='center'>
```{r cluster_fast_greedy, include=TRUE, fig.width=8, fig.height=8, out.width='800px'}
cl <- clts[[1]]; 
ll <- label.hub(lbl, cl, ngb); 

plot.full.graph(igrph, clusters[[1]], ll, 'Fast greedy'); 
```
</div>


<div style="color:darkblue; padding:0 1cm">
**Figure 2A.** Clustering via the fast greedy modularity optimization algorithm.
</div>

<div align='center'>
```{r cluster_fast_greedy_sub, include=TRUE, fig.width=9.6, fig.height=3.2*ceiling(length(cl)/3), out.width='960px'}
par(mfrow=c(ceiling(length(cl)/3), 3)); 
for (i in 1:length(cl)) plot.sub.graph(igrph, cl[[i]], paste('Cluster', i, sep='_')); 
```
</div>

<div style="color:darkblue; padding:0 1cm">
**Figure 2B.** Individual clusters identified via the fast greedy modularity optimization algorithm.
</div>


```{r cluster_fast_greedy_ora, include=FALSE}
ora <- run.ora(cl, set.mpp, bgd, set.ann, 'FastGreedy', path.tbl); 
tbl <- summarize.cluster(cl, ora, ll); 
tbl <- summarize.node(cl, prs, ora, tbl); 
```

<div style="color:darkblue; padding:0 0.5cm">
**Table 1.** Enrichment analysis of network clusters identified by the fast greedy algorithm.
</div>
<div style="padding:0 0.5cm">
`r kable(tbl, row.names=FALSE)`
</div>

## Walktrap

<div align='center'>
```{r cluster_walktrap, include=TRUE, fig.width=8, fig.height=8, out.width='800px'}
cl <- clts[[2]]; 
ll <- label.hub(lbl, cl, ngb); 

plot.full.graph(igrph, clusters[[2]], ll, 'Walktrap'); 
```
</div>

<div style="color:darkblue; padding:0 1cm">
**Figure 3A.** Clustering via the Walktrap community finding algorithm.
</div>

<div align='center'>
```{r cluster_walktraps_sub, include=TRUE, fig.width=9.6, fig.height=3.2*ceiling(length(cl)/3), out.width='960px'}
par(mfrow=c(ceiling(length(cl)/3), 3)); 
for (i in 1:length(cl)) plot.sub.graph(igrph, cl[[i]], paste('Cluster', i, sep='_')); 
```
</div>

<div style="color:darkblue; padding:0 1cm">
**Figure 3B.** Individual clusters identified via the Walktrap community finding algorithm.
</div>

```{r cluster_walktraps_ora, include=FALSE}
ora <- run.ora(cl, set.mpp, bgd, set.ann, 'Walktrap', path.tbl); 
tbl <- summarize.cluster(cl, ora, ll); 
tbl <- summarize.node(cl, prs, ora, tbl); 
```

<div style="color:darkblue; padding:0 0.5cm">
**Table 2.** Enrichment analysis of network clusters identified by the walkgrap algorithm.
</div>
<div style="padding:0 0.5cm">
`r kable(tbl, row.names=FALSE)`
</div>

## Edge betweenness

<div align='center'>
```{r cluster_edge_betweenness, include=TRUE, fig.width=8, fig.height=8, out.width='800px'}
cl <- clts[[3]]; 
ll <- label.hub(lbl, cl, ngb); 

plot.full.graph(igrph, clusters[[3]], ll, 'Edge Betweenness'); 
```
</div>

<div style="color:darkblue; padding:0 1cm">
**Figure 4A.** Clustering via the edge betweenness algorithm.
</div>

<div align='center'>
```{r cluster_edge_betweenness_sub, include=TRUE, fig.width=9.6, fig.height=3.2*ceiling(length(cl)/3), out.width='960px'}
par(mfrow=c(ceiling(length(cl)/3), 3)); 
for (i in 1:length(cl)) plot.sub.graph(igrph, cl[[i]], paste('Cluster', i, sep='_')); 
```
</div>
<div style="color:darkblue; padding:0 1cm">
**Figure 4B.** Individual clusters identified via the edge betweenness algorithm.
</div>

```{r cluster_edge_betweenness_ora, include=FALSE}
ora <- run.ora(cl, set.mpp, bgd, set.ann, 'EdgeBetweenness', path.tbl); 
tbl <- summarize.cluster(cl, ora, ll); 
tbl <- summarize.node(cl, prs, ora, tbl); 
```

<div style="color:darkblue; padding:0 0.5cm">
**Table 3.** Enrichment analysis of network clusters identified by the edge betweenness algorithm.
</div>
<div style="padding:0 0.5cm">
`r kable(tbl, row.names=FALSE)`
</div>

# Session information

```{r session_info, echo=FALSE}
sessionInfo(); 
```

***
_END OF DOCUMENT_

