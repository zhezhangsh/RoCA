m <- match.all[[i]];
s <- rsc[[i]];
olap  <- findOverlaps(m, rng, type='within');
qry   <- olap@queryHits;
sub   <- olap@subjectHits;
stts  <- start(rng)[sub];
mcol  <- mcols(m)[qry, ];
seqID <- names(subject.set)[olap@subjectHits];
stt   <- start(m)[qry] - stts + 1;
end   <- end(m)[qry] - stts + 1;
str   <- mcols(m)$strand[qry];
score <- mcols(m)$percent[qry];
pval  <- ScorePWMPvalue(mcols(m)$score, s);
seqs  <- as.character(m)[qry];
data.frame(seqID=seqID, start=stt, end=end, strand=str, score=score, pvalue=pval, seq=seqs, stringsAsFactors = FALSE);
});
names(tbls) <- names(pwm.set);
m <- match.all[[i]];
s <- rsc[[i]];
olap  <- findOverlaps(m, rng, type='within');
qry   <- olap@queryHits;
sub   <- olap@subjectHits;
stts  <- start(rng)[sub];
mcol  <- mcols(m)[qry, ];
seqID <- names(subject.set)[olap@subjectHits];
stt   <- start(m)[qry] - stts + 1;
end   <- end(m)[qry] - stts + 1;
str   <- mcols(m)$strand[qry];
score <- mcols(m)$percent[qry];
pval  <- ScorePWMPvalue(mcols(m)$score, s);
seqs  <- as.character(m)[qry];
length(seqID)
length(stt)
olap  <- findOverlaps(m, rng, type='within');
qry   <- olap@queryHits;
sub   <- olap@subjectHits;
stts  <- start(rng)[sub];
mcol  <- mcols(m)[qry, ];
seqID <- names(subject.set)[sub];
length(seqID)
names(subject.set)
length(sub)
dim(olap)
length(qry)
m <- match.all[[i]];
s <- rsc[[i]];
olap  <- findOverlaps(m, rng, type='within');
qry   <- olap@queryHits;
sub   <- olap@subjectHits;
stts  <- start(rng)[sub];
mcol  <- mcols(m)[qry, ];
seqID <- names(subject.set)[sub];
stt   <- start(m)[qry] - stts + 1;
end   <- end(m)[qry] - stts + 1;
str   <- mcols(m)$strand[qry];
score <- mcols(m)$percent[qry];
pval  <- ScorePWMPvalue(mcols(m)$score, s);
seqs  <- as.character(m)[qry];
length(seqID
)
length(stt)
length(end)
length(str)
length(score)
length(pval)
tbls <- lapply(1:length(match.all), function(i) {
m <- match.all[[i]];
s <- rsc[[i]];
olap  <- findOverlaps(m, rng, type='within');
qry   <- olap@queryHits;
sub   <- olap@subjectHits;
stts  <- start(rng)[sub];
mcol  <- mcols(m)[qry, ];
seqID <- names(subject.set)[sub];
stt   <- start(m)[qry] - stts + 1;
end   <- end(m)[qry] - stts + 1;
str   <- mcols(m)$strand[qry];
score <- mcols(m)$percent[qry];
pval  <- ScorePWMPvalue(mcols(m)$score[qry], s);
seqs  <- as.character(m)[qry];
data.frame(seqID=seqID, start=stt, end=end, strand=str, score=score, pvalue=pval, seq=seqs, stringsAsFactors = FALSE);
});
names(tbls) <- names(pwm.set);
head(tbls[[1]])
tbls <- lapply(1:length(match.all), function(i) {
m <- match.all[[i]];
s <- rsc[[i]];
olap  <- findOverlaps(m, rng, type='within');
qry   <- olap@queryHits;
sub   <- olap@subjectHits;
stts  <- start(rng)[sub];
mcol  <- mcols(m)[qry, ];
seqID <- names(subject.set)[sub];
stt   <- start(m)[qry] - stts + 1;
end   <- end(m)[qry] - stts + 1;
str   <- mcols(m)$strand[qry];
score <- mcols(m)$percent[qry];
pval  <- ScorePWMPvalue(mcols(m)$score[qry], s);
seqs  <- as.character(m)[qry];
t <- data.frame(seqID=seqID, start=stt, end=end, strand=str, score=score, pvalue=pval, seq=seqs, stringsAsFactors = FALSE);
t <- t[order(t$score), , drop=FALSE];
rownames(t) <- 1:nrow(t);
t;
});
names(tbls) <- names(pwm.set);
tbls[[1]]
both.strand
both.strand <- TRUE
pvalue <- 10-6
# PWM matrix
pwm.set <- lapply(pwm.set, function(pwm) if (is.character(pwm) | is.factor(pwm) | class(pwm)=='DNAStringSet') ConvertSeq2PWM(pwm) else pwm);
# Union sequences
if (is.character(subject.set)) subject.set <- DNAStringSet(subject.set);
seq.all <- BiocGenerics::unlist(subject.set);
# Make sure all sequences have names
nms <- names(seq);
if (is.null(nms)) nms <- paste('Seq', 1:length(seq), sep='_');
ind <- which(is.na(nms) | nms=='');
if (length(ind) > 0) nms[ind] <- paste('Seq', ind, sep='_');
names(seq) <- nms;
# Sequence break points
len <- width(subject.set);
end <- cumsum(len);
stt <- c(1, 1+end[-length(end)]);
rng <- Views(seq.all, start = stt, end = end);
# Minimal matching scores
frq <- colSums(alphabetFrequency(subject.set));
frq <- frq[1:4]/sum(frq);
rsc <- mclapply(pwm.set, function(pwm) {
s <- ScorePWMDist(pwm, frq=frq, num=sampling);
c <- s[min(ceiling(pvalue*length(s)), length(s))];
c <- floor(100*(c/maxScore(pwm)));
list(c, s);
}, mc.cores = num.cluster);
min.score <- sapply(rsc, function(x) x[[1]]);
rsc <- lapply(rsc, function(x) x[[2]]);
########################################################################################
match.all <- mclapply(1:length(pwm.set), function(i) {
ScorePWMMatch(pwm.set[[i]], seq.all, both.strand = both.strand, local.max = local.max,
min.score = min.score[i], min.match = 1);
}, mc.cores = num.cluster);
########################################################################################
sapply(match.all, length)
min.score
min.match
str(rsc)
pwm <- pwm[[1]]
s <- ScorePWMDist(pwm, frq=frq, num=sampling);
frq
sampling
pwm
pwm.set
pwm <- pwm.set[[1]]
pwm
s <- ScorePWMDist(pwm, frq=frq, num=sampling);
length(s)
head(s)
c <- s[min(ceiling(pvalue*length(s)), length(s))];
c
min(ceiling(pvalue*length(s)), length(s))
ceiling(pvalue*length(s))
pvalue
pvalue <- 10^-6
pvalue
# Minimal matching scores
frq <- colSums(alphabetFrequency(subject.set));
frq <- frq[1:4]/sum(frq);
rsc <- mclapply(pwm.set, function(pwm) {
s <- ScorePWMDist(pwm, frq=frq, num=sampling);
c <- s[min(ceiling(pvalue*length(s)), length(s))];
c <- floor(100*(c/maxScore(pwm)));
list(c, s);
}, mc.cores = num.cluster);
min.score <- as.vector(sapply(rsc, function(x) x[[1]]));
rsc <- lapply(rsc, function(x) x[[2]]);
min.score
match.all <- mclapply(1:length(pwm.set), function(i) {
ScorePWMMatch(pwm.set[[i]], seq.all, both.strand = both.strand, local.max = local.max,
min.score = min.score[i], min.match = 1);
}, mc.cores = num.cluster);
########################################################################################
sapply(match.all, length)
min.score <- min.score*2
min.score <- 100
match.all <- mclapply(1:length(pwm.set), function(i) {
ScorePWMMatch(pwm.set[[i]], seq.all, both.strand = both.strand, local.max = local.max,
min.score = min.score[i], min.match = 1);
}, mc.cores = num.cluster);
########################################################################################
min.score
min.score <- rep(100, length(pwm.set))
match.all <- mclapply(1:length(pwm.set), function(i) {
ScorePWMMatch(pwm.set[[i]], seq.all, both.strand = both.strand, local.max = local.max,
min.score = min.score[i], min.match = 1);
}, mc.cores = num.cluster);
########################################################################################
################################################################
# Split matches
tbls <- lapply(1:length(match.all), function(i) {
m <- match.all[[i]];
s <- rsc[[i]];
olap  <- findOverlaps(m, rng, type='within');
qry   <- olap@queryHits;
sub   <- olap@subjectHits;
stts  <- start(rng)[sub];
mcol  <- mcols(m)[qry, ];
seqID <- names(subject.set)[sub];
stt   <- start(m)[qry] - stts + 1;
end   <- end(m)[qry] - stts + 1;
str   <- mcols(m)$strand[qry];
score <- mcols(m)$percent[qry];
pval  <- ScorePWMPvalue(mcols(m)$score[qry], s);
seqs  <- as.character(m)[qry];
t <- data.frame(seqID=seqID, start=stt, end=end, strand=str, score=score, pvalue=pval, seq=seqs, stringsAsFactors = FALSE);
t <- t[rev(order(t$score), , drop=FALSE];
rownames(t) <- 1:nrow(t);
t;
});
names(tbls) <- names(pwm.set);
tbls <- lapply(1:length(match.all), function(i) {
m <- match.all[[i]];
s <- rsc[[i]];
olap  <- findOverlaps(m, rng, type='within');
qry   <- olap@queryHits;
sub   <- olap@subjectHits;
stts  <- start(rng)[sub];
mcol  <- mcols(m)[qry, ];
seqID <- names(subject.set)[sub];
stt   <- start(m)[qry] - stts + 1;
end   <- end(m)[qry] - stts + 1;
str   <- mcols(m)$strand[qry];
score <- mcols(m)$percent[qry];
pval  <- ScorePWMPvalue(mcols(m)$score[qry], s);
seqs  <- as.character(m)[qry];
t <- data.frame(seqID=seqID, start=stt, end=end, strand=str, score=score, pvalue=pval, seq=seqs, stringsAsFactors = FALSE);
t <- t[rev(order(t$score), , drop=FALSE];
rownames(t) <- 1:nrow(t);
t;
});
t <- data.frame(seqID=seqID, start=stt, end=end, strand=str, score=score, pvalue=pval, seq=seqs, stringsAsFactors = FALSE);
tbls <- lapply(1:length(match.all), function(i) {
m <- match.all[[i]];
s <- rsc[[i]];
olap  <- findOverlaps(m, rng, type='within');
qry   <- olap@queryHits;
sub   <- olap@subjectHits;
stts  <- start(rng)[sub];
mcol  <- mcols(m)[qry, ];
seqID <- names(subject.set)[sub];
stt   <- start(m)[qry] - stts + 1;
end   <- end(m)[qry] - stts + 1;
str   <- mcols(m)$strand[qry];
score <- mcols(m)$percent[qry];
pval  <- ScorePWMPvalue(mcols(m)$score[qry], s);
seqs  <- as.character(m)[qry];
t <- data.frame(seqID=seqID, start=stt, end=end, strand=str, score=score, pvalue=pval, seq=seqs, stringsAsFactors = FALSE);
t <- t[rev(order(t$score)), , drop=FALSE];
rownames(t) <- 1:nrow(t);
t;
});
names(tbls) <- names(pwm.set);
tbls[[1]]
install_local('~/Documents/Agri/')
yml
rm(yml)
name.yaml <- 'rGADEM.yaml';
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'GenomicFeatures', 'rGADEM',
'RoCA', 'awsomics', 'Agri');
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table'); # <full.path.to.subfolder>=<subfolder.name>
## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }
## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template
prms <- yml$parameter;
## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]);
## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
tp <- yml$input$seq$type[1];
if (tp == 'DNAStringSet') {
seq <- ImportR(DownloadFile(yml$input$seq$file, path.input));
} else if (tp == 'character') {
seq <- ImportVector(DownloadFile(yml$input$seq$file, path.input));
seq <- DNAStringSet(seq);
} else if (tp == 'GRanges' | tp == 'bed') {
if (exists('rng')) rm(rng);
if (tp == 'GRanges') rng <- ImportR(DownloadFile(yml$input$seq$file, path.input)) else {
bed <- ImportTable(DownloadFile(yml$input$seq$file, path.input), rownames = FALSE, colnames = FALSE);
if (ncol(bed) >= 6) str <- as.vector(bed[, 6]) else str <- rep('*', nrow(bed));
rng <- GRanges(bed[, 1], IRanges(bed[, 2], bed[, 3]), strand=str);
if (ncol(bed) >= 4) names(rng) <- as.vector(bed[, 4]) else names(rng) <- paste('Seq', 1:length(rng), sep='_');
}
require(yml$input$reference, character.only = TRUE);
gname <- strsplit(yml$input$reference, '\\.')[[1]][2];
assign('gnm', get(gname));
genome(rng) <- genome(gnm);
seq <- getSeq(gnm, rng);
} else {
stop("No input sequences.\n");
}
wid <- width(seq);
nms <- names(seq);
if (is.null(nms)) nms <- paste('Seq', 1:length(seq), sep='_');
ind <- which(is.na(nms) | nms=='');
if (length(ind) > 0) nms[ind] <- paste('Seq', ind, sep='_');
names(seq) <- nms;
if (exists('rng')) names(rng) <- names(seq);
rm(yml)
name.yaml <- 'rGADEM.yaml';
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'GenomicFeatures', 'rGADEM',
'RoCA', 'awsomics', 'Agri');
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table'); # <full.path.to.subfolder>=<subfolder.name>
## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }
## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template
prms <- yml$parameter;
## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]);
## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
tp <- yml$input$seq$type[1];
if (tp == 'DNAStringSet') {
seq <- ImportR(DownloadFile(yml$input$seq$file, path.input));
} else if (tp == 'character') {
seq <- ImportVector(DownloadFile(yml$input$seq$file, path.input));
seq <- DNAStringSet(seq);
} else if (tp == 'GRanges' | tp == 'bed') {
if (exists('rng')) rm(rng);
if (tp == 'GRanges') rng <- ImportR(DownloadFile(yml$input$seq$file, path.input)) else {
bed <- ImportTable(DownloadFile(yml$input$seq$file, path.input), rownames = FALSE, colnames = FALSE);
if (ncol(bed) >= 6) str <- as.vector(bed[, 6]) else str <- rep('*', nrow(bed));
rng <- GRanges(bed[, 1], IRanges(bed[, 2], bed[, 3]), strand=str);
if (ncol(bed) >= 4) names(rng) <- as.vector(bed[, 4]) else names(rng) <- paste('Seq', 1:length(rng), sep='_');
}
require(yml$input$reference, character.only = TRUE);
gname <- strsplit(yml$input$reference, '\\.')[[1]][2];
assign('gnm', get(gname));
genome(rng) <- genome(gnm);
seq <- getSeq(gnm, rng);
} else {
stop("No input sequences.\n");
}
wid <- width(seq);
nms <- names(seq);
if (is.null(nms)) nms <- paste('Seq', 1:length(seq), sep='_');
ind <- which(is.na(nms) | nms=='');
if (length(ind) > 0) nms[ind] <- paste('Seq', ind, sep='_');
names(seq) <- nms;
if (exists('rng')) names(rng) <- names(seq);
pwm.set <- lapply(res, function(x) x[[3]][[1]]);
length(pwm.set)
length(seq)
seq
pwm.set <- lapply(res, function(x) x[[3]][[1]]);
matches <- ScorePWMWrapper(pwm.set, seq, num.cluster = prms$rematch$cluster, both.strand = TRUE, local.max = TRUE,
sampling = prms$rematch$sampling, pvalue = prms$rematch$pvalue);
nms <- names(seq);
if (is.null(nms)) nms <- paste('Seq', 1:length(seq), sep='_');
ind <- which(is.na(nms) | nms=='');
if (length(ind) > 0) nms[ind] <- paste('Seq', ind, sep='_');
seq
names(seq)
names(seq) <- nms
rm(nms)
pwm.set <- lapply(res, function(x) x[[3]][[1]]);
matches <- ScorePWMWrapper(pwm.set, seq, num.cluster = prms$rematch$cluster, both.strand = TRUE, local.max = TRUE,
sampling = prms$rematch$sampling, pvalue = prms$rematch$pvalue);
install_local('~/Documents/Agri/')
matches <- ScorePWMWrapper(pwm.set, seq, num.cluster = prms$rematch$cluster, both.strand = TRUE, local.max = TRUE,
sampling = prms$rematch$sampling, pvalue = prms$rematch$pvalue);
head(matches[[1]])
sapply(matches, nrow)
t <- matches[[1]]
head(t)
summary(t[, 5])
summary(t[, 6])
t
rng
names(matches) <- names(res);
saveRDS(matches, paste(path.r, 'rematch.rds', sep='/'));
# summarize
stat <- sapply(tbls, function(t) {
ns <- c(nrow(t), length(unique(t[, 1])));
ln <- max(t[,3]-t[,2]+1, na.rm=TRUE);
sc <- c(min(t$score), mean(t$score), max(t$score));
fq <- ns[1]/(sum(wid)/1000);
c(ln, fq, ns, sc);
});
stat <- t(stat);
dimnames(stat) <- list(names(res), c('Len_Motif', 'Match_Per_Kb', 'Num_Match', 'Num_Seq',
'Min_Score', 'Mean_Score', 'Max_Score'));
stat
head(t)
stat <- sapply(matches, function(t) {
ns <- c(nrow(t), length(unique(t[, 1])));
ln <- max(t[,3]-t[,2]+1, na.rm=TRUE);
sc <- c(min(t$score), mean(t$score), max(t$score));
fq <- ns[1]/(sum(wid)/1000);
c(ln, fq, ns, sc);
});
stat <- t(stat);
dimnames(stat) <- list(names(res), c('Len_Motif', 'Match_Per_Kb', 'Num_Match', 'Num_Seq',
'Min_Score', 'Mean_Score', 'Max_Score'));
stat
rm(list=ls())
source('~/.active-rstudio-document', echo=TRUE)
names(res) <- paste('Motif', 1:length(res), sep='_');
saveRDS(res, paste(path.r, 'GADEM.rds', sep='/'));
num <- length(res);
con <- consensus(gadem);
len <- nchar(con);
nms <- names(res);
if (num == 0) {
fig <- tbl <- matrix('**No motif found**', dimnames = list('', ''));
} else {
################################################################
# Plot Logo
sapply(1:num, function(i) {
png(paste(path.fig, '/Logo_', nms[i], '.png', sep=''), width = 640, height = 320, res = 100);
plot(gadem[i], main=nms[i]);
dev.off();
pdf(paste(path.fig, '/Logo_', nms[i], '.pdf', sep=''), width = 6, height = 4);
plot(gadem[i]);
dev.off();
});
logo <- paste(' ![](figure/Logo_', nms, '.png)', sep='');
################################################################
################################################################
# Plot match position
sapply(1:num, function(i) {
mtch <- res[[i]][[3]];
pos <- mtch$pos;
str <- as.vector(mtch$strand);
pos[str=='+'] <- pos[str=='+'] + len[i]/2;
pos[str=='-'] <- pos[str=='-'] - len[i]/2;
pos <- 100*pos/wid[mtch$seqID]
png(paste(path.fig, '/Position_', nms[i], '.png', sep=''), width = 480, height = 320, res = 100);
par(mar=c(5, 5, 3, 1));
hist(pos, breaks=seq(0, 100, 5+(nrow(mtch)<50)*5), xaxt='n', xlab='Position', ylab='# of matches', cex.lab=1.5,
col='lightgrey', main=nms[i], cex.main=2);
axis(1, at=c(0, 50, 100), label=c('Start', 'Center', 'End'));
dev.off();
pdf(paste(path.fig, '/Position_', nms[i], '.pdf', sep=''), width = 4.8, height = 3.2);
par(mar=c(5, 5, 3, 1));
hist(pos, breaks=seq(0, 100, 5+(nrow(mtch)<50)*5), xaxt='n', xlab='Position', ylab='# of matches', cex.lab=1.5,
col='lightgrey', main=nms[i], cex.main=2);
axis(1, at=c(0, 50, 100), label=c('Start', 'Center', 'End'));
dev.off();
});
posi <- paste(' ![](figure/Position_', nms, '.png)', sep='');
################################################################
fig  <- cbind("Matching position"=posi, "PWM Logo"=logo);
################################################################
fn  <- sapply(1:num, function(i) {
CreateDatatable(FormatNumeric(res[[i]][[3]]), paste(path.tbl, '/Match_', nms[i], '.html', sep=''),
rownames = FALSE, caption = paste(nms[i], con[i], sep=': '));
CreateDatatable(FormatNumeric(res[[i]][[1]]), paste(path.tbl, '/PWM_',   nms[i], '.html', sep=''),
rownames = FALSE, caption = paste(nms[i], con[i], sep=': '));
write.table(res[[i]][[3]], paste(path.tbl, '/Match_', nms[i], '.txt', sep=''), row.names = FALSE,
sep='\t', qu=FALSE);
});
gc  <- sapply(res, function(x) round(mean(100*colSums(x[[1]][c('C', 'G'), ])), 2));
tbl <- data.frame(Name = nms, Consensus = con, 'GC_Percent' = gc, Num_Base = nchar(con),
Num_Match = nOccurrences(gadem),
Num_Seq = sapply(res, function(x) length(unique(x[[3]]$seqID))), stringsAsFactors = FALSE);
tbl[[1]] <- paste('[', tbl[[1]], '](table/Match_', nms, '.html)', sep='');
tbl[[2]] <- paste('[', tbl[[2]], '](table/PWM_', nms, '.html)', sep='');
################################################################
}
if (length(res) == 0) {
stat <- matrix('**No motif found**', dimnames = list('', ''));
} else {
# Re-match
pwm.set <- lapply(res, function(x) x[[3]][[1]]);
matches <- ScorePWMWrapper(pwm.set, seq, num.cluster = prms$rematch$cluster, both.strand = TRUE, local.max = TRUE,
sampling = prms$rematch$sampling, pvalue = prms$rematch$pvalue);
# summarize
stat <- sapply(matches, function(t) {
ns <- c(nrow(t), length(unique(t[, 1])));
ln <- max(t[,3]-t[,2]+1, na.rm=TRUE);
sc <- c(min(t$score), mean(t$score), max(t$score));
fq <- ns[1]/(sum(wid)/1000);
c(ln, fq, ns, sc);
});
stat <- t(stat);
dimnames(stat) <- list(names(res), c('Len_Motif', 'Match_Per_Kb', 'Num_Match', 'Num_Seq',
'Min_Score', 'Mean_Score', 'Max_Score'));
}
kable(stat, align='c')
kable(FormatNumeric(stat), align='c')
kable(FormatNumeric(stat))
