---
title: "Package wrapper: ***rGADEM***, de novo motif discovery"
author: "`r if (exists('yml')) yml$analyst else 'Jim Zhang'`"
date: "`r Sys.Date()`"
output:
  html_document:
    number_sections: yes
    self_contained: no
    toc: yes
    toc_float:
      collapsed: no
---

<div style="border:black 1px solid; padding: 0.5cm 0.5cm">

**Introduction** 

This is an R markdown template that implements main functionality of Bioconductor package ***rGADEM***. Please read the package [manual](https://www.bioconductor.org/packages/devel/bioc/vignettes/rGADEM/inst/doc/rGADEM.pdf) first for the background information and parameter options of using this package.

The main input data to this analysis is a set of DNA sequences, within which de novo motifs and their position weighted matrix (PWM) will be discovered. The DNA sequences can be provided as named character vector, an _DNAStringSet_ object, or a set of genomic locations with their reference genome, such as _[BSgenome.Hsapiens.NCBI.GRCh38](http://bioconductor.org/packages/release/data/annotation/html/BSgenome.Hsapiens.NCBI.GRCh38.html)_.

This analysis includes three major steps:

  1. The **GADEM {rGADEM}** function is used to discover de novo motifs from the DNA sequences and report the matches to the motifs
  2. The motifs and matches are summarized and visualized
  3. The motifs are re-matched to the DNA sequences using the **matchPWM {Biostrings}** function and a p value cutoff, to identify extra matches

</div>

&nbsp;

```{r global_setup, eval=TRUE, include=FALSE}
name.yaml <- 'rGADEM.yaml'; 
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'GenomicFeatures', 'rGADEM', 
                   'RoCA', 'awsomics', 'Agri'); 
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table'); # <full.path.to.subfolder>=<subfolder.name>

## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));

if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
	if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
		yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template

prms <- yml$parameter;

## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]); 

## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
```

`r home.url` 

# Description

`r WriteDescription(yml$description)`

`r home.url`

```{r load_data, include=FALSE}
tp <- yml$input$seq$type[1];
if (tp == 'DNAStringSet') {
  seq <- ImportR(DownloadFile(yml$input$seq$file, path.input)); 
} else if (tp == 'character') {
  seq <- ImportVector(DownloadFile(yml$input$seq$file, path.input));
  seq <- DNAStringSet(seq); 
} else if (tp == 'GRanges' | tp == 'bed') {
  if (exists('rng')) rm(rng); 
  if (tp == 'GRanges') rng <- ImportR(DownloadFile(yml$input$seq$file, path.input)) else {
    bed <- ImportTable(DownloadFile(yml$input$seq$file, path.input), rownames = FALSE, colnames = FALSE); 
    if (ncol(bed) >= 6) str <- as.vector(bed[, 6]) else str <- rep('*', nrow(bed)); 
    rng <- GRanges(bed[, 1], IRanges(bed[, 2], bed[, 3]), strand=str);
    if (ncol(bed) >= 4) names(rng) <- as.vector(bed[, 4]) else names(rng) <- paste('Seq', 1:length(rng), sep='_'); 
  }
  require(yml$input$reference, character.only = TRUE);
  gname <- strsplit(yml$input$reference, '\\.')[[1]][2];
  assign('gnm', get(gname));
  genome(rng) <- genome(gnm);
  seq <- getSeq(gnm, rng);
} else {
  stop("No input sequences.\n");
}

nms <- names(seq);
if (is.null(nms)) nms <- paste('Seq', 1:length(seq), sep='_'); 
ind <- which(is.na(nms) | nms=='');
if (length(ind) > 0) nms[ind] <- paste('Seq', ind, sep='_');
names(seq) <- nms;
if (exists('rng')) names(rng) <- names(seq); 

wid <- width(seq);
names(wid) <- names(seq);
```

# Motif discovery

```{r summary_seq, include=FALSE}
frq <- alphabetFrequency(seq)[, 1:4];
gc  <- round(100*rowSums(frq[, 2:3])/rowSums(frq), 2);
len <- summary(wid); 
pct <- summary(gc); 
tbl <- rbind(len, pct); 
rownames(tbl) <- c('Length (bp)', 'GC (%)');
```

```{r motif_discovery, include=FALSE}
gadem <- GADEM(seq, 
               numEM   = prms$GADEM$numEM,
               pValue  = prms$GADEM$pValue, 
               maskR   = prms$GADEM$maskR,
               nmotifs = prms$GADEM$nmotifs); 
```


A total of **`r length(seq)`** sequences are used by the **GADEM {rGADEM}** function to discovery de novo motifs (see **Table 1**). The function call uses the following parameters:

  - Seed PWM (_Spwm_): no
  - Number of EM steps (_numEM_): `r prms$GADEM$numEM`
  - P value cutoff of matches (_pValue_): `r format(prms$GADEM$pValue)`
  - Mask low-complexity sequences (_maskR_): `r c('no', 'yes')[1+prms$GADEM$maskR]`
  - Maximal number of motifs allowed (_nmotifs_): `r prms$GADEM$nmotifs`

<div style="color:darkblue; padding:0 2cm">
**Table 1** Length and GC content of the sequences.
</div>

<div align='center', style="padding:0 2cm">
`r kable(tbl, align=c('c'))`
</div>
  
`r home.url` 

# Motif summary

```{r motif_summary, include=FALSE}
res <- RetrieveGadem(gadem);
res <- lapply(res, function(x) { print(x[[2]]);
  tbl <- x[[3]][, c(1, 7, 5, 8, 6)]; 
  tbl$seqName <- names(seq)[tbl$seqID];
  if (exists('rng')) {
    tbl$seqChr    <- as.vector(seqnames(rng))[tbl$seqID];
    tbl$seqStart  <- start(rng)[tbl$seqID];
    tbl$seqEnd    <- end(rng)[tbl$seqID];
    tbl$seqStrand <- as.vector(strand(rng))[tbl$seqID];
  };
  x[[3]] <- tbl;
  x; 
});
names(res) <- paste('Motif', 1:length(res), sep='_');
saveRDS(res, paste(path.r, 'GADEM.rds', sep='/')); 

num <- length(res); 
con <- consensus(gadem); 
len <- nchar(con);

if (num == 0) {
  fig <- tbl <- matrix('**No motif found**', dimnames = list('', ''));
} else {
  ################################################################
  # Plot Logo
  sapply(1:num, function(i) {
    png(paste(path.fig, '/Logo_', names(res)[i], '.png', sep=''), width = 640, height = 320, res = 100);
    plot(gadem[i], main=names(res)[i]); 
    dev.off(); 
    pdf(paste(path.fig, '/Logo_', names(res)[i], '.pdf', sep=''), width = 6, height = 4);
    plot(gadem[i]); 
    dev.off(); 
  }); 
  logo <- paste(' ![](figure/Logo_', names(res), '.png)', sep='');
  ################################################################
  
  ################################################################
  # Plot match position
  sapply(1:num, function(i) {
    mtch <- res[[i]][[3]]; 
    pos <- mtch$pos;
    str <- as.vector(mtch$strand);
    pos[str=='+'] <- pos[str=='+'] + len[i]/2;
    pos[str=='-'] <- pos[str=='-'] - len[i]/2;
    pos <- 100*pos/wid[mtch$seqID] 
     
    png(paste(path.fig, '/Position_', names(res)[i], '.png', sep=''), width = 480, height = 320, res = 100);
    par(mar=c(5, 5, 3, 1)); 
    hist(pos, breaks=seq(0, 100, 5+(nrow(mtch)<50)*5), xaxt='n', xlab='Position', ylab='# of matches', cex.lab=1.5, 
         col='lightgrey', main=names(res)[i], cex.main=2); 
    axis(1, at=c(0, 50, 100), label=c('Start', 'Center', 'End'));
    dev.off();
    pdf(paste(path.fig, '/Position_', names(res)[i], '.pdf', sep=''), width = 4.8, height = 3.2);
    par(mar=c(5, 5, 3, 1)); 
    hist(pos, breaks=seq(0, 100, 5+(nrow(mtch)<50)*5), xaxt='n', xlab='Position', ylab='# of matches', cex.lab=1.5, 
         col='lightgrey', main=names(res)[i], cex.main=2); 
    axis(1, at=c(0, 50, 100), label=c('Start', 'Center', 'End'));
    dev.off();
  }); 
  posi <- paste(' ![](figure/Position_', names(res), '.png)', sep='');
  ################################################################
  fig  <- cbind("Matching position"=posi, "PWM Logo"=logo); 

  ################################################################
  fn  <- sapply(1:num, function(i) {
    CreateDatatable(FormatNumeric(res[[i]][[3]]), paste(path.tbl, '/Match_', names(res)[i], '.html', sep=''), 
                    rownames = FALSE, caption = paste(names(res)[i], con[i], sep=': '));     
    CreateDatatable(FormatNumeric(res[[i]][[1]]), paste(path.tbl, '/PWM_',   names(res)[i], '.html', sep=''), 
                    rownames = FALSE, caption = paste(names(res)[i], con[i], sep=': '));   
    write.table(res[[i]][[3]], paste(path.tbl, '/Match_', names(res)[i], '.txt', sep=''), row.names = FALSE, 
                sep='\t', qu=FALSE); 
  });

  gc  <- sapply(res, function(x) round(mean(100*colSums(x[[1]][c('C', 'G'), ])), 2));
  tbl <- data.frame(Name = names(res), Consensus = con, 'GC_Percent' = gc, Num_Base = nchar(con), 
                    Num_Match = nOccurrences(gadem), 
                    Num_Seq = sapply(res, function(x) length(unique(x[[3]]$seqID))), stringsAsFactors = FALSE); 
  tbl[[1]] <- paste('[', tbl[[1]], '](table/Match_', names(res), '.html)', sep='');
  tbl[[2]] <- paste('[', tbl[[2]], '](table/PWM_', names(res), '.html)', sep='');
  ################################################################
}
```


The **GADEM {rGADEM}** function discovers **`r nMotifs(gadem)`** motif(s) from the DNA sequences. For each motif, the output includes reports its consensus sequence, PWM, and detailed information about all matches. 

<div style="color:darkblue; padding:0 1cm">
**Table 2** Summary of motifs found from sequences. Click motif name to see full list of matches to each motif and consensus sequence to see its PWM. (***GC_Percent:*** average G/C percent in PWM;  ***Num_Base:*** number of bases of the motif; ***Num_Match:*** total number of matches to the motif in all sequences; and ***Num_Seq:*** number of sequences including one or more matches to the motif.)
</div>

<div align='center', style="padding:0 1cm">
`r kable(tbl, row.names=FALSE, align=c('c', 'l', 'r', 'r', 'r'))`
</div>

&nbsp;

<div align='center'>
`r kable(fig,  row.names=FALSE, align='c')`
</div>

<div style="color:darkblue; padding:0 1cm">
**Figure 1.** Motif visualization. The right panel shows the logo of the consensus sequence and the left panel shows the relative positions of the matches to the motif within the sequences. 
</div>

`r home.url` 

# Motif re-match

```{r motif_rematch, include=FALSE}
if (length(res) == 0) {
  stat <- matrix('**No motif found**', dimnames = list('', ''));
} else {
  # Re-match
  pwm.set <- lapply(res, function(x) x[[3]][[1]]); 
  matches <- ScorePWMWrapper(pwm.set, seq, num.cluster = prms$rematch$cluster, both.strand = TRUE, local.max = TRUE, 
                           sampling = prms$rematch$sampling, pvalue = prms$rematch$pvalue);
  
  fn <- sapply(1:length(matches), function(i) {
    tbl <- matches[[i]]; 
    if (exists('rng')) {
      tbl$seqChr    <- as.vector(seqnames(rng))[tbl$seqID];
      tbl$seqStart  <- start(rng)[tbl$seqID];
      tbl$seqEnd    <- end(rng)[tbl$seqID];
      tbl$seqStrand <- as.vector(strand(rng))[tbl$seqID];
    };
    CreateDatatable(matches[[i]], paste(path.tbl, '/Rematch_', names(res)[i], '.html', sep=''), 
                    caption = paste(names(res)[i], con[i], sep=': ')); 
  });
   
  # summarize
  stat <- sapply(matches, function(t) {
    ns <- c(nrow(t), length(unique(t[, 1]))); 
    ln <- max(t[,3]-t[,2]+1, na.rm=TRUE);
    sc <- c(min(t$score), mean(t$score), max(t$score));
    fq <- ns[1]/(sum(wid)/1000);
    sr <- round(100*nrow(t[t$strand==1, , drop=FALSE])/nrow(t), 2);
    c(ln, fq, ns, sr, sc); 
  }); 
  stat <- t(stat); 
  dimnames(stat) <- list(names(res), c('Len_Motif', 'Match_Per_Kb', 'Num_Match', 'Num_Seq', 'Strand(%)',
                                       'Min_Score', 'Mean_Score', 'Max_Score'));
  lnk <- paste('[', rownames(stat), '](', paste('table/Rematch_', names(res), '.html', sep=''), ')', sep='');
  stat <- data.frame(Motif=lnk, stat, stringsAsFactors = FALSE);
}
```

The motifs discovered previously are re-matched to the DNA sequences by applying the following steps on each motif:

  - Calculate average base frequency of all DNA sequences
  - Draw `r prms$rematch$sampling` random sequences of the same length as the motif
  - Calculate the matching scores of the random sequences to get a background distribution
  - Use the cutoff of empirical p value (`r prms$rematch$pvalue`) to the cutoff of matching score
  - Re-match the motif to the sequences using the cutoff of matching score from the last step

<div style="color:darkblue; padding:0 2cm">
**Table 3** Summary of re-matching result. The columns are: _motif length, number of matches per kilobases, number of total matches, number of sequences including one or more matches, as well as the minimal, average, and maximal matching scores (highest = 100)_. Click on motif names to see the full lists of matches
</div>

<div align='center', style="padding:0 1cm">
`r kable(FormatNumeric(stat), row.names=FALSE)`
</div>

&nbsp;

<div align='center'>
```{r rematch_position, include=TRUE, fig.width=9.6, fig.height=max(1.2, 3.6*round(length(res)/3)), out.width='960px'}
if (length(res) == 0) {
  par(mar=c(1,1,1,1));
  frame();
  text(0.5, 0, pos=3, label='No motif found', cex=2);
} else {
  par(mfrow=c(round(length(res)/2), 2));
  sapply(names(matches), function(nm) {
    m   <- matches[[nm]]; 
    pos <- m$start;
    ttl <- wid[m$seqID];
    pvl <- m$pvalue;
    len <- max(nchar(m$seq));
    PlotPWMMatchPosition(pos, ttl, pvl, len);
    title(main=nm, cex=2);
  }) -> x;
}

```
</div>

<div style="color:darkblue; padding:0 1cm">
**Figure 2.** Distribution of relative positions of motif matches within the DNA sequences. Grey bar is the number of matches within each interval and blue star is the average P values (-log10 transformed) of matches within the interval. 
</div>

`r home.url`

***

# Appendix 

Check out the **[RoCA home page](http://zhezhangsh.github.io/RoCA)** for more information.  

## Reproduce this report

To reproduce this report: 

  1. Find the data analysis template you want to use and an example of its pairing YAML file  [here](https://github.com/zhezhangsh/RoCA/wiki/Templates-and-examples) and download the YAML example to your working directory

  2. To generate a new report using your own input data and parameter, edit the following items in the YAML file:

    - _output_        : where you want to put the output files
    - _home_          : the URL if you have a home page for your project
    - _analyst_       : your name
    - _description_   : background information about your project, analysis, etc.
    - _input_         : where are your input data, read instruction for preparing them
    - _parameter_     : parameters for this analysis; read instruction about how to prepare input data

  3. Run the code below within ***R Console*** or ***RStudio***, preferablly with a new R session:

```{r reproduce_report, eval=FALSE, echo=TRUE}
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

CreateReport(filename.yaml);  # filename.yaml is the YAML file you just downloaded and edited
```

If there is no complaint, go to the _output_ folder and open the ***index.html*** file to view report. 

## Session information

```{r session_info, echo=FALSE}
sessionInfo(); 
```

`r home.url`

***
_END OF DOCUMENT_
