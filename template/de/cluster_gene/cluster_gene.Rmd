---
title: "Cluster genes across multiple sample groups"
author: "`r if (exists('yml')) yml$analyst else 'Jim Zhang'`"
date: "`r Sys.Date()`"
output:
  html_document:
    self_contained: no
    number_sections: yes
    toc: yes
    toc_float: 
      collapsed: no
---

<div style="border:black 1px solid; padding: 0.5cm 0.5cm">
**Introduction: ** This analysis performs a gene-gene clustering procedure that will identify clusters of co-expressed genes across multiple sample groups. It first runs an ANOVA to find genes significantly changed across sample groups and uses these genes as seeds to initiate a number of gene clusters. These clusters will be further refined based on several user-specific paramters. Gene set enrichment analysis is then used to find pre-defined gene sets that are over-represented in each cluster. 

  - **Selection of differentially expressed gene:** ANOVA is used to get each gene a p value 
    for its differential expression across sample groups and false discovery rates are calculated      using the p values. Afterwards, genes are filtered sequentially by their FDR, p value, and         range until the number of remaining genes is smaller than a given minimal number.
  - **Gene clustering analysis:** Remaining genes from the last step are used as seeds for the         _hclust{stat}_ function to generate a hierchical clustering tree; the tree is cut at a given       height to get initial clusters; the cutting height will be lowered if the number of clusters is     less than the number of sample groups; the initial clusters are filtered to remove small           clusters, and refined to remove outlier genes; initial clusters close to each other are merged;     and finally, the clusters are refined through multiple rounds of re-clustering while including     genes with less significant ANOVA p values. 
  - **Gene set enrichment analysis:** Hypergeometric test is used to find predefined gene sets         over-represented in each gene cluster. A collection of gene sets obtained from                     different sources are available for a few model species and can be found at             
    https://github.com/zhezhangsh/RoCA/tree/master/data.
    
</div>

&nbsp;

```{r global_setup, eval=TRUE, include=FALSE}
name.yaml <- 'cluster_gene.yaml'; 
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'gplots', 'rchive', 'RoCA', 'awsomics'); 
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table', 'path.cl'='cluster'); 

## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));

## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
  if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
    yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template

prms <- yml$parameter;

## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]); 

## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
```

```{r load_data, include=FALSE}
# Load input data
expr<-ImportTable(DownloadFile(yml$input$data, path.input)); 
anno<-ImportTable(DownloadFile(yml$input$annotation, path.input)); 
smpl<-ImportTable(DownloadFile(yml$input$sample, path.input)); 
gset<-ImportR(DownloadFile(yml$input$geneset, path.input)); 

saveRDS(expr, file=paste(path.input, TrimPath(yml$input$data), sep='/')); 
saveRDS(anno, file=paste(path.input, TrimPath(yml$input$annotation), sep='/')); 
saveRDS(smpl, file=paste(path.input, TrimPath(yml$input$sample), sep='/')); 
saveRDS(gset, file=paste(path.input, TrimPath(yml$input$geneset), sep='/')); 

anno<-anno[rownames(anno) %in% rownames(expr), , drop=FALSE]; 
smpl<-smpl[rownames(smpl) %in% colnames(expr), , drop=FALSE];
if (nrow(anno) <= 1) stop("Not enough genes to perform clustering.\n");
if (nrow(smpl) <= 1) stop("Not enough samples to perform clustering.\n");
expr0<-expr<-expr[rownames(anno), rownames(smpl)];  # Original matrix

phen <- setdiff(prms$term, names(smpl));
if (length(phen) > 0) stop("Sample phenotype(s): ", paste(phen, collapse=';'), ' not available.\n');
phen <- sapply(prms$term, function(x) as.vector(smpl[, x])); 
phen <- apply(phen, 1, function(x) paste(x, collapse='_')); 

if (prms$normalization$method == 2) {
  ind<-which(smpl[, prms$normalization$control$column]==prms$normalization$control$name);
  if (length(ind)==0) stop('Error: no samples belong to control group "', prms$normalization$control$name,  '".\n')
  expr<-t(apply(expr0, 1, function(x) (x-mean(x[ind]))/sd(x))); 
} else if (prms$normalization$method == 1) expr<-t(scale(t(expr))) else expr<-expr0; 

CreateDatatable(smpl, paste(path.tbl, 'sample.html', sep='/'));
```

`r home.url`

# Description

`r WriteDescription(yml$description)`

`r home.url`

## Data and samples

```{r normalization, include=FALSE}
if (prms$normalization$method == 2) ln<-paste('The input data matrix was normalized using sample group _', prms$normalization$control$name, '_ as control, so, the data of each gene was substracted by control group mean and had SD equal to 1.0', sep='') else if (prms$normalization$method == 1) ln<-paste('The input data matrix was normalized so each gene had mean of 0 and SD of 1.0') else 
  ln<-'It was presumed that the input data matrix had been properly processed for this analysis, so no further normalization was done'
```

  - There are `r nrow(expr)` total genes
  - There are `r ncol(expr)` total [samples](table/sample.html)
  - There are `r unique(smpl[, prms$term[1]])` sample groups

`r ln`

<div align='center'>
```{r pca, include=TRUE, fig.width=6, fig.height=6, out.width='640px'}
col<-rainbow(length(unique(phen)));
names(col)<-unique(phen); 
c<-col[phen]; 
PlotPCA(prcomp(t(expr0)), smpl[, prms$term[1]], new.window = FALSE, col=c)->x;
legend(x='topright', legend=names(col), text.col=col, bty='n', cex=.5); 
```
</div>

<div style="color:darkblue; padding:0 3cm">
**Figure 1.** Principal components analysis (PCA) using all genes. Samples were colored by their groups. 
</div>

`r home.url`

# Analysis and results

## Gene-level summary statistics and ANOVA

```{r anova, include=FALSE}
# Summary statistics and ANOVA
grp <-split(rownames(smpl), phen)[unique(phen)];
m   <-sapply(grp, function(s) rowMeans(expr0[, s, drop=FALSE])); 
mn  <-apply(expr0, 1, min);
mx  <-apply(expr0, 1, max); 
colnames(m) <- paste('Mean', colnames(m), sep='_'); 

if (length(prms$term) == 1) { # One way ANOVA
  f<-as.factor(phen); 
  dat<-data.frame(t(expr0));
  dat$Group<-f;
  formula <- as.formula(paste0("cbind(", paste(names(dat)[-length(dat)],collapse=","), ")~Group") ) 
  aov<-aov(formula, data=dat);
  p<-as.vector(sapply(summary(aov), function(x) x[1, 5])); 
  q<-p.adjust(p, method='BH');
  stat<-cbind(m, Min=mn, Max=mx, Range=mx-mn, pANOVA=p, FDR=q); 
} else {
  aov <- apply(expr0, 1, function(e) summary(aov(formula(paste('e ~ ', paste(prms$term, collapse='*'))), data=smpl)));  
  aov <- lapply(aov, function(x) x[[1]]); 
  pvs <- t(sapply(aov, function(x) x[1:(nrow(x)-1), 5])); 
  cnm <- rownames(aov[[1]]); 
  cnm <- gsub(' ', '', cnm[-length(cnm)]); 
  cnm <- gsub(':', '*', cnm);
  qvs <- apply(pvs, 2, function(p) p.adjust(p, method='BH')); 
  colnames(pvs) <- paste('pANOVA', cnm, sep='_');
  colnames(qvs) <- paste('FDR', cnm, sep='_');
  stat<-cbind(m, Min=mn, Max=mx, Range=mx-mn, pANOVA=pvs, FDR=qvs); 
}
CreateDatatable(cbind(anno, FormatNumeric(stat)), paste(path.tbl, 'anova.html', sep='/'), caption="ANOVA results")
```

Summary statistics and ANOVA p value across all sample groups were calculated for each gene.

- [Summary statistics and ANOVA result.](table/anova.html) 

<div align='center'>
```{r anova_pvalue, fig.width=8, fig.height=4.8*length(prms$term), out.width='640px'}
if (length(prms$term) == 1) {
  par(mfrow=c(1,1), mar=c(5,5,2,2));
  hist(p, br=100, xlab='ANOVA p value', ylab='Number of genes', cex.lab=2, main='');
  ln <- paste(length(p[p<prms$selection$p]), 'genes have p values less than', prms$selection$p);
} else {
  par(mfrow=c(length(prms$term), 1), mar=c(5,5,3,2)); 
  sapply(1:length(prms$term), function(i) hist(pvs[, i], br=100, xlab='ANOVA p value', ylab='Number of genes', 
                                               cex.lab=1.5, main=prms$term[i], cex.main=2)) -> x;
  n <- apply(pvs[, 1:length(prms$term)], 2, function(p) length(p[p<=prms$selection$p])); 
  ln <- paste(min(n), 'to', max(n), 'genes have p values less than', prms$selection$p);
}

```
</div>
  
<div style="color:darkblue; padding:0 3cm">
**Figure 2.** Distribution of ANOVA p values. `r ln`.
</div>
  
`r home.url`

## Identification of gene clusters

### Selection of differentially expressed genes

Differentially expressed genes (DEGs) were selected as seeds for generating gene clusters, using the following criteria:
  
  - Select genes with FDR less than `r prms$selection$fdr`
  - Stop if less than `r prms$selection$min` genes were left; otherwise, select those with ANOVA p values less than `r prms$selection$p`
  - Stop if less than `r prms$selection$min` genes were left; otherwise, select those with range (_max-min_) greater than `r prms$selection$range`
  - If there are still more than `r prms$selection$max` genes left, select the top `r prms$selection$max` with the biggest ranges

```{r selection, include=FALSE}
select.gene <- function(expr, stat, prms) {
  q <- stat[, 'FDR'];
  e <- expr[q<=prms$selection$fdr, , drop=FALSE]; 
  if (nrow(e) < prms$selection$min) {
    q0 <- sort(q); 
    e <- expr[q <= q0[min(nrow(expr), prms$selection$min)], , drop=FALSE];
  };
  if (nrow(e) > prms$selection$min) { # continue if there are more selected genes than minimum
    s<-stat[rownames(e), , drop=FALSE];
    s<-s[order(s[, 'pANOVA']), , drop=FALSE];
    e<-e[rownames(s), , drop=FALSE]; 
    e<-e[1:max(prms$selection$min, max(which(s[, 'pANOVA']<=prms$selection$p))), , drop=FALSE]; 
    
    if (nrow(e) > prms$selection$min) { # continue if there are more selected genes than minimum 
      s<-stat[rownames(e), , drop=FALSE];
      s<-s[rev(order(s[, 'Range'])), , drop=FALSE];
      e<-e[rownames(s), , drop=FALSE]; 
      e<-e[1:max(prms$selection$min, max(which(s[, 'Range']>=prms$selection$range))), , drop=FALSE]; 
    }
    
    if (nrow(e) > prms$selection$max) e<-e[1:prms$selection$max, , drop=FALSE]; # trim if more selected genes than maximum
  }
  
  e; 
}

if (length(prms$term) == 1) e <- select.gene(expr, stat, prms) else {
  es <- lapply(1:ncol(pvs), function(i) {
    ss <- cbind(Range=stat[, 'Range'], pANOVA=pvs[, i], FDR=qvs[, i]); 
    rownames(ss) <- rownames(stat); 
    select.gene(expr, ss, prms); 
  });
  ids <- Reduce('union', lapply(es, rownames)); 
  e <- expr[ids, , drop=FALSE]; 
}
```

A total of **`r nrow(e)`** genes were selected. These genes would be used as seeds to generate gene clusters in the next step.

<div align='center'>
```{r hierarchical_clustering, include=TRUE, fig.width=8, fig.height=4*min(2, ceiling(nrow(smpl)/32)), out.width='800px'}
if (nrow(smpl)>32) par(mfrow=c(2, 1), mar=c(2,2,2,2)) else par(mfrow=c(1, 2), mar=c(2,2,2,2)); 
plot(hclust(as.dist(1-cor(expr0[, colSums(abs(expr0))>0, drop=FALSE))), main='All genes', xlab='', sub='', ylab='');
plot(hclust(as.dist(1-cor(expr0[rownames(e), colSums(abs(expr0))>0, drop=FALSE]))), main='Selected DEGs', xlab='', sub='', ylab='');
```
</div>

<div style="color:darkblue; padding:0 3cm">
**Figure 3.** Hierarchical clustering of samples using all genes (unsupervised) or selected DEGs (supervised).
</div>

`r home.url`

### Idetnfication of gene clusters

Gene clusters were identified from the DEG seeds with the following steps:
  
  - Create a hierchical tree based on gene-gene correlation
  - Cut the tree at height `r prms$cluster$height`, which will classify genes into clusters. Then apply the following steps to refine the clusters
  - Calculate correlation of each gene to the centroid (median) of its cluster. Remove the genes if the correlation is less than `r prms$cluster$corr`
  - Remove clusters with size less than `r 100*prms$cluster$size`% of the expected size (the expected size is 50 if there are 500 genes and 10 clusters)
  - If there are less than `r length(grp)` (the number of sample groups) clusters left, reduce the height cutoff by 0.05 and repeat this step until there are enough clusters
  - Merge the 2 most similar clusters if the correlation of their centroids is greater than or equal to `r prms$cluster$corr`. Repeat this step until no 2 clusters are that similar

```{r cluster_seeding, include=FALSE}
h<-prms$cluster$height;
sz<-prms$cluster$size; # minimal size of a cluster, ratio against expected size (ex. if size=0.2, minimal cluster size is 0.2*500/10 when there are 500 genes and 10 clusters in total)

# Hierarchical clustering
doClust<-function(hc, h, e, corr, sz) {
  ct<-cutree(hc, h=h);
  cl<-split(names(ct), ct); 
  cl<-sapply(cl, function(c) {
    if (length(c) <= 1) c else {
      x<-e[c, , drop=FALSE]; 
      md<-apply(x, 2, median); 
      r<-as.vector(cor(md, t(x))[1, ]); # remove outliers 
      c[r>=corr]
    }
  }); 
  cl[sapply(cl, length)>=sz*nrow(e)/length(cl)];
}

hc<-hclust(as.dist(1-cor(t(e)))); 
cl<-doClust(hc, h, e, prms$cluster$corr, sz); 

# Reduce cutoff if number of clusters is less than number of groups
while(length(cl)<length(grp) & sum(sapply(cl, length))<=nrow(e)) {
  h<-h-0.05;
  cl<-doClust(hc, h, e, prms$cluster$corr, sz); 
}

# merge similar clusters
flag<-TRUE;
while(flag) {
  cat('Number of clusters ', length(cl), '\n'); 
  ms<-sapply(cl, function(cl) colMeans(expr[cl,  , drop=FALSE])); 
  tr<-cutree(hclust(as.dist(1-cor(ms))), k=length(cl)-1); # find the 2 most similar clusters
  i<-tr[duplicated(tr)];
  c<-ms[, tr==i]; 
  r<-cor(c[, 1], c[, 2]); 
  p<-cor.test(c[, 1], c[, 2])$p.value[[1]]; 
  if (r>prms$cluster$merge$corr & p<prms$cluster$merge$p) {
    cl[tr==i][[1]]<-as.vector(unlist(cl[tr==i]));
    cl<-cl[names(cl)!=names(i)]; 
  } else flag<-FALSE;
}

# Sort clusters
m<-sapply(cl, function(cl) colMeans(expr[cl,  , drop=FALSE])); 
ind<-apply(m, 2, function(x) which(x==max(x)));  
cl<-cl[order(ind)]; 
names(cl)<-paste('Cluster', 1:length(cl), sep='_'); 

# preparing for the next blocks
ms<-sapply(cl, function(cl) colMeans(expr[cl,  , drop=FALSE])); 
ms<-data.frame(t(ms));
colnames(ms)<-colnames(e); 
rownames(ms)<-paste(rownames(ms), ' (n=', sapply(cl, length),  ')', sep=''); 

sortColumn<-function(ms, g) {
  corr<-as.vector(cor(rowMeans(ms[, g[[2]], drop=FALSE]), ms[, g[[1]], drop=FALSE]));
  g[[1]]<-g[[1]][order(corr)];
  for (i in 2:length(g)) {
    corr<-as.vector(cor(rowMeans(ms[, g[[i-1]], drop=FALSE]), ms[, g[[i]], drop=FALSE]));
    g[[i]]<-g[[i]][rev(order(corr))]; 
  }
  ms[, as.vector(unlist(g))]; 
}

n<-sapply(cl, length); 
ps <- stat[, grep('pANOVA', colnames(stat)), drop=FALSE]; 
ids <- union(rownames(e), rownames(expr)[apply(ps, 1, min) <= prms$recluster$p]);
d<-expr[ids, , drop=FALSE]; 
```

**`r length(cl)`** gene clusters of **`r sum(n)`** genes were identified from **`r nrow(e)`** seed DEGs.

<div align='center'>
```{r plot_cluster_mean, include=TRUE, fig.width=CalculateColoredBlockSize(ms)[1], fig.height=CalculateColoredBlockSize(ms)[2], out.width='600px'}
x<-sortColumn(ms, grp);
PlotColoredBlock(x, min=-1*max(abs(x), na.rm=TRUE), max=max(abs(x), na.rm=TRUE), key='Average expression', groups=grp); 
```
</div>

<div style="color:darkblue; padding:0 3cm">
**Figure 4.** Color of each block corresponds to the average expression (normalized) of each initial gene cluster in each sample (red = higher).
</div>

`r home.url`

### Refinement of gene clusters

```{r cluster_refine, include=FALSE}
reCl<-function(d, cl, r, dif) {
  md<-sapply(cl, function(cl) apply(d[cl[cl %in% rownames(d)], , drop=FALSE], 2, median));
  corr<-cor(t(d), md); 
  c<-lapply(1:ncol(corr), function(i) {
    mx<-apply(corr[, -i, drop=FALSE], 1, max);
    rownames(corr)[corr[, i]>=r & (corr[, i]-mx)>dif]; 
  });
  c;
}

cls<-list(cl, reCl(d, cl, prms$recluster$r, prms$recluster$diff)); 

while (!identical(cls[[length(cls)]], cls[[length(cls)-1]]) & length(cls)<=prms$recluster$times) {
  cls[[length(cls)+1]]<-reCl(d, cls[[length(cls)]], prms$recluster$r, prms$recluster$diff); 
  cat("Reclustering #", length(cls)-1, '\n'); 
}

sz.min<-max(3, prms$cluster$size*sum(sapply(cl, length))/length(cl));
sz.fit<-sapply(cls[[length(cls)]], length)>=sz.min;
cls<-lapply(cls, function(c) c[sz.fit]); 
cl<-cls[[length(cls)]]; 
names(cl)<-paste('Cluster', 1:length(cl), sep='_'); 

# summary cluster sizes
n<-sapply(cls, function(c) sapply(c, length)); 
n<-data.frame(n); 
colnames(n)<-paste('Cycle #', 0:(ncol(n)-1), sep=''); 

ms<-sapply(cl, function(cl) colMeans(expr[cl,  , drop=FALSE])); 
ms<-data.frame(t(ms));
colnames(ms)<-colnames(expr); 
rownames(ms)<-paste(rownames(ms), ' (n=', sapply(cl, length),  ')', sep=''); 

if(identical(cls[[length(cls)]], cls[[length(cls)-1]])) ln<-paste("The reclustering converged after", length(cls)-1, 'cycles') else ln<-paste("The reclustering didn't converge after", length(cls)-1, 'cycles')
```

The gene clusters identified from the DEG seeds were further refined with the following steps: 

  - Select all `r nrow(d)` genes with p values less than `r prms$recluster$p` to continue
  - Assign selected genes to clusters:
  - Calculate centroid (median expression level of all genes in the cluster) of each cluster
  - Calculate correlation coefficient of each gene to centroid of each cluster to get a `r nrow(d)` X `r length(cl)` matrix
  - Assign a gene to a cluster if its correlation coefficient to the cluster is greater than `r prms$recluster$r`, and the correlation coefficient to any other cluster is at least `r prms$recluster$diff` less
  - Repeat this reclustering steps for `r prms$recluster$times` times unless the reclustering converged
  - Finally, remove clusters with number of genes less than `r sz.min`
  
`r ln`

A total of **`r sum(sapply(cl, length))`** genes were clustered after refinement. 

<div align='center'>
```{r plot_recluster_mean, include=TRUE, fig.width=CalculateColoredBlockSize(ms, 1, 6)[1], fig.height=CalculateColoredBlockSize(ms, 1, 6)[2], out.width='600px'}

ms<-sapply(cl, function(cl) colMeans(expr[cl,  , drop=FALSE])); 
ms<-data.frame(t(ms));
colnames(ms)<-colnames(e); 
rownames(ms)<-paste(rownames(ms), ' (n=', sapply(cl, length),  ')', sep=''); 

x<-sortColumn(ms, grp);
PlotColoredBlock(x, min=-1*max(abs(x), na.rm=TRUE), max=max(abs(x), na.rm=TRUE), key='Average expression', groups=grp);
```
</div>

<div style="color:darkblue; padding:0 3cm">
**Figure 5.** Color of each block corresponds to the average expression (normalized) of each refined gene cluster in each sample (red = higher).
</div>

```{r summary_clusters, include=FALSE}
ids<-as.vector(unlist(cl)); 
c<-rep(names(cl), sapply(cl, length)); 

tbl1<-data.frame(anno[ids, ], Cluster=c, FormatNumeric(expr[ids, ])); 
tbl2<-data.frame(anno[ids, ], Cluster=c, FormatNumeric(stat[ids, ])); 

write.csv2(tbl1, paste(path.tbl, 'clustered_data.csv', sep='/')); 
write.csv2(tbl2, paste(path.tbl, 'clustered_stat.csv', sep='/')); 

CreateDatatable(tbl1, paste(path.tbl, 'clustered_data.html', sep='/')); 
CreateDatatable(tbl2, paste(path.tbl, 'clustered_stat.html', sep='/')); 

saveRDS(tbl1, paste(path.r, 'clustered_data.rds', sep='/')); 
saveRDS(tbl2, paste(path.r, 'clustered_stat.rds', sep='/')); 
```

More info:

  - [Original data of clustered genes](table/clustered_data.html) ([download table](table/clustered_data.csv))
  - [Statistic result of clustered genes](table/clustered_stat.html) ([download table](table/clustered_stat.csv))

`r home.url`

## Analysis of individual clusters

### Summary statistics and visualization of individual clusters

```{r cluster_stats, include=FALSE}
ms<-sapply(names(cl), function(nm) { 
  mtrx<-expr[cl[[nm]], , drop=FALSE]; 
  mtrx<-sortColumn(mtrx, grp);
  
  ms<-colMeans(mtrx); 
  m<-matrix(sapply(grp, function(g) mean(ms[g])), nr=1); 
  se<-matrix(sapply(grp, function(g) sd(ms[g])/sqrt(length(g))), nr=1); 
  colnames(m)<-names(grp); 
  
  fn<-paste(path.cl, '/', nm, '.pdf', sep=''); 
  pdf(fn, w=6, h=12); 
  par(mfrow=c(3, 1)); 
  
  # Pattern of group averages
  par(mar=c(5, 5, 5, 2)); 
  PlotSeries(m, se, labs=c('', 'Average expression'), title=paste(nm, 'Group average pattern', sep=': '), draw.legend = FALSE); 
  
  # Hierarchical clustering 
  par(mar=c(2, 5, 5, 2)); 
  plot(hclust(as.dist(1-cor(mtrx[, colSums(abs(mtrx))>0, drop=FALSE]))), main='Hierarchical sample clustering', xlab='', sub=''); 
  
  # Heatmap
  rownames(mtrx)<-paste(rownames(mtrx), CleanHtmlTags(anno[rownames(mtrx), 1]), sep='_'); 
  PlotColoredBlock(mtrx, min=-1*max(abs(mtrx), na.rm=TRUE), max=max(abs(mtrx), na.rm=TRUE), num.breaks = 127, 
                   groups=grp, key='Expression level'); 
  abline(v=c(0, cumsum(sapply(grp, length))), lwd=1); 
  
  dev.off();
  
  m;
}); 

rownames(ms)<-paste('Mean', names(grp), sep='_'); 
tbl<-data.frame(Cluster=paste('[', names(cl), '](cluster/', names(cl), '.pdf)', sep=''), Num_Gene=sapply(cl, length), FormatNumeric(t(ms))); 
```

<div style="color:darkblue; padding:0 2cm">
**Table 1** Summary of individual clusters, with the average expression (normalized) of all genes of each cluster in all sample groups. Click on cluster name for visualization of each cluster: 1). the average and standard error of sample averages in each group; 2). hierarchical sample clustering using all genes of the cluster; and 3). heatmap of all genes and samples of the cluster.
</div>

<div align='center', style="padding:0 2cm">
`r kable(tbl, row.names = FALSE)`
</div>

`r home.url`

### Gene set enrichment analysis

Find predefined gene sets enriched in gene cluster comparing to the background. 

```{r gsea, include=FALSE}
gse<-lapply(names(cl), function(nm) {
  mtrx<-expr[cl[[nm]], , drop=FALSE]; 
  mtrx<-sortColumn(mtrx, grp);
  gse<-TestGSE(rownames(mtrx), rownames(expr), gset[[2]])[[1]]; 
  gse<-WrapGSE(gse, gset[[1]], paste(path.cl, nm, sep='/'), FALSE); 
  fn<-TruncatePathPrefix(gse[[3]], path);   
  sapply(names(gse[[2]]), function(nm) paste('[', nrow(gse[[2]][[nm]]), '](', fn[nm], ')', sep='')); 
});
gs<-sort(unique(unlist(lapply(gse, names), use.names=FALSE)));
tbl<-t(sapply(gse, function(gse) gse[gs]));
dimnames(tbl)<-list(names(cl), gs); 
tbl[is.na(tbl)]<-'0';
```

<div style="color:darkblue; padding:0 2cm">
**Table 2** Numbers of predefined gene sets significantly enriched in each gene cluster. Gene sets were split based on their sources, such as the NCBI BioSystems and KEGG databases. Click on each number to see list of the gene sets. 
</div>

<div align='center', style="padding:0 2cm">
`r kable(tbl, align=rep('c', ncol(tbl)))`
</div>

`r home.url`

## More plots

<div align='center'>
```{r plot_series, include=TRUE,  fig.width=8, fig.height=6, out.width='750px'}
ms<-sapply(cl, function(cl) colMeans(expr[cl,  , drop=FALSE]));
m<-sapply(grp, function(g) colMeans(ms[g, , drop=FALSE]));
se<-sapply(grp, function(g) apply(ms[g, , drop=FALSE],  2, function(x) sd(x)/sqrt(length(x)))); 
PlotSeries(m, se, c('', 'Normalized group average')); 
```
</div>

<div style="color:darkblue; padding:0 2cm">
**Figure 6.**  Plot the patterns of all clusters using the mean and standard error of samples of each group.
</div>


&nbsp;

<div align='center'>
```{r plot_means, include=TRUE, fig.width=6, fig.height=3.6, out.width='480px'}
ms<-sapply(cl, function(cl) colMeans(expr[cl,  , drop=FALSE]));
m<-sapply(grp, function(g) colMeans(ms[g, , drop=FALSE]));
colnames(m)<-names(grp);
rownames(m)<-names(cl); 
PlotColoredBlock(m, min=-1*max(abs(m), na.rm=TRUE), max=max(abs(m), na.rm=TRUE), key='Cluster average', groups=split(colnames(m), colnames(m))); 
```
</div>

<div style="color:darkblue; padding:0 3cm">
**Figure 7.**  Color represents the average expression (normalized across samples) of all genes in the same cluster and all samples in the same group (red = higher).
</div>

&nbsp;

<div align='center'>
```{r plot_group_means, include=TRUE, fig.width=8, fig.height=6, out.width='480px'}
d<-expr[unlist(cl, use.names = FALSE), , drop=FALSE];
d<-sapply(grp, function(g) rowMeans(d[, g, drop=FALSE])); 
colnames(d)<-names(grp); 
PlotColoredBlock(d, min=-1*max(abs(d), na.rm=TRUE), max=max(abs(d), na.rm=TRUE), num.breaks = 127, groups=split(colnames(d), colnames(d)), key='Group average'); 
abline(h=c(nrow(d), nrow(d)-cumsum(sapply(cl, length)), lwd=1)); 
```
</div>

<div style="color:darkblue; padding:0 3cm">
**Figure 8.**  Color represents the average expression (normalized across samples) of individual genes in all samples of the same group (red = higher).
</div>

&nbsp;

<div align='center'>
```{r plot_heatmap, include=TRUE, fig.width=8, fig.height=6, out.width='600px'}
d<-expr[unlist(cl, use.names = FALSE), , drop=FALSE];
d<-sortColumn(d, grp); 
PlotColoredBlock(d, min=-1*max(abs(d), na.rm=TRUE), max=max(abs(d), na.rm=TRUE), num.breaks = 127, groups=grp, key='Expression level'); 
abline(h=c(nrow(d), nrow(d)-cumsum(sapply(cl, length)), lwd=1)); 
abline(v=c(0, cumsum(sapply(grp, length))), lwd=1); 
```
</div>

<div style="color:darkblue; padding:0 3cm">
**Figure 9.**  Color represents the expression level (normalized across samples) of each gene and each sample (red = higher).
</div>

&nbsp;

<div align='center'>
```{r plot_recluster_size, include=TRUE, fig.width=1+0.25*ncol(n), fig.height=1+0.25*nrow(n), out.width='480px'}
rownames(n)<-paste(rownames(n), ' (n=', n[, 1], ' to ', n[, ncol(n)], ')', sep='')
PlotColoredBlock(n, key='Cluster size'); 
```
</div>

<div style="color:darkblue; padding:0 3cm">
**Figure 10.** Color represents the size of each cluster (number of genes) after a reclustering cycle.  
</div>

`r home.url`

***

# Appendix 

Check out the **[RoCA home page](http://zhezhangsh.github.io/RoCA)** for more information.  

## Reproduce this report

To reproduce this report: 

  1. Find the data analysis template you want to use and an example of its pairing YAML file  [here](https://github.com/zhezhangsh/RoCA/wiki/Templates-and-examples) and download the YAML example to your working directory

  2. To generate a new report using your own input data and parameter, edit the following items in the YAML file:

    - _output_        : where you want to put the output files
    - _home_          : the URL if you have a home page for your project
    - _analyst_       : your name
    - _description_   : background information about your project, analysis, etc.
    - _input_         : where are your input data, read instruction for preparing them
    - _parameter_     : parameters for this analysis; read instruction about how to prepare input data

  3. Run the code below within ***R Console*** or ***RStudio***, preferablly with a new R session:

```{r reproduce_report, eval=FALSE, echo=TRUE}
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

CreateReport(filename.yaml);  # filename.yaml is the YAML file you just downloaded and edited for your analysis
```

If there is no complaint, go to the _output_ folder and open the ***index.html*** file to view report. 

## Session information

```{r session_info, echo=FALSE}
sessionInfo(); 
```

`r home.url`

***
_END OF DOCUMENT_

