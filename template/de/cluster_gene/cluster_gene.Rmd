---
title: "Cluster genes across multiple sample groups"
author: "`r if (exists('yml')) yml$analyst else 'Jim Zhang'`"
date: "`r Sys.Date()`"
output:
  html_document:
    self_contained: no
    number_sections: yes
    toc: yes
    toc_float: 
      collapsed: no
---

<div style="border:black 1px solid; padding: 0.5cm 0.5cm">

**Introduction: ** This analysis performs a gene-gene clustering procedure that will identify clusters of co-expressed genes across multiple sample groups. It first runs an ANOVA to find genes significantly different across sample groups and uses these genes as seeds to initiate a set of gene clusters. These clusters will be further refined based on several user-specific paramters. Gene set enrichment analysis is then used to associate each gene cluster to pre-defined gene sets, and then biological meanings. 

  - **Selection of seed genes:** ANOVA is used to get each gene a p value for its difference across sample groups and corresponding false discovery rates are calculated using the p values. Afterwards, genes are filtered sequentially by their FDR, p value, and range until the number of seed genes is between the given upper and lower limits.
  - **Gene clustering analysis:** Seed genes from the last step are used by the _hclust{stat}_ function to generate a hierchical clustering tree; the tree is cut at a given height to obtain initial clusters; the cutting height will be lowered if the number of clusters is smaller than the number of sample groups; the initial clusters are filtered to remove outlier genes and clusters smaller than a given number; initial clusters close to each other within a given distance are merged; and finally, the clusters are refined through multiple rounds of re-clustering, which allows the inclusion of genes with less significant ANOVA p values. 
  - **Gene set enrichment analysis:** Hypergeometric test is used to find predefined gene sets over-represented in each gene cluster. A collection of gene sets obtained from different sources are available for a few model species, which can be downloaded [here](https://github.com/zhezhangsh/RoCA/tree/master/data).
    
</div>

&nbsp;

```{r global_setup, eval=TRUE, include=FALSE}
name.yaml <- 'cluster_gene.yaml'; 
name.packages <- c('rmarkdown', 'knitr', 'kableExtra', 'yaml', 'DT', 'htmlwidgets', 'gplots', 
                   'rchive', 'RoCA', 'awsomics'); 
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table', 'path.cl'='cluster'); 

## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE, fig.path = 'figure/');
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));

## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
  if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
    yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template

prms <- yml$parameter;

## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]); 

## Automatical figure/table ordering
OrderFigure(reset=TRUE);
OrderTable(reset=TRUE);

## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
```

```{r load_data, include=FALSE}
# Load input data
expr<-ImportTable(DownloadFile(yml$input$data, path.input)); 
anno<-ImportTable(DownloadFile(yml$input$annotation, path.input)); 
smpl<-ImportTable(DownloadFile(yml$input$sample, path.input)); 
gset<-ImportR(DownloadFile(yml$input$geneset, path.input)); 

saveRDS(expr, file=paste(path.input, TrimPath(yml$input$data), sep='/')); 
saveRDS(anno, file=paste(path.input, TrimPath(yml$input$annotation), sep='/')); 
saveRDS(smpl, file=paste(path.input, TrimPath(yml$input$sample), sep='/')); 
saveRDS(gset, file=paste(path.input, TrimPath(yml$input$geneset), sep='/')); 

anno<-anno[rownames(anno) %in% rownames(expr), , drop=FALSE]; 
smpl<-smpl[rownames(smpl) %in% colnames(expr), , drop=FALSE];
if (nrow(anno) <= 1) stop("Not enough genes to perform clustering.\n");
if (nrow(smpl) <= 1) stop("Not enough samples to perform clustering.\n");
expr0<-expr<-expr[rownames(anno), rownames(smpl)];  # Original matrix

phen <- setdiff(prms$term, names(smpl));
if (length(phen) > 0) stop("Sample phenotype(s): ", paste(phen, collapse=';'), ' not available.\n');
phen <- sapply(prms$term, function(x) as.vector(smpl[, x])); 
phen <- apply(phen, 1, function(x) paste(x, collapse='_')); 

if (prms$normalization$method == 2) {
  ind<-which(smpl[, prms$normalization$control$column]==prms$normalization$control$name);
  if (length(ind)==0) stop('Error: no samples belong to control group "', prms$normalization$control$name,  '".\n')
  expr<-t(apply(expr0, 1, function(x) (x-mean(x[ind]))/sd(x))); 
} else if (prms$normalization$method == 1) expr<-t(scale(t(expr))) else expr<-expr0; 

CreateDatatable(smpl, paste(path.tbl, 'sample.html', sep='/'));
```

`r home.url`

# Description {.tabset}

`r WriteDescription(yml$description)`

`r home.url`

## Data and samples

```{r normalization, include=FALSE}
if (prms$normalization$method == 2) ln<-paste('The input data matrix was normalized using sample group _', prms$normalization$control$name, '_ as control, so, the data of each gene was substracted by control group mean and had SD equal to 1.0', sep='') else if (prms$normalization$method == 1) ln<-paste('The input data matrix was normalized so each gene had mean of 0 and SD of 1.0') else 
  ln<-'It was presumed that the input data matrix had been properly processed for this analysis, so no further normalization was done'
```

  - There are **`r nrow(expr)`** total genes.
  - There are **`r ncol(expr)`** total [samples](table/sample.html).
  - There are **`r unique(smpl[, prms$term[1]])`** sample groups.

`r ln`

```{r pca, include=TRUE, fig.width=6, fig.height=6, out.width='640px'}
col <- rainbow(length(unique(phen)));
col <- sub('FF$', 'BB', col);
names(col) <- unique(phen); 
c <- col[phen]; 
PlotPCA(prcomp(t(expr0)), smpl[, prms$term[1]], new.window = FALSE, col=c)->x;
legend(x='topright', legend=names(col), text.col=col, bty='n', cex=.5); 
```

`r OrderFigure()` Principal components analysis (PCA) using all genes. Samples were colored according to their groups. 

`r home.url`

# Analysis and results

## Gene-level summary statistics and ANOVA

```{r anova, include=FALSE}
# Summary statistics and ANOVA
grp <-split(rownames(smpl), phen)[unique(phen)];
m   <-sapply(grp, function(s) rowMeans(expr0[, s, drop=FALSE])); 
mn  <-apply(expr0, 1, min);
mx  <-apply(expr0, 1, max); 
colnames(m) <- paste('Mean', colnames(m), sep='_'); 

if (length(prms$term) == 1) { # One way ANOVA
  f<-as.factor(phen); 
  dat<-data.frame(t(expr0));
  dat$Group<-f;
  formula <- as.formula(paste0("cbind(", paste(names(dat)[-length(dat)],collapse=","), ")~Group") ) 
  aov<-aov(formula, data=dat);
  p<-as.vector(sapply(summary(aov), function(x) x[1, 5])); 
  q<-p.adjust(p, method='BH');
  stat<-cbind(m, Min=mn, Max=mx, Range=mx-mn, pANOVA=p, FDR=q); 
} else {
  aov <- apply(expr0, 1, function(e) summary(aov(formula(paste('e ~ ', paste(prms$term, collapse='*'))), data=smpl)));  
  aov <- lapply(aov, function(x) x[[1]]); 
  pvs <- t(sapply(aov, function(x) x[1:(nrow(x)-1), 5])); 
  cnm <- rownames(aov[[1]]); 
  cnm <- gsub(' ', '', cnm[-length(cnm)]); 
  cnm <- gsub(':', '*', cnm);
  qvs <- apply(pvs, 2, function(p) p.adjust(p, method='BH')); 
  colnames(pvs) <- paste('pANOVA', cnm, sep='_');
  colnames(qvs) <- paste('FDR', cnm, sep='_');
  stat<-cbind(m, Min=mn, Max=mx, Range=mx-mn, pANOVA=pvs, FDR=qvs); 
}
CreateDatatable(cbind(anno, FormatNumeric(stat)), paste(path.tbl, 'anova.html', sep='/'), caption="ANOVA results")
```

[Summary statistics and ANOVA p value](table/anova.html) across all sample groups were calculated for each gene.

```{r anova_pvalue, fig.width=8, fig.height=4.8*length(prms$term), out.width='640px'}
if (length(prms$term) == 1) {
  par(mfrow=c(1,1), mar=c(5,5,2,2));
  hist(p, br=100, xlab='ANOVA p value', ylab='Number of genes', cex.lab=2, main='');
  ln <- paste(length(p[p<prms$selection$p]), 'genes have p values less than', prms$selection$p);
} else {
  par(mfrow=c(length(prms$term), 1), mar=c(5,5,3,2)); 
  sapply(1:length(prms$term), function(i) hist(pvs[, i], br=100, xlab='ANOVA p value', ylab='Number of genes', 
                                               cex.lab=1.5, main=prms$term[i], cex.main=2)) -> x;
  n <- apply(pvs[, 1:length(prms$term)], 2, function(p) length(p[p<=prms$selection$p])); 
  ln <- paste(min(n), 'to', max(n), 'genes have p values less than', prms$selection$p);
};
```

`r OrderFigure()` Distribution of ANOVA p values. `r ln`.

`r home.url`

## Creation of gene clusters

### Selection of seed genes

Significant genes were selected from ANOVA results as seeds to generate gene clusters, using the following criteria:
  
  - Select genes with FDR less than `r prms$selection$fdr`.
  - Stop if less than `r prms$selection$min` genes were left; otherwise, select those with ANOVA p values less than `r prms$selection$p`.
  - Stop if less than `r prms$selection$min` genes were left; otherwise, select those with range (_max-min_) greater than `r prms$selection$range`.
  - If there are still more than `r prms$selection$max` genes left, select the top `r prms$selection$max` with the biggest ranges.

```{r selection, include=FALSE}
select.gene <- function(expr, stat, prms) {
  q <- stat[, 'FDR'];
  e <- expr[q<=prms$selection$fdr, , drop=FALSE]; 
  if (nrow(e) < prms$selection$min) {
    q0 <- sort(q); 
    e <- expr[q <= q0[min(nrow(expr), prms$selection$min)], , drop=FALSE];
  };
  if (nrow(e) > prms$selection$min) { # continue if there are more selected genes than minimum
    s<-stat[rownames(e), , drop=FALSE];
    s<-s[order(s[, 'pANOVA']), , drop=FALSE];
    e<-e[rownames(s), , drop=FALSE]; 
    e<-e[1:max(prms$selection$min, max(which(s[, 'pANOVA']<=prms$selection$p))), , drop=FALSE]; 
    
    if (nrow(e) > prms$selection$min) { # continue if there are more selected genes than minimum 
      s<-stat[rownames(e), , drop=FALSE];
      s<-s[rev(order(s[, 'Range'])), , drop=FALSE];
      e<-e[rownames(s), , drop=FALSE]; 
      e<-e[1:max(prms$selection$min, max(which(s[, 'Range']>=prms$selection$range))), , drop=FALSE]; 
    }
    
    if (nrow(e) > prms$selection$max) e<-e[1:prms$selection$max, , drop=FALSE]; # trim if more selected genes than maximum
  }
  
  e; 
}

if (length(prms$term) == 1) e <- select.gene(expr, stat, prms) else {
  es <- lapply(1:ncol(pvs), function(i) {
    ss <- cbind(Range=stat[, 'Range'], pANOVA=pvs[, i], FDR=qvs[, i]); 
    rownames(ss) <- rownames(stat); 
    select.gene(expr, ss, prms); 
  });
  ids <- Reduce('union', lapply(es, rownames)); 
  e <- expr[ids, , drop=FALSE]; 
}
```

Finnally, a total of **`r nrow(e)`** genes were selected as seeds for gene clustering in the next step.

```{r hierarchical_clustering, include=TRUE, fig.width=8, fig.height=4*min(2, ceiling(nrow(smpl)/32)), out.width='800px'}
if (nrow(smpl)>32) par(mfrow=c(2, 1), mar=c(2,2,2,2)) else par(mfrow=c(1, 2), mar=c(2,2,2,2)); 
plot(hclust(as.dist(1-cor(expr0[, colSums(abs(expr0))>0, drop=FALSE]))), main='All genes', xlab='', sub='', ylab='');
plot(hclust(as.dist(1-cor(expr0[rownames(e), colSums(abs(expr0))>0, drop=FALSE]))), main='Selected DEGs', xlab='', sub='', ylab='');
```

`r OrderFigure()` Hierarchical clustering of samples using all genes (unsupervised) or selected DEGs (supervised).

`r home.url`

### Initiation of gene clusters

Gene clusters were created using the seed genes with the following steps:
  
  - Create a hierchical tree based on gene-gene correlation.
  - Cut the tree at height `r prms$cluster$height`, and put genes of the same branch into the same cluster. 
  - Calculate correlation of each gene to the centroid (median) of its cluster. Remove the genes if the correlation is less than `r prms$cluster$corr`.
  - Remove clusters with size less than `r 100*prms$cluster$size`% of the expected size (the expected size is M/N if there are M genes and N clusters).
  - If there are less than `r length(grp)` (the number of sample groups) clusters left, reduce the height cutoff by 0.05 and repeat the last 3 steps until there are enough clusters.
  - Merge the 2 most similar clusters if the correlation of their centroids is greater than or equal to `r prms$cluster$corr`. Repeat this step until no 2 clusters are that similar.

```{r cluster_seeding, include=FALSE}
h<-prms$cluster$height;
sz<-prms$cluster$size; # minimal size of a cluster, ratio against expected size (ex. if size=0.2, minimal cluster size is 0.2*500/10 when there are 500 genes and 10 clusters in total)

# Hierarchical clustering
doClust<-function(hc, h, e, corr, sz) {
  ct<-cutree(hc, h=h);
  cl<-split(names(ct), ct); 
  cl<-sapply(cl, function(c) {
    if (length(c) <= 1) c else {
      x<-e[c, , drop=FALSE]; 
      md<-apply(x, 2, median); 
      r<-as.vector(cor(md, t(x))[1, ]); # remove outliers 
      c[r>=corr]
    }
  }); 
  cl[sapply(cl, length)>=sz*nrow(e)/length(cl)];
}

hc<-hclust(as.dist(1-cor(t(e)))); 
cl<-doClust(hc, h, e, prms$cluster$corr, sz); 

# Reduce cutoff if number of clusters is less than number of groups
while(length(cl)<length(grp) & sum(sapply(cl, length))<=nrow(e)) {
  h<-h-0.05;
  cl<-doClust(hc, h, e, prms$cluster$corr, sz); 
}

# merge similar clusters
flag<-TRUE;
while(flag) {
  cat('Number of clusters ', length(cl), '\n'); 
  ms<-sapply(cl, function(cl) colMeans(expr[cl,  , drop=FALSE])); 
  tr<-cutree(hclust(as.dist(1-cor(ms))), k=length(cl)-1); # find the 2 most similar clusters
  i<-tr[duplicated(tr)];
  c<-ms[, tr==i]; 
  r<-cor(c[, 1], c[, 2]); 
  p<-cor.test(c[, 1], c[, 2])$p.value[[1]]; 
  if (r>prms$cluster$merge$corr & p<prms$cluster$merge$p) {
    cl[tr==i][[1]]<-as.vector(unlist(cl[tr==i]));
    cl<-cl[names(cl)!=names(i)]; 
  } else flag<-FALSE;
}

# Sort clusters
m<-sapply(cl, function(cl) colMeans(expr[cl,  , drop=FALSE])); 
ind<-apply(m, 2, function(x) which(x==max(x))[1]);  
cl<-cl[order(ind)]; 
names(cl)<-paste('Cluster', 1:length(cl), sep='_'); 

# preparing for the next blocks
ms<-sapply(cl, function(cl) colMeans(expr[cl,  , drop=FALSE])); 
ms<-data.frame(t(ms));
colnames(ms)<-colnames(e); 
rownames(ms)<-paste(rownames(ms), ' (n=', sapply(cl, length),  ')', sep=''); 

sortColumn<-function(ms, g) {
  corr<-as.vector(cor(rowMeans(ms[, g[[2]], drop=FALSE]), ms[, g[[1]], drop=FALSE]));
  g[[1]]<-g[[1]][order(corr)];
  for (i in 2:length(g)) {
    corr<-as.vector(cor(rowMeans(ms[, g[[i-1]], drop=FALSE]), ms[, g[[i]], drop=FALSE]));
    g[[i]]<-g[[i]][rev(order(corr))]; 
  }
  ms[, as.vector(unlist(g))]; 
}

n<-sapply(cl, length); 
ps <- stat[, grep('pANOVA', colnames(stat)), drop=FALSE]; 
ids <- union(rownames(e), rownames(expr)[apply(ps, 1, min) <= prms$recluster$p]);
d<-expr[ids, , drop=FALSE]; 
```

These steps clustered **`r sum(n)`** of **`r nrow(e)`** seed genes into **`r length(cl)`** initial clusters.

```{r plot_cluster_mean, include=TRUE, fig.width=CalculateColoredBlockSize(ms)[1], fig.height=CalculateColoredBlockSize(ms)[2], out.width='600px'}
x<-sortColumn(ms, grp);
PlotColoredBlock(x, min=-1*max(abs(x), na.rm=TRUE), max=max(abs(x), na.rm=TRUE), key='Average expression', groups=grp); 
```

`r OrderFigure()` Color of each block corresponds to the average expression (normalized) of each initial gene cluster in each sample (red = higher).

`r home.url`

### Refinement of gene clusters

```{r cluster_refine, include=FALSE}
reCl<-function(d, cl, r, dif) {
  md<-sapply(cl, function(cl) apply(d[cl[cl %in% rownames(d)], , drop=FALSE], 2, median));
  corr<-cor(t(d), md); 
  c<-lapply(1:ncol(corr), function(i) {
    mx<-apply(corr[, -i, drop=FALSE], 1, max);
    rownames(corr)[corr[, i]>=r & (corr[, i]-mx)>dif]; 
  });
  c;
}

cls<-list(cl, reCl(d, cl, prms$recluster$r, prms$recluster$diff)); 

while (!identical(cls[[length(cls)]], cls[[length(cls)-1]]) & length(cls)<=prms$recluster$times) {
  cls[[length(cls)+1]]<-reCl(d, cls[[length(cls)]], prms$recluster$r, prms$recluster$diff); 
  cat("Reclustering #", length(cls)-1, '\n'); 
}

sz.min<-max(3, prms$cluster$size*sum(sapply(cl, length))/length(cl));
sz.fit<-sapply(cls[[length(cls)]], length)>=sz.min;
cls<-lapply(cls, function(c) c[sz.fit]); 
cl<-cls[[length(cls)]]; 
names(cl)<-paste('Cluster', 1:length(cl), sep='_'); 

# summary cluster sizes
n<-sapply(cls, function(c) sapply(c, length)); 
n<-data.frame(n); 
colnames(n)<-paste('Cycle #', 0:(ncol(n)-1), sep=''); 

ms<-sapply(cl, function(cl) colMeans(expr[cl,  , drop=FALSE])); 
ms<-data.frame(t(ms));
colnames(ms)<-colnames(expr); 
rownames(ms)<-paste(rownames(ms), ' (n=', sapply(cl, length),  ')', sep=''); 

if(identical(cls[[length(cls)]], cls[[length(cls)-1]])) ln<-paste("The reclustering converged after", length(cls)-1, 'cycles') else ln<-paste("The reclustering didn't converge after", length(cls)-1, 'cycles')
```

The gene clusters were further refined with the following steps: 

  - Select all `r nrow(d)` genes with p values less than `r prms$recluster$p`, and assign each of them to existing clusters:
    - Calculate the centroid (median expression level of all genes in the cluster) of each cluster
    - Calculate correlation coefficient of each gene to the centroid of each cluster to get a `r nrow(d)` X `r length(cl)` matrix
    - Assign each selected gene to a cluster if its correlation coefficient to the cluster centroid is greater than `r prms$recluster$r`, and the correlation coefficient to the centroid of any other cluster is no more than `r prms$recluster$r - prms$recluster$diff`.
  - Repeat the last step for `r prms$recluster$times` times unless it will not change the clusters any more.
  - Finally, remove clusters with number of genes less than `r sz.min`.
  
`r ln`

These steps clustered **`r sum(sapply(cl, length))`** of **`r nrow(d)`** selected genes into **`r length(cl)`** refined clusters.

```{r plot_recluster_mean, include=TRUE, fig.width=CalculateColoredBlockSize(ms, 1, 6)[1], fig.height=CalculateColoredBlockSize(ms, 1, 6)[2], out.width='600px'}

ms<-sapply(cl, function(cl) colMeans(expr[cl,  , drop=FALSE])); 
ms<-data.frame(t(ms));
colnames(ms)<-colnames(e); 
rownames(ms)<-paste(rownames(ms), ' (n=', sapply(cl, length),  ')', sep=''); 

x<-sortColumn(ms, grp);
PlotColoredBlock(x, min=-1*max(abs(x), na.rm=TRUE), max=max(abs(x), na.rm=TRUE), key='Average expression', groups=grp);
```
`r OrderFigure()` Color of each block corresponds to the average expression (normalized) of each refined gene cluster in each sample (red = higher).

```{r summary_clusters, include=FALSE}
ids<-as.vector(unlist(cl)); 
c<-rep(names(cl), sapply(cl, length)); 

a <- anno[ids, , drop=FALSE];
for (i in 1:ncol(a)) a[[i]] <- CleanHtmlTags(a[[i]], FALSE); 

tbl1<-data.frame(a, Cluster=c, FormatNumeric(expr[ids, ])); 
tbl2<-data.frame(a, Cluster=c, FormatNumeric(stat[ids, ])); 

write.csv2(tbl1, paste(path.tbl, 'clustered_data.csv', sep='/')); 
write.csv2(tbl2, paste(path.tbl, 'clustered_stat.csv', sep='/')); 

CreateDatatable(tbl1, paste(path.tbl, 'clustered_data.html', sep='/')); 
CreateDatatable(tbl2, paste(path.tbl, 'clustered_stat.html', sep='/')); 

saveRDS(tbl1, paste(path.r, 'clustered_data.rds', sep='/')); 
saveRDS(tbl2, paste(path.r, 'clustered_stat.rds', sep='/')); 
```

More info:

  - [Original data of clustered genes](table/clustered_data.html) ([download table](table/clustered_data.csv))
  - [Statistic result of clustered genes](table/clustered_stat.html) ([download table](table/clustered_stat.csv))

`r home.url`

## Analysis of clusters

Clusters created by the last section were further analyzed.

### Summary statistics and visualization of individual clusters

```{r cluster_stats, include=FALSE}
ms<-sapply(names(cl), function(nm) { 
  mtrx<-expr[cl[[nm]], , drop=FALSE]; 
  mtrx<-sortColumn(mtrx, grp);
  
  ms<-colMeans(mtrx); 
  m<-matrix(sapply(grp, function(g) mean(ms[g])), nr=1); 
  se<-matrix(sapply(grp, function(g) sd(ms[g])/sqrt(length(g))), nr=1); 
  colnames(m)<-names(grp); 
  
  fn<-paste(path.cl, '/', nm, '.pdf', sep=''); 
  pdf(fn, w=6, h=12); 
  par(mfrow=c(3, 1)); 
  
  # Pattern of group averages
  par(mar=c(5, 5, 5, 2)); 
  PlotSeries(m, se, labs=c('', 'Average expression'), title=paste(nm, 'Group average pattern', sep=': '), draw.legend = FALSE); 
  
  # Hierarchical clustering 
  par(mar=c(2, 5, 5, 2)); 
  plot(hclust(as.dist(1-cor(mtrx[, colSums(abs(mtrx))>0, drop=FALSE]))), main='Hierarchical sample clustering', xlab='', sub=''); 
  
  # Heatmap
  rownames(mtrx)<-paste(rownames(mtrx), CleanHtmlTags(anno[rownames(mtrx), 1]), sep='_'); 
  PlotColoredBlock(mtrx, min=-1*max(abs(mtrx), na.rm=TRUE), max=max(abs(mtrx), na.rm=TRUE), num.breaks = 127, 
                   groups=grp, key='Expression level'); 
  abline(v=c(0, cumsum(sapply(grp, length))), lwd=1); 
  
  dev.off();
  
  m;
}); 

rownames(ms) <- paste('Mean', names(grp), sep='_'); 
tbl<-data.frame(Cluster=paste('[', names(cl), '](cluster/', names(cl), '.pdf)', sep=''), Num_Gene=sapply(cl, length),
                FormatNumeric(t(ms))); 
rownames(tbl) <- NULL;
```

`r OrderTable()` Summary of individual clusters, with the normalized averages of all genes in each cluster and sample group. Click the name of a cluster to view more details about it:

  - the average and standard error of samples in each group; 
  - hierarchical sample clustering using all genes in the cluster; 
  - and heatmap of all genes and samples in the cluster.

`r kable(tbl) %>% kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE)`

`r home.url`

### Gene set analysis

Test over-representation of predefined gene sets in each cluster, while using all input genes as background. 

```{r gse, include=FALSE}
gse<-lapply(names(cl), function(nm) {
  mtrx<-expr[cl[[nm]], , drop=FALSE]; 
  mtrx<-sortColumn(mtrx, grp);
  gse<-TestGSE(rownames(mtrx), rownames(expr), gset[[2]])[[1]]; 
  gse<-WrapGSE(gse, gset[[1]], paste(path.cl, nm, sep='/'), FALSE); 
  fn<-TruncatePathPrefix(gse[[3]], path);   
  sapply(names(gse[[2]]), function(nm) paste('[', nrow(gse[[2]][[nm]]), '](', fn[nm], ')', sep='')); 
});
gs<-sort(unique(unlist(lapply(gse, names), use.names=FALSE)));
tbl<-t(sapply(gse, function(gse) gse[gs]));
dimnames(tbl)<-list(names(cl), gs); 
tbl[is.na(tbl)]<-'0';
```

`r OrderTable()` Numbers of predefined gene sets significantly enriched in each gene cluster. Gene sets were split based on their sources, such as the NCBI BioSystems and KEGG databases. Click on each number to see full list of the gene sets. 

`r kable(tbl, align=rep('c', ncol(tbl))) %>% kable_styling(
bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE)`

`r home.url`

## More plots

```{r plot_series, include=TRUE,  fig.width=8, fig.height=6, out.width='750px'}
ms<-sapply(cl, function(cl) colMeans(expr[cl,  , drop=FALSE]));
m<-sapply(grp, function(g) colMeans(ms[g, , drop=FALSE]));
se<-sapply(grp, function(g) apply(ms[g, , drop=FALSE],  2, function(x) sd(x)/sqrt(length(x)))); 
PlotSeries(m, se, c('', 'Normalized group average')); 
```

`r OrderFigure()` Plot the patterns of all clusters using the mean and standard error of samples of each group.


&nbsp;

```{r plot_means, include=TRUE, fig.width=6, fig.height=3.6, out.width='480px'}
ms<-sapply(cl, function(cl) colMeans(expr[cl,  , drop=FALSE]));
m<-sapply(grp, function(g) colMeans(ms[g, , drop=FALSE]));
colnames(m)<-names(grp);
rownames(m)<-names(cl); 
PlotColoredBlock(m, min=-1*max(abs(m), na.rm=TRUE), max=max(abs(m), na.rm=TRUE), key='Cluster average', groups=split(colnames(m), colnames(m))); 
```

`r OrderFigure()`  Color represents the average expression (normalized across samples) of all genes in the same cluster and all samples in the same group (red = higher).

&nbsp;

```{r plot_group_means, include=TRUE, fig.width=8, fig.height=6, out.width='480px'}
d<-expr[unlist(cl, use.names = FALSE), , drop=FALSE];
d<-sapply(grp, function(g) rowMeans(d[, g, drop=FALSE])); 
colnames(d)<-names(grp); 
PlotColoredBlock(d, min=-1*max(abs(d), na.rm=TRUE), max=max(abs(d), na.rm=TRUE), num.breaks = 127, groups=split(colnames(d), colnames(d)), key='Group average'); 
abline(h=c(nrow(d), nrow(d)-cumsum(sapply(cl, length)), lwd=1)); 
```

`r OrderFigure()`  Color represents the average expression (normalized across samples) of individual genes in all samples of the same group (red = higher).

&nbsp;

```{r plot_heatmap, include=TRUE, fig.width=8, fig.height=6, out.width='600px'}
d<-expr[unlist(cl, use.names = FALSE), , drop=FALSE];
d<-sortColumn(d, grp); 
PlotColoredBlock(d, min=-1*max(abs(d), na.rm=TRUE), max=max(abs(d), na.rm=TRUE), num.breaks = 127, groups=grp, key='Expression level'); 
abline(h=c(nrow(d), nrow(d)-cumsum(sapply(cl, length)), lwd=1)); 
abline(v=c(0, cumsum(sapply(grp, length))), lwd=1); 
```

`r OrderFigure()`  Color represents the expression level (normalized across samples) of each gene and each sample (red = higher).

&nbsp;

```{r plot_recluster_size, include=TRUE, fig.width=1+0.25*ncol(n), fig.height=1+0.25*nrow(n), out.width='480px'}
rownames(n)<-paste(rownames(n), ' (n=', n[, 1], ' to ', n[, ncol(n)], ')', sep='')
PlotColoredBlock(n, key='Cluster size'); 
```

`r OrderFigure()` Color represents the size of each cluster (number of genes) after a reclustering cycle.  

`r home.url`

***

# Appendix 

Check out the **[RoCA home page](http://zhezhangsh.github.io/RoCA)** for more information.  

## Reproduce this report

To reproduce this report: 

  1. Find the data analysis template you want to use and an example of its pairing YAML file  [here](https://github.com/zhezhangsh/RoCA/wiki/Templates-and-examples) and download the YAML example to your working directory

  2. To generate a new report using your own input data and parameter, edit the following items in the YAML file:

    - _output_        : where you want to put the output files
    - _home_          : the URL if you have a home page for your project
    - _analyst_       : your name
    - _description_   : background information about your project, analysis, etc.
    - _input_         : where are your input data, read instruction for preparing them
    - _parameter_     : parameters for this analysis; read instruction about how to prepare input data

  3. Run the code below within ***R Console*** or ***RStudio***, preferablly with a new R session:

```{r reproduce_report, eval=FALSE, echo=TRUE}
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

CreateReport(filename.yaml);  # filename.yaml is the YAML file you just downloaded and edited for your analysis
```

If there is no complaint, go to the _output_ folder and open the ***index.html*** file to view report. 

## Session information

```{r session_info, echo=FALSE}
sessionInfo(); 
```

`r home.url`

***
_END OF DOCUMENT_

