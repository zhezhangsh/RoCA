v;
});
n
n[1,1]
n<-sapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
v[as.integer(names(s))]<-s;
as.vector(v);
});
n
n1[1,]
n[1,1]
o<-op[1]
i<-which(val==o);
i
s<-sapply(split(len[i], ind[i]), sum);
s
v[as.integer(names(s))]<-s;
v
n<-sapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
v[as.integer(names(s))]<-s;
as.vector(v);
});
class(n)
n[1,1]
n[1, ]
val
len
v
n<-lapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
v[as.integer(names(s))]<-s;
as.vector(v);
});
n
n[[1]]
n[[2]]
o<-op[2]
o
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
v[as.integer(names(s))]<-s;
s
v
v<-rep(0, length(cigar));
v
s
length(s)
v<-rep(0, length(cigar));
n<-lapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
if (length(s)>0) v[as.integer(names(s))]<-s;
v
});
n
n<-sapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
if (length(s)>0) v[as.integer(names(s))]<-s;
v
});
n
n[1,1]
n[1, ]
n[2, ]
class(n)
n[, 1]
i
devtools::install_github("zhezhangsh/DEGandMore");
devtools::install_github("zhezhangsh/RoCA");
devtools::install_github("zhezhangsh/RoCA");
devtools::install_github("zhezhangsh/CHOPseq");
devtools::install_github("zhezhangsh/CHOPseq");
devtools::install_github("zhezhangsh/Rnaseq");
devtools::install_github("zhezhangsh/awsomics");
devtools::install_github("zhezhangsh/rchive");
devtools::install_github("zhezhangsh/GtUtility");
library(RoCA)
CreateReport('~/Desktop/sample_normal.yml')
download.file('https://raw.githubusercontent.com/zhezhangsh/RoCA/master/template/demo/sample_normal/sample_normal.yml', 'sample_normal.yml')
dir()
RoCA::CreateReport('sample_normal.yml')
RoCA::CreateReport('sample_normal.yml')
if (is.null(names(exon))) names(exon)<-1:length(exon);
prop.test(0, 1700, 0.002)
relist
?relist
rm(list=ls())
ls()
.libPaths()
library("RoCA", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
InstallDependency()
InstallDependency
detach("package:RoCA", unload=TRUE)
library("RoCA", lib.loc="~/Library/R/3.2/library")
InstallDependency
detach("package:RoCA", unload=TRUE)
InstallDependency(TRUE)
library("RoCA", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
InstallDependency(TRUE)
detach("package:RoCA", unload=TRUE)
library("RoCA", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
?readGAlignments
library(GenomicAlignments)
?readGAlignments
bamfile <- system.file("extdata", "ex1.bam", package="Rsamtools",
mustWork=TRUE)
gal1 <- readGAlignments(bamfile)
gal1
names(gal1)
library(GenomicAlignments)
galp1 <- readGAlignmentPairs(bamfile)
head(galp1)
names(galp1)
---
param <- ScanBamParam(flag=scanBamFlag(isProperPair=TRUE,
isDuplicate=FALSE,
isSecondaryAlignment=FALSE))
galp2 <- readGAlignmentPairs(bamfile, use.names=TRUE, param=param)
galp2
head(galp2)
head(names(galp2))
param <- ScanBamParam(tag=c("MF", "Aq", "NM", "UQ", "H0", "H1"),
what=c('flag', 'mapq', 'cigar', "isize")
)
galp2 <- readGAlignmentPairs(bamfile, use.names=TRUE, param=param)
galp2
param <- ScanBamParam(tag=c("MF", "Aq", "NM", "UQ", "H0", "H1"),
what='cigar')
galp2 <- readGAlignmentPairs(bamfile, use.names=TRUE, param=param)
galp2
x<-galp2
str(x)
class(x$first)
class(x@first)
class(x@second)
class(x@last)
class(x)
a<-x@first
a
param <- ScanBamParam(
what=c('flag', 'mapq', 'cigar', "isize")
)
x <- readGAlignmentPairs(bamfile, use.names=TRUE, param=param)
a<-x@first
a
a$flag
a@flag
a[, 'flag']
b<- elementMetadata(a)
b
table(b[, 1])
x <- readGAlignmentPairs(bamfile, use.names=TRUE)
a<-x@first
a
a@cigar
a
x
countOverlaps(x, a)
countOverlaps(x, a)->y
length(x)
length(y)
table(y)
str(a)
seqlengths(a)
seqlengths(x)
install.packages('servr')
getwd()
library(devtools)
?install_github
install_github('zhezhangsh/RoCA/R', quick=TRUE)
library(RoCA)
setwd('~/Documents/RoCA/template/qc/summarize_fastqc/')
CreateReport('summarize_fastqc.yaml')
setwd('../../de/cluster_gene/')
CreateReport('cluster_gene.yaml')
CreateReport('cluster_gene.yaml')
getwd()
dir()
x<-readRDS('exp')
x<-readRDS('examples/circadian_rhythm/input/sample_wt.rds')
x
dim(x)
rm(list=ls())
rm(list=ls())
CreateReport('cluster_gene.yaml')
source('~/.active-rstudio-document', echo=TRUE)
dim(expr0)
smpl
dim(smpl)
smpl[, prms$term[1]]
smpl[, prms$term[1]]
# Summary statistics and ANOVA
grp<-split(rownames(smpl), phen)[unique(phen)];
m<-sapply(grp, function(s) rowMeans(expr0[, s, drop=FALSE]));
mn<-apply(expr, 1, min);
mx<-apply(expr, 1, max);
f<-as.factor(phen);
dat<-data.frame(t(expr));
dat$Group<-f;
formula = as.formula(paste0("cbind(", paste(names(dat)[-length(dat)],collapse=","), ")~Group") )
aov<-aov(formula, data=dat);
p<-as.vector(sapply(summary(aov), function(x) x[1, 5]));
q<-p.adjust(p, method='BH');
stat<-cbind(m, Min=mn, Max=mx, Range=mx-mn, pANOVA=p, FDR=q);
CreateDatatable(cbind(anno, FormatNumeric(stat)), paste(path.tbl, 'anova.html', sep='/'), caption="ANOVA results")
f
dat$Group
formula
dim(dat)
dat[, ncol(dat)]
f<-as.factor(phen);
dat<-data.frame(t(expr));
dat$Group<-f;
formula = as.formula(paste0("cbind(", paste(names(dat)[-length(dat)],collapse=","), ")~Group") )
f
phen
class(phen)
formula = as.formula(paste0("cbind(", paste(names(dat)[-length(dat)],collapse=","), ")~Group") )
aov<-aov(formula, data=dat);
dat<-data.frame(t(expr));
dat$Group<-f;
dat$Group<-paste('f', f, sep='');
data$Group
f<-paste('f', f, sep='')
f
f<-as.factor(f)
f
data$Group<-f
dat<-data.frame(t(expr));
dat$Group<-f;
dat$Group
formula = as.formula(paste0("cbind(", paste(names(dat)[-length(dat)],collapse=","), ")~Group") )
aov<-aov(formula, data=dat);
dim(Expr)
dim(expr)
dat<-data.frame(t(expr[1:10, ]));
dat$Group<-f;
formula = as.formula(paste0("cbind(", paste(names(dat)[-length(dat)],collapse=","), ")~Group") )
aov<-aov(formula, data=dat);
aov<-apply(expr, 1, function(e) summary(aov(e~f))[[1]]);
dim(expr)
f
length(f)
f<-as.factor(phen);
f
aov(expr[1, ]~f)
f
length(f)
dim(expr)
expr[1, ]
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
require(gplots);
require(knitr);
require(rmarkdown);
require(yaml);
require(RCurl);
require(awsomics);
require(rchive);
if (!exists('yml'))                               # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
if (file.exists('cluster_gene.yaml'))           # assume the pairing YAML file exists in the current folder with the same name
yml<-yaml.load_file('cluster_gene.yaml');
# All run-specific parameters
prms<-yml$parameter;
# folder and subfolders of output files
f <- GenerateFolder(yml$output, c('input', 'R', 'figure', 'table', 'cluster'));
path <- yml$output;
path.r <- f['R'];
path.cl <- f['cluster'];
path.tbl <- f['table'];
path.fig <- f['figure'];
path.input <- f['input'];
# Load input data
expr<-ImportTable(DownloadFile(yml$input$data, path.input));
anno<-ImportTable(DownloadFile(yml$input$annotation, path.input));
smpl<-ImportTable(DownloadFile(yml$input$sample, path.input));
gset<-ImportR(DownloadFile(yml$input$geneset, path.input));
saveRDS(expr, file=paste(path.input, TrimPath(yml$input$data), sep='/'));
saveRDS(anno, file=paste(path.input, TrimPath(yml$input$annotation), sep='/'));
saveRDS(smpl, file=paste(path.input, TrimPath(yml$input$sample), sep='/'));
saveRDS(gset, file=paste(path.input, TrimPath(yml$input$geneset), sep='/'));
anno<-anno[rownames(anno) %in% rownames(expr), , drop=FALSE];
smpl<-smpl[rownames(smpl) %in% colnames(expr), , drop=FALSE];
if (nrow(anno) <= 1) stop("Not enough genes to perform clustering.\n");
if (nrow(smpl) <= 1) stop("Not enough samples to perform clustering.\n");
expr0<-expr[rownames(anno), rownames(smpl)];
phen<-smpl[, prms$term[1]];
if (prms$normalization$method == 2) {
ind<-which(smpl[, prms$term[1]]==prms$normalization$control);
expr<-t(apply(expr0, 1, function(x) (x-mean(x[ind]))/sd(x)));
} else if (prms$normalization$method == 1) expr<-t(scale(t(expr))) else expr<-expr0;
CreateDatatable(smpl, paste(path.tbl, 'sample.html', sep='/'));
# URL to project home
home.url <- Link2Home(yml$home);
# Description of this analysis
lns<-lapply(names(yml$description), function(nm) {
c(paste('##', nm), '\n', yml$description[[nm]], '\n');
});
lns<-paste(do.call('c', lns), collapse='\n');
dim(Expr)
dim(expr)
expr[1, ]
expr<-ImportTable(DownloadFile(yml$input$data, path.input));
expr[1, ]
mean(expr[1, ])
sd(expr[1, ])
expr<-ImportTable(DownloadFile(yml$input$data, path.input));
dim(expr)
mean(expr[1, ])
mean(expr0[1, ])
if (prms$normalization$method == 2) {
ind<-which(smpl[, prms$term[1]]==prms$normalization$control);
expr<-t(apply(expr0, 1, function(x) (x-mean(x[ind]))/sd(x)));
} else if (prms$normalization$method == 1) expr<-t(scale(t(expr))) else expr<-expr0;
expr[1, ]
prms$normalization$method
e<-expr0[1, ]
mean(e)
mean(e)-e[1:3]
e-e[1:3]
sd(e-e[1:3])
# All run-specific parameters
prms<-yml$parameter;
# folder and subfolders of output files
f <- GenerateFolder(yml$output, c('input', 'R', 'figure', 'table', 'cluster'));
path <- yml$output;
path.r <- f['R'];
path.cl <- f['cluster'];
path.tbl <- f['table'];
path.fig <- f['figure'];
path.input <- f['input'];
# Load input data
expr<-ImportTable(DownloadFile(yml$input$data, path.input));
anno<-ImportTable(DownloadFile(yml$input$annotation, path.input));
smpl<-ImportTable(DownloadFile(yml$input$sample, path.input));
gset<-ImportR(DownloadFile(yml$input$geneset, path.input));
saveRDS(expr, file=paste(path.input, TrimPath(yml$input$data), sep='/'));
saveRDS(anno, file=paste(path.input, TrimPath(yml$input$annotation), sep='/'));
saveRDS(smpl, file=paste(path.input, TrimPath(yml$input$sample), sep='/'));
saveRDS(gset, file=paste(path.input, TrimPath(yml$input$geneset), sep='/'));
anno<-anno[rownames(anno) %in% rownames(expr), , drop=FALSE];
smpl<-smpl[rownames(smpl) %in% colnames(expr), , drop=FALSE];
if (nrow(anno) <= 1) stop("Not enough genes to perform clustering.\n");
if (nrow(smpl) <= 1) stop("Not enough samples to perform clustering.\n");
expr0<-expr[rownames(anno), rownames(smpl)];  # Original matrix
phen<-smpl[, prms$term[1]];
ind<-which(smpl[, prms$term[1]]==prms$normalization$control);
ind
prms$normalization$control
smpl[1,]
ind<-which(smpl[, prms$term[1]]==prms$normalization$control);
if (length(ind)==0) stop('Error: no samples belong to control group"', prms$normalization$control,  '".\n')
setwd('~/Documents/RoCA/data/gex/circadian_rhythm/')
dir()
s<-readRDS('sample.rds')
s[1, ]
s<-s[s[,2]=='WT', ]
s
s<-s[, -2]
s
s[1:2, ]
saveRDS(s, 'sample_wt.rds')
setwd('../../')
dir()
setwd('../template/de/cluster_gene/')
dir()
CreateReport('cluster_gene.yaml')
s<-readRDS('examples/circadian_rhythm/input/sample_wt.rds')
s
CreateReport('cluster_gene.yaml')
s[1, ]
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
require(gplots);
require(knitr);
require(rmarkdown);
require(yaml);
require(RCurl);
require(awsomics);
require(rchive);
if (!exists('yml'))                               # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
if (file.exists('cluster_gene.yaml'))           # assume the pairing YAML file exists in the current folder with the same name
yml<-yaml.load_file('cluster_gene.yaml');
# All run-specific parameters
prms<-yml$parameter;
# folder and subfolders of output files
f <- GenerateFolder(yml$output, c('input', 'R', 'figure', 'table', 'cluster'));
path <- yml$output;
path.r <- f['R'];
path.cl <- f['cluster'];
path.tbl <- f['table'];
path.fig <- f['figure'];
path.input <- f['input'];
# Load input data
expr<-ImportTable(DownloadFile(yml$input$data, path.input));
anno<-ImportTable(DownloadFile(yml$input$annotation, path.input));
smpl<-ImportTable(DownloadFile(yml$input$sample, path.input));
gset<-ImportR(DownloadFile(yml$input$geneset, path.input));
saveRDS(expr, file=paste(path.input, TrimPath(yml$input$data), sep='/'));
saveRDS(anno, file=paste(path.input, TrimPath(yml$input$annotation), sep='/'));
saveRDS(smpl, file=paste(path.input, TrimPath(yml$input$sample), sep='/'));
saveRDS(gset, file=paste(path.input, TrimPath(yml$input$geneset), sep='/'));
anno<-anno[rownames(anno) %in% rownames(expr), , drop=FALSE];
smpl<-smpl[rownames(smpl) %in% colnames(expr), , drop=FALSE];
if (nrow(anno) <= 1) stop("Not enough genes to perform clustering.\n");
if (nrow(smpl) <= 1) stop("Not enough samples to perform clustering.\n");
expr0<-expr[rownames(anno), rownames(smpl)];  # Original matrix
phen<-smpl[, prms$term[1]];
if (prms$normalization$method == 2) {
ind<-which(smpl[, prms$term[1]]==prms$normalization$control);
if (length(ind)==0) stop('Error: no samples belong to control group "', prms$normalization$control,  '".\n')
expr<-t(apply(expr0, 1, function(x) (x-mean(x[ind]))/sd(x)));
} else if (prms$normalization$method == 1) expr<-t(scale(t(expr))) else expr<-expr0;
CreateDatatable(smpl, paste(path.tbl, 'sample.html', sep='/'));
# URL to project home
home.url <- Link2Home(yml$home);
smpl
prms$term[1]]
smpl[, prms$term[1]]
term
yml$parameter$term
rm(list=ls())
CreateReport('cluster_gene.yaml')
CreateReport('cluster_gene.yaml')
CreateReport('cluster_gene.yaml')
CreateReport('cluster_gene.yaml')
CreateReport('cluster_gene.yaml')
CreateReport('cluster_gene.yaml')
getwd()
setwd('../../qc')
dir()
setwd('adjust_batch/')
CreateReport('cluster_gene.yaml')
CreateReport('adjust_batch.yaml')
setwd('../../de/cluster_gene/')
CreateReport('adjust_batch.yaml')
CreateReport('cluster_gene.yaml')
CreateReport('cluster_gene.yaml')
CreateReport('cluster_gene.yaml')
CreateReport('cluster_gene.yaml')
rm(list=ls())
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
require(gplots);
require(knitr);
require(rmarkdown);
require(yaml);
require(RCurl);
require(awsomics);
require(rchive);
if (!exists('yml'))                               # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
if (file.exists('cluster_gene.yaml'))           # assume the pairing YAML file exists in the current folder with the same name
yml<-yaml.load_file('cluster_gene.yaml');
# All run-specific parameters
prms<-yml$parameter;
# folder and subfolders of output files
f <- GenerateFolder(yml$output, c('input', 'R', 'figure', 'table', 'cluster'));
path <- yml$output;
path.r <- f['R'];
path.cl <- f['cluster'];
path.tbl <- f['table'];
path.fig <- f['figure'];
path.input <- f['input'];
# Load input data
expr<-ImportTable(DownloadFile(yml$input$data, path.input));
anno<-ImportTable(DownloadFile(yml$input$annotation, path.input));
smpl<-ImportTable(DownloadFile(yml$input$sample, path.input));
gset<-ImportR(DownloadFile(yml$input$geneset, path.input));
saveRDS(expr, file=paste(path.input, TrimPath(yml$input$data), sep='/'));
saveRDS(anno, file=paste(path.input, TrimPath(yml$input$annotation), sep='/'));
saveRDS(smpl, file=paste(path.input, TrimPath(yml$input$sample), sep='/'));
saveRDS(gset, file=paste(path.input, TrimPath(yml$input$geneset), sep='/'));
anno<-anno[rownames(anno) %in% rownames(expr), , drop=FALSE];
smpl<-smpl[rownames(smpl) %in% colnames(expr), , drop=FALSE];
if (nrow(anno) <= 1) stop("Not enough genes to perform clustering.\n");
if (nrow(smpl) <= 1) stop("Not enough samples to perform clustering.\n");
expr0<-expr[rownames(anno), rownames(smpl)];  # Original matrix
phen<-smpl[, prms$term[1]];
if (prms$normalization$method == 2) {
ind<-which(smpl[, prms$term[1]]==prms$normalization$control);
if (length(ind)==0) stop('Error: no samples belong to control group "', prms$normalization$control,  '".\n')
expr<-t(apply(expr0, 1, function(x) (x-mean(x[ind]))/sd(x)));
} else if (prms$normalization$method == 1) expr<-t(scale(t(expr))) else expr<-expr0;
CreateDatatable(smpl, paste(path.tbl, 'sample.html', sep='/'));
# URL to project home
home.url <- Link2Home(yml$home);
dim(expr)
dim(expr0)
dim(anno)
expr<-ImportTable(DownloadFile(yml$input$data, path.input));
anno<-ImportTable(DownloadFile(yml$input$annotation, path.input));
smpl<-ImportTable(DownloadFile(yml$input$sample, path.input));
gset<-ImportR(DownloadFile(yml$input$geneset, path.input));
dim(anno)
dim(expr)
head(anno)
anno<-anno[rownames(anno) %in% rownames(expr), , drop=FALSE];
dim(anno)
head(expr)
x<-rownames(expr)
x<-strsplit(x, '_')
x<-sapply(x, function(x) x[1])
head(x)
rownames(expr)<-x
saveRDS(expr, '~/Documents/RoCA/data/gex/NCI60/expr_ss.rds')
rm(list=ls())
CreateReport('cluster_gene.yaml')
CreateReport('cluster_gene.yaml')
CreateReport('cluster_gene.yaml')
