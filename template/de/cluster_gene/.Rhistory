path.r<-paste(path, 'R', sep='/');
path.tbl<-paste(path, 'table', sep='/');
path.fig<-paste(path, 'figure', sep='/');
path.input<-paste(path, 'input', sep='/');
sapply(c(path, path.r, path.tbl, path.fig, path.input), function(f) if (!file.exists(f)) dir.create(f, recursive = TRUE))->x;
# Load input data
mtr<-readRDS(yml$input$matrix); # full data matrix; columns are samples/rows are variables
smp<-readRDS(yml$input$sample); # sample description; rows must match columns of data matrix
CreateDatatable(smp, paste(path.tbl, 'sample.html', sep='/'))
saveRDS(mtr, paste(path.input, 'matrix.rds', sep='/'));
saveRDS(smp, paste(path.input, 'sample.rds', sep='/'));
# Match sample IDs
smp<-smp[rownames(smp) %in% colnames(mtr), , drop=FALSE];
mtr<-mtr[, rownames(smp)];
if (nrow(smp) < 2) stop('Not enough samples to perform the analysis.\n');
# Make all columns factors
for (i in 1:ncol(smp)) if (!is.numeric(smp[[i]])) smp[[i]]<-as.factor(as.vector(smp[[i]]));
# Variable names
v0<-yml$parameter$interest; # variable(s) of interest
v1<-yml$parameter$batch; # known batch effect variable(s)
v0<-v0[v0 %in% colnames(smp)];
v1<-v1[v1 %in% colnames(smp)];
if (length(v0) < 1) stop('No variable of interest was specified. \n');
# URL to project home
if (is.null(yml$home)) home.url<-'' else
home.url<-paste("<div align='right'>_[Go back to project home](", yml$home, ")_</div>", sep='');
# Description of this analysis
lns<-lapply(names(yml$description), function(nm) {
c(paste('##', nm), '\n', yml$description[[nm]], '\n');
});
lns<-paste(do.call('c', lns), collapse='\n');
nlvl<-sapply(colnames(smp), function(nm) length(unique(as.vector(smp[, nm]))));
clss<-sapply(1:ncol(smp), function(i) class(smp[[i]]));
tbl<-data.frame(Sample_feature=colnames(smp), Type=clss, Num_level=nlvl, Variable_of_interest=colnames(smp) %in% v0, Batch_effect=colnames(smp) %in% v1);
rm(yml)
require(knitr);
require(yaml);
require(sva);
require(awsomics);
require(limma);
knitr::opts_chunk$set(eval=TRUE, dev=c('png', 'pdf'), dpi=300, echo=FALSE, warning=FALSE, message=FALSE);
if (!exists('yml'))                               # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
if (file.exists('adjust_batch.yaml'))           # assume the pairing YAML file exists in the current folder with the same name
yml<-yaml.load_file('adjust_batch.yaml');
# folder and subfolders of output files
path<-yml$output;
path.r<-paste(path, 'R', sep='/');
path.tbl<-paste(path, 'table', sep='/');
path.fig<-paste(path, 'figure', sep='/');
path.input<-paste(path, 'input', sep='/');
sapply(c(path, path.r, path.tbl, path.fig, path.input), function(f) if (!file.exists(f)) dir.create(f, recursive = TRUE))->x;
# Load input data
mtr<-readRDS(yml$input$matrix); # full data matrix; columns are samples/rows are variables
smp<-readRDS(yml$input$sample); # sample description; rows must match columns of data matrix
CreateDatatable(smp, paste(path.tbl, 'sample.html', sep='/'))
saveRDS(mtr, paste(path.input, 'matrix.rds', sep='/'));
saveRDS(smp, paste(path.input, 'sample.rds', sep='/'));
# Match sample IDs
smp<-smp[rownames(smp) %in% colnames(mtr), , drop=FALSE];
mtr<-mtr[, rownames(smp)];
if (nrow(smp) < 2) stop('Not enough samples to perform the analysis.\n');
# Make all columns factors
for (i in 1:ncol(smp)) if (!is.numeric(smp[[i]])) smp[[i]]<-as.factor(as.vector(smp[[i]]));
# Variable names
v0<-yml$parameter$interest; # variable(s) of interest
v1<-yml$parameter$batch; # known batch effect variable(s)
v0<-v0[v0 %in% colnames(smp)];
v1<-v1[v1 %in% colnames(smp)];
if (length(v0) < 1) stop('No variable of interest was specified. \n');
# URL to project home
if (is.null(yml$home)) home.url<-'' else
home.url<-paste("<div align='right'>_[Go back to project home](", yml$home, ")_</div>", sep='');
# Description of this analysis
lns<-lapply(names(yml$description), function(nm) {
c(paste('##', nm), '\n', yml$description[[nm]], '\n');
});
lns<-paste(do.call('c', lns), collapse='\n');
CreateReport('adjust_batch.yaml')
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
rm(yml)
source('~/.active-rstudio-document', echo=TRUE)
download.file('https://raw.githubusercontent.com/zhezhangsh/RoCA/master/data/gex/circadian_rhythm/expr.rds', 'expr.rds')
file.remove('expr.rds')
rm(yml)
rm(list=ls())
dir()
require(knitr);
require(yaml);
require(sva);
require(awsomics);
require(limma);
knitr::opts_chunk$set(eval=TRUE, dev=c('png', 'pdf'), dpi=300, echo=FALSE, warning=FALSE, message=FALSE);
if (!exists('yml'))                               # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
if (file.exists('adjust_batch.yaml'))           # assume the pairing YAML file exists in the current folder with the same name
yml<-yaml.load_file('adjust_batch.yaml');
# folder and subfolders of output files
path<-yml$output;
path.r<-paste(path, 'R', sep='/');
path.tbl<-paste(path, 'table', sep='/');
path.fig<-paste(path, 'figure', sep='/');
path.input<-paste(path, 'input', sep='/');
sapply(c(path, path.r, path.tbl, path.fig, path.input), function(f) if (!file.exists(f)) dir.create(f, recursive = TRUE))->x;
# Load input data
mtr<-readRDS(yml$input$matrix); # full data matrix; columns are samples/rows are variables
smp<-readRDS(yml$input$sample); # sample description; rows must match columns of data matrix
CreateDatatable(smp, paste(path.tbl, 'sample.html', sep='/'))
saveRDS(mtr, paste(path.input, TrimPath(yml$input$matrix), sep='/'));
saveRDS(smp, paste(path.input, TrimPath(yml$input$sample), sep='/'));
# Match sample IDs
smp<-smp[rownames(smp) %in% colnames(mtr), , drop=FALSE];
mtr<-mtr[, rownames(smp)];
if (nrow(smp) < 2) stop('Not enough samples to perform the analysis.\n');
# Make all columns factors
for (i in 1:ncol(smp)) if (!is.numeric(smp[[i]])) smp[[i]]<-as.factor(as.vector(smp[[i]]));
# Variable names
v0<-yml$parameter$interest; # variable(s) of interest
v1<-yml$parameter$batch; # known batch effect variable(s)
v0<-v0[v0 %in% colnames(smp)];
v1<-v1[v1 %in% colnames(smp)];
if (length(v0) < 1) stop('No variable of interest was specified. \n');
# URL to project home
if (is.null(yml$home)) home.url<-'' else
home.url<-paste("<div align='right'>_[Go back to project home](", yml$home, ")_</div>", sep='');
# Description of this analysis
lns<-lapply(names(yml$description), function(nm) {
c(paste('##', nm), '\n', yml$description[[nm]], '\n');
});
lns<-paste(do.call('c', lns), collapse='\n');
source('~/.active-rstudio-document', echo=TRUE)
as.expression('r^2')
as.expression(10^2)
as.character(as.expression(10^2))
as.character(as.expression('10^2'))
?geom_text
library(ggplot2)
?geom_text
p <- ggplot(mtcars, aes(x=wt, y=mpg, label=rownames(mtcars)))
p + geom_text()
# Change size of the label
p + geom_text(size=10)
p <- p + geom_point()
# Set aesthetics to fixed value
p + geom_text()
p + geom_point() + geom_text(hjust=0, vjust=0)
p + geom_point() + geom_text(angle = 45)
# Add aesthetic mappings
p + geom_text(aes(colour=factor(cyl)))
p + geom_text(aes(colour=factor(cyl))) + scale_colour_discrete(l=40)
p + geom_text(aes(size=wt))
p + geom_text(aes(size=wt)) + scale_size(range=c(3,6))
# You can display expressions by setting parse = TRUE.  The
# details of the display are described in ?plotmath, but note that
# geom_text uses strings, not expressions.
p + geom_text(aes(label = paste(wt, "^(", cyl, ")", sep = "")),
parse = TRUE)
p + geom_text(aes(label = paste(wt, "^(", cyl, ")", sep = "")),
+               parse = TRUE)
p + geom_text(aes(label = paste(wt, "^(", cyl, ")", sep = "")),
parse = TRUE)
geom_text(aes(label = paste(wt, "^(", cyl, ")", sep = "")), parse=TRUE)
plot(0:1, 0:1)
text(.5, .5, label=geom_text(aes(label = paste(wt, "^(", cyl, ")", sep = "")), parse=TRUE))
x<-geom_text(aes(label = paste(wt, "^(", cyl, ")", sep = "")), parse=TRUE))
x<-geom_text(aes(label = paste(wt, "^(", cyl, ")", sep = "")), parse=TRUE)
class(x)
str(x)
?"text"
?format
dim(c)
c
PlotColoredBlock(c, min=floor(min(c, na.rm=TRUE)-1), max=ceiling(max(c, na.rm=TRUE)+1), key='Enrichment', num.breaks = 127);
min(c)
floor(min(c, na.rm=TRUE)-1)
max(c)
CreateReport('adjust_batch.yaml')
CreateReport('adjust_batch.yaml')
?bquote
bquote(R^2 == .(format(0.5, digits = 2)))
plot(0:2, 0:2)
text(1, 1, label=bquote(R^2 == .(format(0.5, digits = 2))))
text(1, 1, label=bquote(R^2 == .(format(0.9))))
plot(1:20, pch=1:20)
legend('topleft', legend=bquote(R^2 == .(format(1.0, digits=2)))
)
legend('topleft', legend=bquote(R^2 == .(format(1.0, digits=2))))
plot(1:20, pch=1:20)
legend('topleft', legend=bquote(R^2 == .(format(1.0, digits=2))))
CreateReport('adjust_batch.yaml')
setwd('../summarize_fastqc/')
dir()
source('~/.active-rstudio-document', echo=TRUE)
rm(list=ls())
source('~/.active-rstudio-document', echo=TRUE)
par(mfrow=c(1,1))
PlotColoredBlock(t(sc), group=as.list(rownames(sc)));
PlotColoredBlock(t(sc), group=as.list(rownames(sc)), key='Average score');
PlotColoredBlock(t(pct), group=as.list(rownames(pct)));
PlotColoredBlock(t(pct), group=as.list(rownames(pct)), key='Percent');
PlotColoredBlock(t(npct), group=as.list(rownames(npct)));
PlotColoredBlock(t(npct), group=as.list(rownames(npct)), key='Percent');
max(npct)
min(npct)
min=NA
max=NA
num.breaks=15
group=as.list(rownames(npct))
d<-t(npct)
dim(d)
require(awsomics);
if (num.breaks<1) num.breaks<-32;
col<-GetBluePickogramColors(num.breaks);
if (is.na(min)) min<-min(d, na.rm=TRUE);
if (is.na(max)) max<-max(d, na.rm=TRUE);
if (min > min(d, na.rm=TRUE)) d[!is.na(d) & d<min]<-min;
if (max < max(d, na.rm=TRUE)) d[!is.na(d) & d>max]<-max;
breaks<-seq(min, max, length.out = length(col)+1);
# column/row names
rnm<-rownames(d);
cnm<-colnames(d);
nr<-nrow(d);
nc<-ncol(d);
# Current device size in inch
W<-par()$fin[1] - .2;
H<-par()$fin[2] - .2;
str.h<-strheight('', unit='inches'); # default string height
# Total block size
block.w<-1.2*str.h*nc;
block.h<-1.2*str.h*nr;
ratio<-c(0.1, 10); # minimal and maximal label/block ratio
# lable size
wid.r<-max(strwidth(rnm, units='inches'));
wid.c<-max(strwidth(cnm, units='inches'));
str.r<-wid.r/max(1, str.h/(0.75*H/nr));
str.c<-wid.c/max(1, str.h/(0.75*W/nc));
str.r<-max(ratio[1]*block.w, min(ratio[2]*block.w, str.r));
str.c<-max(ratio[1]*block.h, min(ratio[2]*block.h, str.c));
if (0.9*block.w/ncol(d) < str.h) str.c<-str.c*(0.9*block.w/ncol(d)/str.h);
# label + block size
full.w<-block.w+str.r;
full.h<-block.h+str.c;
# ratio to device size
ratio.w<-W/full.w;
ratio.h<-H/full.h;
# plot heatmap
par(mar=c(0.1, 0.1, 0.1, 0.1));
limit.w<-ceiling(full.w/(block.w/nc));
limit.h<-ceiling(full.h/(block.h/nr));
plot(0, type='n', xlim=c(0, limit.w), ylim=c(0, limit.h), xaxs='i', yaxs='i', axes=FALSE, xlab='', ylab='');
image(0:nc, 0:nr, t(d[nr:1,]), col=col, breaks=breaks, add=TRUE);
# column background label
#   if (length(groups) > 0) {
#     c0<-gplots::colorpanel(length(groups), "#CCCCCC", "#FFEE00");
#     c1<-rep('#FFFFFF', ncol(d));
#     names(c1)<-colnames(d);
#     for (i in 1:length(groups)) c1[names(c1) %in% groups[[i]]]<-c0[i];
#     rect(0:(ncol(d)-1), nrow(d), 1:ncol(d), limit.h, border=NA, col=c1)
#   }
# column background label
if (length(groups) > 0) {
c0<-rep('#FFFFFF', length(groups));
c0[seq(1, length(groups), 2)]<-"#DDDDDD"
c1<-rep(c0, sapply(groups, length));
names(c1)<-unlist(groups);
c1<-c1[colnames(d)];
rect(0:(ncol(d)-1), nrow(d), 1:ncol(d), limit.h, border=NA, col=c1);
}
# row background label
c2<-rep('#FFFFFF', nrow(d));
c2[seq(1, nrow(d), 2)]<-'#DDDDDD';
rect(ncol(d), 0:(nrow(d)-1), limit.w, 1:nrow(d), border=NA, col=rev(c2));
# plot row names
space.w<-(1-nc/limit.w)*W;
cex.w<-(space.w-0.2)/wid.r;
cex.w<-min(cex.w, 0.66*(H/limit.h)/str.h);
text(nc, (nr:1)-0.5, pos=4, label=rnm, cex=cex.w);
# plot column names
space.h<-(1-nr/limit.h)*H;
cex.h<-(space.h-0.2)/wid.c;
cex.h<-min(cex.h, 0.66*(W/limit.w)/str.h);
text((1:nc)-0.5, (nr+limit.h)/2, srt=90, label=cnm, cex=cex.h);
key
key<-'GC percent'
key.w<-0.6*(space.w-0.2)/strwidth(key, units='inches');
key.h<-0.2*space.h/str.h
text((nc+limit.w)/2, nr, pos=3, label=key, col='purple', cex=min(key.w, key.h));
key.w<-limit.w-nc;
key.h<-limit.h-nr;
key.x<-c(nc + 0.15*key.w, nc + 0.85*key.w);
key.y<-c(nr + 0.4*key.h, nr + 0.6*key.h);
image(seq(key.x[1], key.x[2], length.out=num.breaks+1), key.y, matrix(breaks, nc=1), col=col, breaks=breaks, add=TRUE);
min<-round(min, ceiling(log10(abs(min))));
max<-round(max, ceiling(log10(abs(min))));
min
max
key.w<-0.6*(space.w-0.2)/strwidth(key, units='inches');
key.h<-0.2*space.h/str.h
text((nc+limit.w)/2, nr, pos=3, label=key, col='purple', cex=min(key.w, key.h));
key.w<-limit.w-nc;
key.h<-limit.h-nr;
key.x<-c(nc + 0.15*key.w, nc + 0.85*key.w);
key.y<-c(nr + 0.4*key.h, nr + 0.6*key.h);
image(seq(key.x[1], key.x[2], length.out=num.breaks+1), key.y, matrix(breaks, nc=1), col=col, breaks=breaks, add=TRUE);
min
max
ceiling(log10(abs(min)))
ceiling(log10(abs(min)))
if (num.breaks<1) num.breaks<-32;
col<-GetBluePickogramColors(num.breaks);
if (is.na(min)) min<-min(d, na.rm=TRUE);
if (is.na(max)) max<-max(d, na.rm=TRUE);
max
max(d)
is.na(max)
min=NA
max=NA
require(awsomics);
if (num.breaks<1) num.breaks<-32;
col<-GetBluePickogramColors(num.breaks);
if (is.na(min)) min<-min(d, na.rm=TRUE);
if (is.na(max)) max<-max(d, na.rm=TRUE);
if (min > min(d, na.rm=TRUE)) d[!is.na(d) & d<min]<-min;
if (max < max(d, na.rm=TRUE)) d[!is.na(d) & d>max]<-max;
breaks<-seq(min, max, length.out = length(col)+1);
# column/row names
rnm<-rownames(d);
cnm<-colnames(d);
nr<-nrow(d);
nc<-ncol(d);
# Current device size in inch
W<-par()$fin[1] - .2;
H<-par()$fin[2] - .2;
str.h<-strheight('', unit='inches'); # default string height
# Total block size
block.w<-1.2*str.h*nc;
block.h<-1.2*str.h*nr;
ratio<-c(0.1, 10); # minimal and maximal label/block ratio
# lable size
wid.r<-max(strwidth(rnm, units='inches'));
wid.c<-max(strwidth(cnm, units='inches'));
str.r<-wid.r/max(1, str.h/(0.75*H/nr));
str.c<-wid.c/max(1, str.h/(0.75*W/nc));
str.r<-max(ratio[1]*block.w, min(ratio[2]*block.w, str.r));
str.c<-max(ratio[1]*block.h, min(ratio[2]*block.h, str.c));
if (0.9*block.w/ncol(d) < str.h) str.c<-str.c*(0.9*block.w/ncol(d)/str.h);
# label + block size
full.w<-block.w+str.r;
full.h<-block.h+str.c;
# ratio to device size
ratio.w<-W/full.w;
ratio.h<-H/full.h;
# plot heatmap
par(mar=c(0.1, 0.1, 0.1, 0.1));
limit.w<-ceiling(full.w/(block.w/nc));
limit.h<-ceiling(full.h/(block.h/nr));
plot(0, type='n', xlim=c(0, limit.w), ylim=c(0, limit.h), xaxs='i', yaxs='i', axes=FALSE, xlab='', ylab='');
image(0:nc, 0:nr, t(d[nr:1,]), col=col, breaks=breaks, add=TRUE);
min
max
if (length(groups) > 0) {
c0<-rep('#FFFFFF', length(groups));
c0[seq(1, length(groups), 2)]<-"#DDDDDD"
c1<-rep(c0, sapply(groups, length));
names(c1)<-unlist(groups);
c1<-c1[colnames(d)];
rect(0:(ncol(d)-1), nrow(d), 1:ncol(d), limit.h, border=NA, col=c1);
}
min<-nA
min<-NA
nA
max<-nA
max<-NA
group
require(awsomics);
if (num.breaks<1) num.breaks<-32;
col<-GetBluePickogramColors(num.breaks);
if (is.na(min)) min<-min(d, na.rm=TRUE);
if (is.na(max)) max<-max(d, na.rm=TRUE);
if (min > min(d, na.rm=TRUE)) d[!is.na(d) & d<min]<-min;
if (max < max(d, na.rm=TRUE)) d[!is.na(d) & d>max]<-max;
breaks<-seq(min, max, length.out = length(col)+1);
# column/row names
rnm<-rownames(d);
cnm<-colnames(d);
nr<-nrow(d);
nc<-ncol(d);
# Current device size in inch
W<-par()$fin[1] - .2;
H<-par()$fin[2] - .2;
str.h<-strheight('', unit='inches'); # default string height
# Total block size
block.w<-1.2*str.h*nc;
block.h<-1.2*str.h*nr;
ratio<-c(0.1, 10); # minimal and maximal label/block ratio
# lable size
wid.r<-max(strwidth(rnm, units='inches'));
wid.c<-max(strwidth(cnm, units='inches'));
str.r<-wid.r/max(1, str.h/(0.75*H/nr));
str.c<-wid.c/max(1, str.h/(0.75*W/nc));
str.r<-max(ratio[1]*block.w, min(ratio[2]*block.w, str.r));
str.c<-max(ratio[1]*block.h, min(ratio[2]*block.h, str.c));
if (0.9*block.w/ncol(d) < str.h) str.c<-str.c*(0.9*block.w/ncol(d)/str.h);
# label + block size
full.w<-block.w+str.r;
full.h<-block.h+str.c;
# ratio to device size
ratio.w<-W/full.w;
ratio.h<-H/full.h;
# plot heatmap
par(mar=c(0.1, 0.1, 0.1, 0.1));
limit.w<-ceiling(full.w/(block.w/nc));
limit.h<-ceiling(full.h/(block.h/nr));
plot(0, type='n', xlim=c(0, limit.w), ylim=c(0, limit.h), xaxs='i', yaxs='i', axes=FALSE, xlab='', ylab='');
image(0:nc, 0:nr, t(d[nr:1,]), col=col, breaks=breaks, add=TRUE);
# column background label
#   if (length(groups) > 0) {
#     c0<-gplots::colorpanel(length(groups), "#CCCCCC", "#FFEE00");
#     c1<-rep('#FFFFFF', ncol(d));
#     names(c1)<-colnames(d);
#     for (i in 1:length(groups)) c1[names(c1) %in% groups[[i]]]<-c0[i];
#     rect(0:(ncol(d)-1), nrow(d), 1:ncol(d), limit.h, border=NA, col=c1)
#   }
# column background label
if (length(groups) > 0) {
c0<-rep('#FFFFFF', length(groups));
c0[seq(1, length(groups), 2)]<-"#DDDDDD"
c1<-rep(c0, sapply(groups, length));
names(c1)<-unlist(groups);
c1<-c1[colnames(d)];
rect(0:(ncol(d)-1), nrow(d), 1:ncol(d), limit.h, border=NA, col=c1);
}
# row background label
c2<-rep('#FFFFFF', nrow(d));
c2[seq(1, nrow(d), 2)]<-'#DDDDDD';
rect(ncol(d), 0:(nrow(d)-1), limit.w, 1:nrow(d), border=NA, col=rev(c2));
# plot row names
space.w<-(1-nc/limit.w)*W;
cex.w<-(space.w-0.2)/wid.r;
cex.w<-min(cex.w, 0.66*(H/limit.h)/str.h);
text(nc, (nr:1)-0.5, pos=4, label=rnm, cex=cex.w);
# plot column names
space.h<-(1-nr/limit.h)*H;
cex.h<-(space.h-0.2)/wid.c;
cex.h<-min(cex.h, 0.66*(W/limit.w)/str.h);
text((1:nc)-0.5, (nr+limit.h)/2, srt=90, label=cnm, cex=cex.h);
min
max
# key name
key.w<-0.6*(space.w-0.2)/strwidth(key, units='inches');
key.h<-0.2*space.h/str.h
text((nc+limit.w)/2, nr, pos=3, label=key, col='purple', cex=min(key.w, key.h));
key.w<-limit.w-nc;
key.h<-limit.h-nr;
key.x<-c(nc + 0.15*key.w, nc + 0.85*key.w);
key.y<-c(nr + 0.4*key.h, nr + 0.6*key.h);
image(seq(key.x[1], key.x[2], length.out=num.breaks+1), key.y, matrix(breaks, nc=1), col=col, breaks=breaks, add=TRUE);
max
min
round(min, ceiling(log10(abs(min))));
round(max, ceiling(log10(abs(min))));
min<-0.1
ceiling(log10(abs(min)))
format(100.1)
format(100.10001)
format(0.0001)
format(0.01254443)
format(0.0001432423423)
ceiling(log10(abs(1.0300333)))
ceiling(log10(abs(100.0300333)))
ceiling(log10(abs(100.030033300009)))
?round
trunc(10000)
trunc(10000.3453425432)
trunc(1.345)
trunc(1.34523423432)
trunc(0.231412321)
-log10(0.000111)
ceiling(-log10(abs))+2
abs<-max(abs(max), abs(min));
if (abs>=100) rnd<-0 else if(abs>=10) rnd<-2 else if (abs>=1) rnd<-3 else if (abs==0) rnd<-1 else
rnd<-ceiling(-log10(abs))+2;
rnd
ceiling(-log10(0.1332))+2
ceiling(-log10(0.1332345243232432))+2
devtools::install_github("zhezhangsh/awsomics");
library(awsomics);
detach("package:awsomics", unload=TRUE)
library("awsomics", lib.loc="~/Library/R/3.2/library")
PlotColoredBlock
CreateReport('summarize_fastqc.yaml')
s<-readRDS('~/Desktop/RoCA/data/gex/NCI60/sample.rds')
s[1, ]
s<-readRDS('~/Desktop/RoCA/data/gex/NCI60/sample_p53.rds')
s[1:2, ]
getwd()
setwd('../adjust_batch/')
CreateReport('adjust_batch.yaml')
CreateReport('adjust_batch.yaml')
dim(s)
xtabs(~s[, 1]+s[, 3])
getwd()
setwd('../../de/cluster_gene/')
dir()
CreateReport('cluster_gene.yaml')
CreateReport('cluster_gene.yaml')
setwd('../../qc/adjust_batch/')
CreateReport('adjust_batch.yaml')
setwd('../../de/cluster_gene/')
CreateReport('cluster_gene.yaml')
