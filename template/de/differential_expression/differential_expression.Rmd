---
title: "Two-group differential gene expression"
author: "`r if (exists('yml')) yml$analyst else 'Jim Zhang'`"
date: "`r Sys.Date()`"
output:
  html_document:
    number_sections: yes
    self_contained: no
    toc: yes
    toc_float:
      collapsed: no
---

<div style="border:black 1px solid; padding: 0.5cm 0.5cm">
This procedure performs a two-group comparison of all genes in a transcriptome, or similar, data set. It accepts either read count data (RNA-seq) or normalized/log-transformed signal intensity (microarray or RNA-seq) as input. Gene-level analysis will be performed by applying a selected statistical test to the comparison of group means of each genes.
</div>

&nbsp;

```{r global_setup, include=FALSE}
name.yaml <- 'differential_expression.yaml'; 
name.packages <- c('rmarkdown', 'knitr', 'kableExtra', 'yaml', 'DT', 'htmlwidgets', 'MASS', 'gplots', 
                   'colorspace', 'RoCA', 'rchive', 'awsomics', 'DEGandMore'); 
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table', 'path.deg'='deg');

## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE, fig.path='figure/');

if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));

## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
  if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
    yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template

prms <- yml$parameter;

## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]); 

## Automatical figure/table ordering
OrderFigure(reset=TRUE);
OrderTable(reset=TRUE);

## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
```

```{r load_data, include=FALSE}
inputs<-yml$input;

# All input variables
anno    <- inputs$anno       <- ImportTable(DownloadFile(inputs$anno, path.input));
expr    <- inputs$expr       <- as.matrix(ImportTable(DownloadFile(inputs$expr, path.input)));
grps    <- inputs$comparison <- ImportR(DownloadFile(inputs$comparison, path.input));

g1.ind  <- intersect(colnames(expr), grps[[1]]);
g2.ind  <- intersect(colnames(expr), grps[[2]]);
g1.name <- gsub('-', '_', names(grps)[1]);
g2.name <- gsub('-', '_', names(grps)[2]);

anno <- anno[rownames(anno) %in% rownames(expr), , drop=FALSE]; 
expr <- expr[rownames(anno), , drop=FALSE]; 

paired <- prms$deg$paired;
if (is.null(paired))                         paired  <- FALSE; 
if (paired & length(g1.ind)!=length(g2.ind)) paired  <- FALSE;
if (is.null(g1.name))                        g1.name <- 'Group_1';
if (is.null(g2.name))                        g2.name <- 'Group_2';

# Check validity of inputs
if (nrow(expr) < 3)   stop('Less than 3 genes in the data set, cannot continue.\n');
if (is.null(g1.ind))  stop('Error: Index of samples in group 1 unknown\n');
if (is.null(g2.ind))  stop('Error: Index of samples in group 2 unknown\n');
if (length(g1.ind)<2) stop('Error: Not enough samples in group ', g1.name, ' (minimum=2), cannot continue.\n');
if (length(g2.ind)<2) stop('Error: Not enough samples in group ', g2.name, ' (minimum=2), cannot continue.\n');

# Re-process gene expression matrix
e1   <- expr[, g1.ind, drop=FALSE];
e2   <- expr[, g2.ind, drop=FALSE];
e1.2 <- cbind(e1, e2); 

inputs <- list(anno=anno, expr=expr);
inputs$parameters <- prms;
res <- list(inputs=inputs);  # Result set
```

```{r analysis_deg, include=FALSE}
de <- DeWrapper(mtrx=expr, grps=grps[1:2], mthd=prms$deg$method, paired=paired);
stat <- de$results$stat[, 1:6];
stat.table <- cbind(anno[rownames(stat), ], stat); 
stat.formatted <- FormatNumeric(cbind(ID=rownames(stat.table), stat.table));
stat.formatted[, prms$entrez+1] <- 
  AddHref(stat.formatted[, prms$entrez+1], UrlEntrezGene(stat.formatted[, prms$entrez+1]));
CreateDatatable(stat.formatted, fn = paste(path.deg, 'all_genes.html', sep='/'), 
                rownames = FALSE, caption = "Differential expression of all genes");
saveRDS(de, file=paste(path.r, 'all_genes.rds', sep='/'));
```

`r home.url` 

# Description
  
`r WriteDescription(yml$description)`

`r home.url` 

# Analysis and results

The analysis results below were based upon the following:

  - **Gene expression data**: 
    - **File location:** `r yml$input$expr`
    - **Number of genes:** `r nrow(e1.2)`
    - **Number of samples:** `r ncol(e1.2)`
  - **Gene annotation:** 
    - **File location:** `r yml$input$anno`
    - **Column names:** `r paste(colnames(anno), collapse='; ')`
  - **Comparison:** 
    - **Group0, `r g1.name`:** `r paste(colnames(e1), collapse='; ')` (n=`r ncol(e1)`)
    - **Group1, `r g2.name`:** `r paste(colnames(e2), collapse='; ')` (n=`r ncol(e1)`)
    - **Paired:** `r paired`
    - **Method:** `r sub('^De', '', prms$deg$method)`
  - **Location of outputs:** `r path`

## Sample analysis
  
This section analyzes the samples by summarizing their global expression patterns, through descriptive statistics, unsupervised clustering, and sample-sample correlation.
  
### Data distribution

Distribution of average expression level and between-sample variance. 

```{r data_distribution, include=TRUE, fig.width=4.8, fig.height=7.2, out.width='480px'}
if (prms$count) {
  nrm <- NormalizeRNAseq(round(e1.2), methods = 'NormDESeq')$DESeq;
  nrm[nrm<=1/3] <- 1/3;
  nrm <- log2(nrm); 
} else nrm <- e1.2;

par(mfrow=c(3,1), mar=c(4,5,2,2));

# Distribution of average expression level
m <- rowMeans(nrm);
d <- density(m);
x <- d$x;
y <- d$y;

plot(d, type='n', yaxs='i', xaxs='i', xlim=c(min(x), max(x)), ylim=c(0, 1.1*max(y)), xlab='', ylab='Density', main='A. Distribution of Expression Level', cex.lab=2, cex.main=1.5);
title(xlab='Average expression level of genes', line=2, cex=2);

x0  <- as.vector(summary(m))[2:5];
y0  <- sapply(x0, function(x0, x, y) y[which(abs(x-x0)==min(abs(x-x0)))], x=x, y=y);
col <- c('blue', 'red', 'orange', 'green');
segments(x0, 0, x0, y0, lty=1, col=col, lwd=1);
lines(d, col='darkgrey', lwd=4); 
text(x0, y0/2, srt=90, labels=round(x0, 3));
legend('topright', legend=c('First quantile', 'Median', 'Mean', 'Third quantile'), lty=1, col=col, bty='n', lwd=2);

# Distribution of standard deviation across samples
sd <- apply(nrm, 1, sd);
d  <- density(sd); 
x  <- d$x;
y  <- d$y;
plot(d, type='n', yaxs='i', xaxs='i', xlim=c(min(x), max(x)), ylim=c(0, 1.1*max(y)), xlab='', ylab='Density', main='B. Distribution of Variance', cex.lab=2, cex.main=1.5);
title(xlab='Standard deviation of genes', line=2, cex=2);

x0  <- as.vector(summary(sd))[2:5];
y0  <- sapply(x0, function(x0, x, y) y[which(abs(x-x0)==min(abs(x-x0)))], x=x, y=y);
col <-c('blue', 'red', 'orange', 'green');
segments(x0, 0, x0, y0, lty=1, col=col, lwd=1);
lines(d, col='darkgrey', lwd=4);
text(x0, y0/2, srt=90, labels=round(x0, 3));
legend('topright', legend=c('First quantile', 'Median', 'Mean', 'Third quantile'), lty=1, col=col, bty='n', lwd=2);

plot(m, sd, xlab='', ylab='Standard Deviation', main='C. Variance vs. Expression Level', cex.lab=2, cex.main=1.5, cex=0.5, col='darkgrey');
title(xlab='Average expression level of genes', line=2, cex=2);
lines(lowess(m, sd), lwd=3, col=2);
```

<div style="color:darkblue">
`r OrderFigure()`

 - **A.** This figure is based on the average expression measurements of all genes. They often have a bi-modal (two-peak) distribution: a high and narrow peak on the left corresponding to inactive genes and a relatively lower and wider peak on the right corresponding to active genes expressed different levels.
 - **B.** This figure is based on the between-sample standard deviations of all genes. The distribution usually has a single peak and a long tail on the right side. An enlarged tail usually indicates more genes are differentially expressed between samples. In a high quality data set, a gene not differentially expressed between samples should have small variance. So, if we assume that the majority of genes have no or little differential expression, the skewness of the peak towards the left side roughly represents data quality. 
 - **C.** This figure summarizes the relationship between gene expression measurements and their between-sample variance. If there is a strong dependency of variance on expression measurements, the analysis of differential expression will be affected by the baseline expression of genes. Variance stabilization procedure is commonly used during data normalization to minimize such dependency. In the figure, the red line is the result of LOWESS smoothing and the majority of this line should be approximately straight and horizontal if the data has been normalized properly.
</div>

`r home.url` 

### Sample similarity

By comparing gene expression patterns of different samples, observations can be made about the sample similarity. This section compares samples via data distribution, hierarchical clustering, and principal components analysis, which can potentially be used to identify outliers and confounding variables. 

```{r analysis_boxplot, include=TRUE, fig.width=6.4, fig.height=4, out.width='640px'}
par(mfrow=c(1,1), mai=c(0.7, 0.6, .1,.1))
plot(0, type='n', xlim=c(0.5, 0.5+ncol(nrm)), ylim=c(min(nrm), max(nrm)), ylab='', xlab='', xaxt='n'); 
lines(1:ncol(nrm), apply(nrm, 2, median), col='green', lwd=1);
title(ylab='Expression Level', line=2);
cex <- max(strwidth(colnames(nrm), unit='in'));
boxplot(data.frame(nrm), las=3, notch=TRUE, boxwex=.6, 
        col=c(rep('#2E86C1', ncol(e1)), rep('#CB4335', ncol(e2))), 
        names=colnames(nrm), cex.axis=min(1, 0.4/cex), yaxt='n', add=TRUE, pch=19, cex=0.4) -> x;
```

<div style="color:darkblue">
`r OrderFigure()` Each boxplot summarizes the expression measurements of all genes in one sample. Based on the assumption that all samples have approximately the same global distribution of gene expression measurements, all boxes should look similar regardless of which group they belong to. This assumption is not always true though. For example, normal cells and cancer cells could have dramatically different global patterns of gene expression. The notches of each box indicate the median, the lower and upper sides of the box represent the first and third quantile, and the individual data points out of the whiskers are the outliers (more than 1.5 inter-quantile range from the median).
</div>

```{r analysis_clustering, include=TRUE, fig.width=6.4, fig.height=4.8, out.width='640px'}
par(mfrow=c(1,1), mai=c(0.2, 0.8, .2 , .2));
plot(hclust(dist(t(nrm))), main='', ylab='', xlab='', sub='', cex=min(1, 5/ncol(nrm)/0.12), frame.plot=TRUE);
title(ylab='Distance', line=2.5, cex.lab=2);
```

<div style="color:darkblue">
`r OrderFigure()` This is an unsupervised clustering of samples used all genes in the data set. On the clustering tree, the vertical location of their lowest common node of any two samples represents their similarity (lower = more similar). Since the sample grouping information is not used, the splitting of samples into two sub-trees will indicate that these samples belong to different groups due to a known or unknown factor. Unexpected splitting often suggest outliers or confounding variables. 
</div>

```{r analysis_pca, include=TRUE, fig.width=6.4, fig.height=4.8, out.width='640px'}
pca <- prcomp(t(nrm));

X <- pca$x[,1];
Y <- pca$x[,2];
per <- round(summary(pca)$importance[2, 1:2]*100, 2);
pca$importance <- summary(pca)$importance;
res$pca <- pca;

col <- rep(c('#2E86C1', '#CB4335'), c(length(g1.ind), length(g2.ind)));

layout(matrix(1:2, nrow=1), width=c(3,1));
par(mai=c(1,1,.25,.25));

cx <- max(0.5, min(3, 64/length(X)))
plot(X, Y, col=col, pch=19, cex=cx, xlim=c(min(X)*1.1, max(X)*1.1), ylim=c(min(Y)*1.1, max(Y)*1.1), 
     xlab=paste('PC1', ', ', per[1], '%', sep=''), ylab=paste('PC2', ', ', per[2], '%', sep=''), cex.lab=1.5);

text(X, Y, label=1:length(X), col='white', cex=.3*cx);

par(mai=c(1, 0, 0.25, 0));
plot(0, type='n', xlim=c(0, 100), ylim=c(1, 100), axes=FALSE, bty='n', xaxs='i', yaxs='i', xlab='', ylab='');

w   <- strwidth(1:length(X), cex=1.2);
w0  <- 1.2*80/max(w, 80);
h0  <- 1.2*(100/length(X))/4.0;
cex <- min(1.2, w0, h0); 

points(rep(5, length(X)), 100-(1:length(X))*4.0*cex, col=col, pch=19, cex=1.8*cex);
text(5+cex*5, 100-(1:length(X))*4.0*cex, labels=colnames(nrm), adj=0, col=col, pch=19, cex=cex);
text(rep(5, length(labels)), 100-(1:length(X))*4.0*cex, labels=1:length(X), col='white', cex=0.8*cex);
```

<div style="color:darkblue">
`r OrderFigure()` Principal Components Analysis (PCA) is also an unsupervised analysis that converts a large number of correlated variables (genes) into a smaller set of uncorrelated variables called principal components (PCs). Each principal component accounts for certain percentage of total variability of a data set so the PCs can be ordered by their percentages. This figure plots the top two PCs on the two axes. In general, samples closer to each other have more similar gene expression patterns. PCA can be used to identify sample features, such as age, disease, and treatment, that are associated with one or two PCs. It then can be concluded that these features are responsible for part of the total variability in the data set.
</div>

`r home.url` 

## Differential gene expression

  - **Fold change, percentage change, ratio, or log2-ratio:** These statistics indicate the magnitude of the difference of group averages. They are the same values in different scale and can be easily converted to each other (see **Appendix 1**). Given the data has been log2-transformed, the difference of group averages is equivalent to the log2-ratio of unlogged data as _log2(A/B)==log2(A)-log2(B)_. So, group difference will be referred as log2-ratio throughout this report. 
  - **p value, q value, or FDR:** These statistics indicates the statistical significance of group difference.  P value refers to type I error of statistical test, or the chance to mistakenly conclude the differential expression of a gene while the gene is actually unchanged. RP estimates both p values and FDR based on a permutation procedure during which the ranked gene lists were shuffled to generate a background distribution of rank products.

### DEG summary

```{r deg_plot, include=TRUE, fig.width=6.4, fig.height=4.8, out.width='800px'}
par(mai=c(0.4, 0.5, 0.3, 0.05), mfrow=c(2,2));

# M-A Plot
x <- rowMeans(nrm[, g1.ind, drop=FALSE])/2 + rowMeans(nrm[, g2.ind, drop=FALSE])/2; 
y <- stat[, 4];
plot(x, y, main='A. M-A Plot', pch=19, col='#2471A3',  cex=.25, xlab='', ylab='', cex.axis=.75);
abline(h=0, lwd=1, col=1);
lines(lowess(y~x), lwd=2, col=3);
ylab<-paste('Log2(', g2.name, '/', g1.name, ')', sep='');
xlab<-paste('Log2(', g1.name, ')/2 + Log2(', g2.name, ')/2', sep='');
title(xlab=xlab, ylab=ylab, line=1.6, cex.lab=.75);

#Volcano Plot
x <- stat[,'LogFC'];
p <- stat[,'Pvalue'];
y <- -1*log10(p);
y[y==Inf] <- max(y[y<Inf])+1; 
z    <- sqrt(abs(x*y));
cx   <- z/(max(z));
ylim <- min(10, ceiling(max(y))); 
xlab <- paste('Log2(', g2.name, '/', g1.name, ')', sep='');
plot(x, y, main='B. Volcano Plot', pch=19, col='#C0392B',  cex=0.8*cx, 
     xlab='', ylab='', cex.axis=.75, ylim=c(0, 1.1*ylim), yaxs='i', 
     xlim=c(-1*max(abs(x)), max(abs(x))), yaxt='n');
title(xlab=xlab, ylab='P value', line=1.6, cex.lab=.75);
axis(2, at=0:ylim, labels=10^(-1*(0:ylim)));
abline(h=-1*log10(0.05), v=c(-1,1), col=4, lty=3);
box();

# P Value Distribution
hist(p[p<1], br=seq(0, 1, 0.01), cex.axis=.75, main='C. P Value Distribution', col='#D68910');
title(xlab='P value', ylab='Count', line=1.6, cex.lab=.75);
box();

# FDR
q<-round(stat[, 'FDR'], 2);
n<-sapply(seq(min(q), 1, 0.01), function(x) length(q[q<=x]));
plot(1, type='n', log='y', xlab='', ylab='', cex.axis=.75, xlim=0.01*c(1, 100), ylim=c(1, nrow(expr)), 
     main='D. False Discovery Rate');
abline(v=seq(0, 1, .05), lty=3, col=8);
lines(seq(min(q), 1, 0.01), n, lwd=2.5, col='#7D3C98');
title(xlab='FDR cutoff', ylab='Count', line=1.6, cex.lab=.75);
box();
```

<div style="color:darkblue">
`r OrderFigure()` The differential expression of all [`r nrow(expr)`](DEG/all_genes.html) genes can be visualized in different ways: 
  
  - **A:** ***M-A Plot.*** This plot visualizes global pattern of group difference (as log2-ratio). **M** (Y axis) is the log2-ratio and **A** (X axis) is the average measurements of the two groups. Each dot represents a gene and the green line is generated by LOWESS smoothing. The location and shape of the LOWESS line indicate whether there is an overall skewness of differential expression or expression level-dependent differential expression.
  - **B:** ***Volcano Plot.*** This plot puts together both types of variables (usually **p value** and **log2-ratio**) used to represent differential expression and their association. A common strategy is to only consider genes with both small p values and large log2-ratios as GOI (genes of interest). Each dot represents a gene and its size is proportional to its distance from the [0, 1] point. The horizontal line corresponds to a p value of 0.05 and the vertical lines correspond to 2.0 fold change on both sides. 
  - **C:** ***P Value Distribution.*** This plot shows the counts of genes whose Rank Product p values are located in each 0.01 interval. So, the leftmost bar indicates the number of genes having p values less than 0.01. If the data is completely random and there are enough samples, the p values will have a uniform distribution, with approximately the same number of genes in each interval. If there are indeed a number of genes differentially expressed between the compared groups and the microarray experiments are properly designed and executed, we expect that the p values have a distribution with the highest density on the left side. If the highest density of the distribution is in the middle or on the right side, we will suspect a confounding factor that has a bigger influence on the data than the factor distinguishing the two compared groups. 
  - **D:** ***FDR.*** This plots traces the number of genes corresponding to each FDR (false discovery rate) cutoff. **Table 1** lists the number of genes corresponding to commonly used FDR cutoffs. 
</div>
  
```{r deg_fdr, include=FALSE}
#FDR counts
c <- c(0.01, 0.02, 0.05, 0.1, 0.15, 0.2, 0.25);
n.fdr <- sapply(c, function(c) sapply(c(1, -1), function(di) 
  nrow(stat[sign(stat[, 'LogFC'])==di & stat[, 'FDR']<=c, , drop=FALSE])));
fdr.table <- cbind(c, t(n.fdr), colSums(n.fdr)); 
deg.sub <- paste(c('Higher', 'Lower'), 'in', g2.name, sep='_');
rownames(fdr.table) <- NULL;
colnames(fdr.table) <- c('FDR', deg.sub, 'Total')
```

<div style="color:darkblue">
`r OrderTable()` Number of top DEGs selected via different cutoffs of FDR. FDRs are calculated using the Benjamini&Hochberg method (_Controlling the false discovery rate: a practical and powerful approach to multiple testing_. Journal of the Royal Statistical Society Series B 57, 289â€“300. 1995)
</div>

`r kable(fdr.table) %>% kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE)`

`r home.url` 

### Top genes
  
```{r write_deg, include=FALSE}
z    <- tolower(prms$deg$rank[1]);
if (length(z) == 0) z <-'both'; 
if (z=='p') rnk <- -log10(stat[, 'Pvalue'])*sign(stat[,'LogFC']) else 
  if (z=='fc') rnk <- stat[, 'LogFC'] else 
    rnk <- sign(stat[,'LogFC'])*sqrt(abs(log10(stat[, 'Pvalue'])*stat[, 'LogFC'])); 
x  <- -rank(rnk); 
y  <- rank(-rnk); 
rk <- rep(NA, length(x));
rk[rnk>0] <- y[rnk>0];
rk[rnk<0] <- x[rnk<0];
names(rk) <- rownames(stat);
up <- stat[names(sort(rk[rk>0 & !is.na(rk)]))[1:max(1, prms$deg$num.top)], , drop=FALSE];
dn <- stat[names(rev(sort(rk[rk<0 & !is.na(rk)]))[1:max(1, prms$deg$num.top)]), , drop=FALSE];

pctl <- apply(nrm, 2, function(e) 100*rank(e)/length(e)); # percentile

path.deg1 <- paste(path.deg, deg.sub[1], sep='/');
path.deg2 <- paste(path.deg, deg.sub[2], sep='/');
path.deg1.bars <- paste(path.deg1, '/bars', sep='');
path.deg2.bars <- paste(path.deg2, '/bars', sep='');

if (!exists(path.deg1.bars)) dir.create(path.deg1.bars, showWarnings = FALSE, recursive = TRUE);
if (!exists(path.deg2.bars)) dir.create(path.deg2.bars, showWarnings = FALSE, recursive = TRUE);
ids <- c(up=rownames(up), dn=rownames(dn));
names(ids) <- paste(rep(c(path.deg1.bars, path.deg2.bars), c(nrow(up), nrow(dn))), '/', ids, '.pdf', sep='');

col <- rep(c('#16A085BB', '#E74C3CBB'), c(length(g1.ind), length(g2.ind)));
wid <- min(1.8, 8/max(nchar(colnames(expr[, c(g1.ind, g2.ind)]))));
fn.barplot <- sapply(names(ids), function(nm) {
  pdf(nm, w=8, h=6); 
  par(mai=c(1.2, 1, 0.6, 0.2));
  barplot(nrm[ids[nm], c(g1.ind, g2.ind)], las=3, col=col, ylab='Normalized expression', 
          cex.lab=wid, cex.names=0.75*wid);
  title(main=paste(ids[nm], CleanHtmlTags(as.vector(anno[ids[nm], 1])), sep=' - '), cex.main=2);
  #plot.new();
  par(mai=c(1.2, 1.2, 0.6, 0.2));
  barplot(pctl[ids[nm], c(g1.ind, g2.ind)], las=3, col=col, ylab='Percentile (%)', ylim=c(0, 100), cex.lab=2, cex.names=wid);
  title(main=paste(ids[nm], CleanHtmlTags(as.vector(anno[ids[nm], 1])), sep=' - '), cex.main=2);
  
  dev.off();
  nm;
});

# Write index tables of DEGs
cnm <- c(colnames(anno), colnames(up), 'Samples');
ind <- prms$entrez;

xls <- list(All=stat.table);

up.tbl <- data.frame(anno[rownames(up), , drop=FALSE], up, rep('Figure', nrow(up)));
colnames(up.tbl) <- cnm;
xls$Up <- up.tbl;
up.tbl$Samples   <- AddHref(up.tbl$Samples, paste('bars/', rownames(up), '.pdf', sep='')); 
if (ind > 0) up.tbl <- cbind(ID=rownames(up.tbl), 'Entrez_ID'=up.tbl[, ind], up.tbl[, -ind]);
up.formatted     <- GeneList2Datatable(FormatNumeric(up.tbl), fn=paste(path.deg1, 'index.html', sep='/'), 
                                       col.entrez=as.integer(prms$entrez>0), genome=prms$genome, 
                                       title=paste('Genes with higher expression in', g2.name));

dn.tbl <- data.frame(anno[rownames(dn), , drop=FALSE], dn, rep('Figure', nrow(dn)));
colnames(dn.tbl) <- cnm;
xls$Down <- dn.tbl;
dn.tbl$Samples   <- AddHref(dn.tbl$Samples, paste('bars/', rownames(dn), '.pdf', sep='')); 
if (ind > 0) dn.tbl <- cbind(ID=rownames(dn.tbl), 'Entrez_ID'=dn.tbl[, ind], dn.tbl[, -ind]);
dn.formatted     <- GeneList2Datatable(FormatNumeric(dn.tbl), paste(path.deg2, 'index.html', sep='/'), 
                                       col.entrez=as.integer(prms$entrez>0), genome=prms$genome, 
                                       title=paste('Genes with lower expression in', g2.name));
names(xls)[-1] <- deg.sub;
xls <- lapply(xls, function(x) {
  for (i in 1:ncol(x)) x[[i]] <- CleanHtmlTags(x[[i]], FALSE);
  for (i in 1:ncol(stat)) x[, colnames(stat)[i]] <- as.numeric(x[, colnames(stat)[i]]);
  FormatNumeric(x);
}); 
WriteExcel(xls, fileName = paste(path.deg, 'deg', sep='/'));
saveRDS(xls, paste(path.r, 'deg.rds', sep='/'));
```

```{r deg_top, include=TRUE, fig.width=6.4, fig.height=2.4, out.width='640px'}
# Plot top genes
par(mfrow=c(1,2), mai=c(0.7, 0.35, 0.3, 0.05));
ind <- c(rownames(up)[1], rownames(dn)[1]);

cex <- min(0.75, min(0.5/max(strwidth(colnames(nrm), unit='in'))));
col <- rep(c('#2E86C1', '#CB4335'), c(length(g1.ind), length(g2.ind)));
for (ii in 1:2) barplot(nrm[ind[ii], ], las=3, cex.names=cex, main=CleanHtmlTags(anno[ind[ii], 1], FALSE), 
                        cex.main=.75, cex.axis=.75, col=col);
```

<div style="color:darkblue">
`r OrderFigure()` Top-ranked genes with increased (left) and decreased (right) expression in `r g2.name`. Click [here](DEG/all_genes.html) to view differential expression of all genes.
</div>
  
```{r deg_heatmap, include=TRUE, fig.width=6.4, fig.height=6.4, out.width='640px'}
# Plot heatmap of top genes
par(mfrow=c(1,1));
goi <- nrm[c(rownames(up), rownames(dn)), ];
rownames(goi) <- as.vector(anno[rownames(goi), 1]);
DegHeatmap(goi,  col=rep(c('#2E86C1', '#CB4335'), c(length(g1.ind), length(g2.ind))), plot.new=FALSE);
```

<div style="color:darkblue">
`r OrderFigure()` Heatmap of the top `r nrow(up)` and `r nrow(dn)` DEGs with higher (red) and lower (yellow) expression in `r g2.name`. Each row represents a DEG, whose expression measurements are normalized across samples. Samples are clustered by these genes and the columns are colored (blue = `r g1.name` and red = `r g2.name`).
</div>

## View and download results

```{r zip, include=FALSE}
zip(paste(path.fig, 'figure.zip', sep='/'), path.fig, zip = 'zip'); 
zip(paste(path.deg, 'deg.zip', sep='/'), path.deg, zip = 'zip'); 
zip(paste(path.r, 'R.zip', sep='/'), path.r, zip = 'zip'); 
```

<p />

**Click links below to view table or download files:**

  - [Differential expression of all genes](deg/all_genes.html)
    - [`r nrow(up)` DEGs with higher expression in `r g2.name`](`r paste('deg', deg.sub[1], 'index.html', sep='/')`)
    - [`r nrow(dn)` DEGs with lower expression in `r g2.name`](`r paste('deg', deg.sub[2], 'index.html', sep='/')`)

  - **Download:**
    - [DEG tables and figures](deg/deg.zip)
    - [Excel file](deg/deg.xlsx)
    - [Other Figures](figure/figure.zip)
    - [R objects](R/R.zip)

`r home.url` 

***

# Appendix 

Check out the **[RoCA home page](http://zhezhangsh.github.io/RoCA)** for more information.  

## Fold change vs. log(fold change)

The terms to represent differential expression can be used quite confusingly. In this report, **fold change** refers the ratio of two group means in their unlogged form. So a fold change of 2.0 means the average of the second group is increased to twice of the average of the first group; similarly, a fold change of 0.5 means the average is reduced to half. **Log2(fold change)** equals to the log2-transformation of the fold change. The table below gives a few examples of the conversion of these 2 variables. **Log2(fold change)** is more suitable for statistical analysis since it is symmetric around 0. 

<div style="color:darkblue">
**Supplemental Table 1.** Fold Change vs. Log(Fold Change) vs. Percentage Change
</div>
  
```{r fold_change, eval=TRUE, include=TRUE}
c<-c(1.25, 1.5, 2, 4, 8);
fc<-c(1/rev(c), 1, c);
lg<-log2(fc);
pct<-100*(fc-1);
t<-round(cbind(fc, lg, pct), 3);
colnames(t)<-c('Fold change', 'Log2(fold change)', 'Percentage change (%)');


kable(t) %>% kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE); 
```

## Methods and functions

The key steps of statistical analysis in this report use existing R/Bioconductor packages and functions.

<div style="color:darkblue">
**Supplemental Table 2.** R/Bioconductor key functions
</div>
  
```{r biocondductor, include=TRUE}
t<-strsplit(
"Hierarchical clustering\tstats\thclust 
PCA\tstats\tprcomp
Differential expression\tDEGandMore\tDeWrapper
Heatmap\tstats\theatmap
Write Java HTML datatables\tawsomics\tCreateDatatable
Write data to Excel\txlsx\tcreateWorkbook",
'\n')[[1]]; 
t<-do.call('rbind', strsplit(t, '\t'));
colnames(t)<-c('Task', 'R package', 'R function');
kable(t) %>% kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE); 
```

<p />

## References

  - **R:** R Development Core Team, 2011. _R: A Language and Environment for Statistical Computing._ ISBN 3-900051-07-0. [Home page](http://www.R-project.org).
  - **Bioconductor:** Gentleman RC et al., 2004. _Bioconductor: open software development for computational biology and bioinformatics._ Genome Biology. [ Home page](http://www.bioconductor.org).
  - **Biclustering:** Ihmels J, Bergmann S, Barkai N, 2004 _Defining transcription modules using large-scale gene expression data._ Bioinformatics. [Home page](http://www2.unil.ch/cbg/index.php?title=ISA). 
  - **GSEA:** Subramanian A et al. 2005 _Gene set enrichment analysis: A knowledge-based approach for interpreting genome-wide expression profiles_ PNAS. [Home page](http://software.broadinstitute.org/gsea/index.jsp)
  - **[RoCA](http://zhezhangsh.github.io/RoCA)** 
  - **[Awsomics](awsomics.org)**


## Reproduce this report

To reproduce this report: 

  1. Find the data analysis template you want to use and an example of its pairing YAML file  [here](https://github.com/zhezhangsh/RoCA/wiki/Templates-and-examples) and download the YAML example to your working directory

  2. To generate a new report using your own input data and parameter, edit the following items in the YAML file:

    - **output**        : where you want to put the output files
    - **home**          : the URL if you have a home page for your project
    - **analyst**       : your name
    - **description**   : background information about your project, analysis, etc.
    - **input**         : where are your input data, read instruction for preparing them
    - **parameter**     : parameters for this analysis; read instruction about how to prepare input data

  3. Run the code below within ***R Console*** or ***RStudio***, preferablly with a new R session:

```{r reproduce_report, eval=FALSE, echo=TRUE}
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

CreateReport(filename.yaml);  # filename.yaml is the YAML file you just downloaded and edited for your analysis
```

If there is no complaint, go to the _output_ folder and open the ***index.html*** file to view report. 

# Session information

```{r session_info, echo=FALSE}
sessionInfo(); 
```

`r home.url`

***
_END OF DOCUMENT_


