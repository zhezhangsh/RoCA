paste('[', c, '](', f, ')', sep='');
});
dimnames(lnk)<-list(gset.cll, names(ora.s));
names(ora.s)
length(gsea.s)
names(gsea.s)
path.ora<-paste(path, 'ORA', sep='/');
if (!file.exists(path.ora)) dir.create(path.ora, recursive = TRUE);
ora<-lapply(res, function(x) x$ora);
ora.stat<-lapply(ora, function(x) lapply(x[1:2], function(x) x[[1]]));
ora.sets<-lapply(ora.stat, function(x) lapply(x, rownames));
ora.univ<-lapply(ora, function(x) lapply(x[1:2], function(x) rownames(x[[3]])));
ora.univ<-Reduce('union', c(ora.univ[[1]], ora.univ[[2]]));
# Combine stats
ora.n<-lapply(ora, function(o) sapply(o[1:2], function(o) o[[3]][, 'n11'][ora.univ]));
ora.n<-cbind(ora.n[[1]], ora.n[[2]]);
ora.n[is.na(ora.n)]<-0;
rownames(ora.n)<-ora.univ;
colnames(ora.n)<-paste('N', colnames(ora.n), sep='_');
ora.or<-lapply(ora, function(o) sapply(o[1:2], function(o) {
c<-o[[3]];
c<-(c[, 1]/c[, 2])*(c[, 4]/c[, 3]);
c<-c[ora.univ];
c;
}));
ora.or<-cbind(ora.or[[1]], ora.or[[2]]);
ora.or[is.na(ora.or)]<-1;
rownames(ora.or)<-ora.univ;
colnames(ora.or)<-paste('OR', colnames(ora.or), sep='_');
ora.or<-cbind(ora.or[, c(1, 3)], OR_High_Diff=ora.or[, 3]-ora.or[, 1], ora.or[, c(2, 4)], OR_Low_Diff=ora.or[, 4]-ora.or[, 2]);
ora.p<-lapply(ora.stat, function(o) sapply(o, function(o) o[, 'P_HyperGeo'][ora.univ]));
ora.p<-cbind(ora.p[[1]], ora.p[[2]]);
rownames(ora.p)<-ora.univ;
colnames(ora.p)<-paste('P', colnames(ora.p), sep='_');
ora.p[is.na(ora.p)]<-0.5;
ora.p<-cbind(ora.p[, c(1, 3)], P_High_Ratio=ora.p[, 3]/ora.p[, 1], ora.p[, c(2, 4)], P_Low_ratio=ora.p[, 4]/ora.p[, 2]);
ora.tbl<-FormatNumeric(cbind(ora.n, ora.or, ora.p));
ora.tbl<-cbind(gset[[1]][rownames(ora.tbl), ], ora.tbl);
CreateDatatable(ora.tbl, paste(path.tbl, 'ora_table.html', sep='/'), caption='Combined table of ORA statistics');
saveRDS(ora.tbl, paste(path.r, 'ora_stat.rds', sep='/'));
write.csv(ora.tbl, paste(path.tbl, 'ora_stat.csv', sep='/'));
gset.src<-sort(unique(gset[[1]][, 'Source']));
ora.s<-c(ora.stat[[1]], ora.stat[[2]]);
fn.tbl<-lapply(names(ora.s), function(nm) {
s<-ora.s[[nm]];
lapply(gset.src, function(src) {
a<-gset[[1]][rownames(s), ];
a$Name<-AddHref(a$Name, a$URL)
a<-a[, 1:3];
t<-cbind(a[a$Source==src, , drop=FALSE], FormatNumeric(s[a$Source==src, , drop=FALSE]))[, -1];
f<-paste('ORA/', src, '_', nm, '.html', sep='');
CreateDatatable(t, paste(path, f, sep='/'), rownames = FALSE, caption=paste(src, nm, sep=': '));
c<-nrow(t);
names(c)<-f;
c;
});
});
lnk<-sapply(fn.tbl, function(fn) {
c<-as.vector(unlist(fn));
f<-sapply(fn, names);
paste('[', c, '](', f, ')', sep='');
});
lnk<-lnk;
dimnames(lnk)<-list(gset.src, names(ora.s));
path.gsea<-paste(path, 'GSEA', sep='/');
if (!file.exists(path.gsea)) dir.create(path.gsea, recursive = TRUE);
gsea<-lapply(res, function(x) x$gsea);
gsea.stat<-lapply(gsea, function(x) x$stat);
gsea.stat<-lapply(gsea.stat, function(x) {
rownames(x)<-paste(x[[1]], x[[2]], sep=':');
x;
})
gsea.univ<-Reduce('union', lapply(gsea.stat, rownames));
gsea.stat<-lapply(gsea.stat, function(x) x[gsea.univ, ]);
gsea.tbl<-cbind(gsea.stat[[1]][, 1:3], gsea.stat[[1]][gsea.univ, 4:7], gsea.stat[[2]][gsea.univ, 4:7]);
colnames(gsea.tbl)[c(4:6, 8:10)]<-paste(colnames(gsea.tbl)[c(4:6, 8:10)], rep(names(grp), each=3), sep='_');
gsea.tbl<-FormatNumeric(gsea.tbl);
rownames(gsea.tbl)<-1:nrow(gsea.tbl);
CreateDatatable(gsea.tbl, paste(path.tbl, 'gsea_table.html', sep='/'), caption='GSEA statistics');
saveRDS(gsea.tbl, paste(path.r, 'gsea_stat.rds', sep='/'));
write.csv(gsea.tbl, paste(path.tbl, 'gsea_stat.csv', sep='/'));
gsea.st<-lapply(gsea.stat, function(x) split(x[x[, 'PValue']<=0.05, -ncol(x)], x[x[, 'PValue']<=0.05, ncol(x)])[2:1]);
gsea.s<-c(gsea.st[[1]], gsea.st[[2]]);
names(gsea.s)<-names(ora.s);
gset.cll<-sort(unique(unlist(lapply(gsea.s, function(x) x$Collection), use.names=FALSE)));
fn.tbl<-lapply(names(gsea.s), function(nm) {
s<-gsea.s[[nm]];
lapply(gset.cll, function(cll) {
t<-s[s$Collection==cll, , drop=FALSE];
t<-FormatNumeric(t);
f<-paste('GSEA/', cll, '_', nm, '.html', sep='');
CreateDatatable(t, paste(path, f, sep='/'), rownames = FALSE, caption=paste(cll, nm, sep=': '));
c<-nrow(t);
names(c)<-f;
c;
});
});
lnk<-sapply(fn.tbl, function(fn) {
c<-as.vector(unlist(fn));
f<-sapply(fn, names);
paste('[', c, '](', f, ')', sep='');
});
dimnames(lnk)<-list(gset.cll, names(ora.s));
CreateReport('summarize_two.yaml')
path.cl<-paste(path, 'CLUSTER', sep='/');
if (!file.exists(path.cl)) dir.create(path.cl, recursive = TRUE);
# normalize data
d1 <- lapply(res, function(x) {
y<-x$inputs;
y$expr[, unlist(y$comparison)];
});
sapply(d1, dim)
x<-paov[order(paov[, 3]), ];
x<-x[x[,3]<=prms$geneset$cluster$panova, , drop=FALSE];
d0<-d1[rownames(d1) %in% rownames(x), ];
d0<-d0[1:min(nrow(d0), prms$geneset$cluster$top), , drop=FALSE];
dim(x)
prms$geneset$cluster$panova
x<-x[x[,3]<=prms$geneset$cluster$panova, , drop=FALSE];
dim(x)
d0<-d1[rownames(d1) %in% rownames(x), ];
dim(d1)
d1 <- lapply(res, function(x) {
y<-x$inputs;
y$expr[, unlist(y$comparison)];
});
gs<-Reduce('intersect', lapply(d1, rownames));
d1 <- do.call('cbind', d1);
d1<-do.call('cbind', lapply(d1, function(x) x[gs, , drop=FALSE]));
if (!prms$gene$processing$logged) d1 <- log2(d1+1);
if (!prms$gene$processing$normalized) d1 <- NormLoess(d1+1);
for (i in 1:3) {
y <- res[[i]]$inputs$comparison;
d1[, unlist(y)] <- d1[, unlist(y)] - rowMeans(d1[, y[[1]]]);
d1[, unlist(y)] <- t(apply(d1[, unlist(y)], 1, function(x) x/sd(x)));
}
d1 <- lapply(res, function(x) {
y<-x$inputs;
y$expr[, unlist(y$comparison)];
});
gs<-Reduce('intersect', lapply(d1, rownames));
d1 <- do.call('cbind', d1);
d1<-do.call('cbind', lapply(d1, function(x) x[gs, , drop=FALSE]));
length(gs)
head(gs)
dim(d1[[1]])
dim(d1)
length(gs[is.na(gs)])
lapply(d1, function(x) x[gs, , drop=FALSE])-> a
dim(d1[[1]])
d1 <- lapply(res, function(x) {
y<-x$inputs;
y$expr[, unlist(y$comparison)];
});
gs<-Reduce('intersect', lapply(d1, rownames));
d1<-do.call('cbind', lapply(d1, function(x) x[gs, , drop=FALSE]));
if (!prms$gene$processing$logged) d1 <- log2(d1+1);
if (!prms$gene$processing$normalized) d1 <- NormLoess(d1+1);
for (i in 1:3) {
y <- res[[i]]$inputs$comparison;
d1[, unlist(y)] <- d1[, unlist(y)] - rowMeans(d1[, y[[1]]]);
d1[, unlist(y)] <- t(apply(d1[, unlist(y)], 1, function(x) x/sd(x)));
}
# select seeds
x<-paov[order(paov[, 3]), ];
x<-x[x[,3]<=prms$geneset$cluster$panova, , drop=FALSE];
d0<-d1[rownames(d1) %in% rownames(x), ];
d0<-d0[1:min(nrow(d0), prms$geneset$cluster$top), , drop=FALSE];
dim(d0)
comp
grp[[i]]
grp
d1 <- lapply(res, function(x) {
y<-x$inputs;
y$expr[, unlist(y$comparison)];
});
gs <- Reduce('intersect', lapply(d1, rownames));
d1 <- do.call('cbind', lapply(d1, function(x) x[gs, , drop=FALSE]));
if (!prms$gene$processing$logged) d1 <- log2(d1+1);
if (!prms$gene$processing$normalized) d1 <- NormLoess(d1+1);
for (i in 1:2) {
y <- res[[i]]$inputs$comparison;
d1[, unlist(y)] <- d1[, unlist(y)] - rowMeans(d1[, y[[1]]]);
d1[, unlist(y)] <- t(apply(d1[, unlist(y)], 1, function(x) x/sd(x)));
}
# select seeds
x <- paov[order(paov[, 3]), ];
x <- x[x[,3]<=prms$geneset$cluster$panova, , drop=FALSE];
d0 <- d1[rownames(d1) %in% rownames(x), ];
d0 <- d0[1:min(nrow(d0), prms$geneset$cluster$top), , drop=FALSE];
# merge similar clusters
flag<-TRUE;
while(flag) {
cat('Number of clusters ', length(cl), '\n');
ms<-sapply(cl, function(cl) colMeans(d0[cl, ]));
tr<-cutree(hclust(as.dist(1-cor(ms))), k=length(cl)-1); # find the 2 most similar clusters
i<-tr[duplicated(tr)];
c<-ms[, tr==i];
r<-cor(c[, 1], c[, 2]);
p<-cor.test(c[, 1], c[, 2])$p.value[[1]];
if (r>yml$input$geneset$cluster$merge$corr & p<yml$input$geneset$cluster$merge$p) {
cl[tr==i][[1]]<-as.vector(unlist(cl[tr==i]));
cl<-cl[names(cl)!=names(i)];
} else flag<-FALSE;
}
# Sort clusters
m<-sapply(cl, function(cl) colMeans(d1[cl, ]));
ind<-apply(m, 2, function(x) which(x==max(x)));
cl<-cl[order(ind)];
names(cl)<-paste('Cluster', 1:length(cl), sep='_');
flag<-TRUE;
while(flag) {
cat('Number of clusters ', length(cl), '\n');
ms<-sapply(cl, function(cl) colMeans(d0[cl, ]));
tr<-cutree(hclust(as.dist(1-cor(ms))), k=length(cl)-1); # find the 2 most similar clusters
i<-tr[duplicated(tr)];
c<-ms[, tr==i];
r<-cor(c[, 1], c[, 2]);
p<-cor.test(c[, 1], c[, 2])$p.value[[1]];
if (r>yml$input$geneset$cluster$merge$corr & p<yml$input$geneset$cluster$merge$p) {
cl[tr==i][[1]]<-as.vector(unlist(cl[tr==i]));
cl<-cl[names(cl)!=names(i)];
} else flag<-FALSE;
}
# merge similar clusters
flag<-TRUE;
while(flag) {
cat('Number of clusters ', length(cl), '\n');
ms<-sapply(cl, function(cl) colMeans(d0[cl, ]));
tr<-cutree(hclust(as.dist(1-cor(ms))), k=length(cl)-1); # find the 2 most similar clusters
i<-tr[duplicated(tr)];
c<-ms[, tr==i];
r<-cor(c[, 1], c[, 2]);
p<-cor.test(c[, 1], c[, 2])$p.value[[1]];
if (r>prms$geneset$cluster$merge$corr & p<prms$geneset$cluster$merge$p) {
cl[tr==i][[1]]<-as.vector(unlist(cl[tr==i]));
cl<-cl[names(cl)!=names(i)];
} else flag<-FALSE;
}
hc<-hclust(as.dist(1-cor(t(d0))));
cl<-cutree(hc, k=prms$geneset$cluster$seed);
cl<-split(names(cl), cl);
# merge similar clusters
flag<-TRUE;
while(flag) {
cat('Number of clusters ', length(cl), '\n');
ms<-sapply(cl, function(cl) colMeans(d0[cl, ]));
tr<-cutree(hclust(as.dist(1-cor(ms))), k=length(cl)-1); # find the 2 most similar clusters
i<-tr[duplicated(tr)];
c<-ms[, tr==i];
r<-cor(c[, 1], c[, 2]);
p<-cor.test(c[, 1], c[, 2])$p.value[[1]];
if (r>prms$geneset$cluster$merge$corr & p<prms$geneset$cluster$merge$p) {
cl[tr==i][[1]]<-as.vector(unlist(cl[tr==i]));
cl<-cl[names(cl)!=names(i)];
} else flag<-FALSE;
}
# Sort clusters
m<-sapply(cl, function(cl) colMeans(d1[cl, ]));
ind<-apply(m, 2, function(x) which(x==max(x)));
cl<-cl[order(ind)];
names(cl)<-paste('Cluster', 1:length(cl), sep='_');
hc<-hclust(as.dist(1-cor(t(d0))));
cl<-cutree(hc, k=prms$geneset$cluster$seed);
cl<-split(names(cl), cl);
# merge similar clusters
flag<-TRUE;
while(flag) {
cat('Number of clusters ', length(cl), '\n');
ms<-sapply(cl, function(cl) colMeans(d0[cl, ]));
tr<-cutree(hclust(as.dist(1-cor(ms))), k=length(cl)-1); # find the 2 most similar clusters
i<-tr[duplicated(tr)];
c<-ms[, tr==i];
r<-cor(c[, 1], c[, 2]);
p<-cor.test(c[, 1], c[, 2])$p.value[[1]];
if (r>prms$geneset$cluster$merge$corr & p<prms$geneset$cluster$merge$p) {
cl[tr==i][[1]]<-as.vector(unlist(cl[tr==i]));
cl<-cl[names(cl)!=names(i)];
} else flag<-FALSE;
}
# Sort clusters
m<-sapply(cl, function(cl) colMeans(d1[cl, ]));
ind<-apply(m, 2, function(x) which(x==max(x)));
cl<-cl[order(ind)];
names(cl)<-paste('Cluster', 1:length(cl), sep='_');
# re-cluster genes
reCl<-function(d, cl, r, dif, nmax) {
d <- d[!is.na(rowMeans(d)), , drop=FALSE];
cl <- lapply(cl, function(cl) cl[cl %in% rownames(d)]);
md<-sapply(cl, function(cl) apply(d[cl[cl %in% rownames(d)], , drop=FALSE], 2, median));
corr<-cor(t(d), md);
c<-lapply(1:ncol(corr), function(i) {
corr<-corr[rev(order(corr[, i])), ];
mx<-apply(corr[, -i, drop=FALSE], 1, max);
id<-rownames(corr)[corr[, i]>=r & (corr[, i]-mx)>dif];
id[1:min(length(id), nmax)];
});
c;
}
for (i in 1:prms$geneset$cluster$recluster$time)
cl<-reCl(d0, cl, prms$geneset$cluster$recluster$corr, prms$geneset$cluster$recluster$diff, prms$geneset$cluster$recluster$nmax);
str(cl)
cls<-reCl(d1, cl, prms$geneset$cluster$recluster$corr, prms$geneset$cluster$recluster$diff);
cls<-reCl(d1, cl, prms$geneset$cluster$recluster$corr, prms$geneset$cluster$recluster$diff, prms$geneset$cluster$recluster$nmax);
str(cls)
ms<-t(sapply(cls, function(x) colMeans(d1[x, ])));
rownames(ms)<-names(cls)<-paste('Cluster', 1:length(cls), sep='_');
fn.htmp<-sapply(names(cls), function(nm) {
x<-d1[cls[[nm]], ];
f<-paste(path.cl, '/Heatmap_', nm, '.pdf', sep='');
sz<-CalculateColoredBlockSize(x);
pdf(f, width = max(sz[2]/3, sz[1]), height = sz[2]);
PlotColoredBlock(x, num.breaks = 31, key = 'Normalized expression', groups = grps);
dev.off();
f;
});
saveRDS(list(cluster=cls, data=d1), file=paste(path.r, 'cluster.rds', sep='/'));
dim(d0)
fn.tbl<-lapply(names(cls), function(nm) {
cl<-cls[[nm]];
s<-TestGSE(cl, gid, gset[[2]])[[1]];
t<-gset[[1]][rownames(s), ];
t$Name<-AddHref(t$Name, t$URL);
t<-cbind(t[, 1:3], FormatNumeric(s));
f<-paste('CLUSTER/ORA_', nm, '.html', sep='');
CreateDatatable(t, paste(path, f, sep='/'), rownames=FALSE, caption=paste('Over-represented gene set in', nm));
c<-nrow(t);
names(c)<-f;
t<-do.call('cbind', lapply(stat, function(s) s[cl, c(1, 2, 4, 5, 6)]));
t<-FormatNumeric(t);
colnames(t)[c(3,4,5,8,9,10)]<-paste(colnames(t)[c(3,4,5,8,9,10)], rep(names(grp), each=3), sep='_');
t<-data.frame(anno[rownames(t), ], t, stringsAsFactors = FALSE);
CreateDatatable(t, paste(path.cl, '/', nm, '.html', sep=''), caption=nm);
c;
});
names(cls)
mm<-round(sapply(grps, function(x) rowMeans(ms[, x, drop=FALSE])), 4);
n<-as.vector(unlist(fn.tbl));
sz<-sapply(cls, length);
lnk<-paste('[', n, '](', sapply(fn.tbl, names), ')', sep='');
cl.tbl<-data.frame(Size=sz, mm, Gene_set=lnk, stringsAsFactors = FALSE);
cl.tbl[, 1]<-paste('[', sz, '](CLUSTER/', names(cls), '.html)', sep='');
cl.tbl<-cbind(ID=rownames(cl.tbl), cl.tbl);
cl.tbl[, 1]<-paste('[', cl.tbl[, 1], '](CLUSTER/Heatmap_', names(cls), '.pdf)', sep='');
dim(cl.tbl)
cl.tbl
`r kable(cl.tbl, row.names=FALSE, align='c')`
kable(cl.tbl, row.names=FALSE, align='c')
cl.tbl<-data.frame(Size=sz, mm, Gene_set=lnk, stringsAsFactors = FALSE);
cl.tbl[, 1]<-paste('[', sz, '](CLUSTER/', names(cls), '.html)', sep='');
cl.tbl<-cbind(ID=rownames(cl.tbl), cl.tbl);
cl.tbl
mm
cl.tbl<-data.frame(Size=sz, mm, Gene_set=lnk, stringsAsFactors = FALSE);
cl.tbl[, 1]<-paste('[', sz, '](CLUSTER/', names(cls), '.html)', sep='');
cl.tbl<-cbind(ID=rownames(cl.tbl), cl.tbl);
cl.tbl[, 1]<-paste('[', cl.tbl[, 1], '](CLUSTER/Heatmap_', names(cls), '.pdf)', sep='');
cl.tbl
mm<-round(sapply(grps, function(x) rowMeans(ms[, x, drop=FALSE])), 4);
mm
colnames(cl.tbl)
paste(rep(comp, each=2), unlist(grp), sep='::')
names(ora.s)
names(ora.s) <- paste(rep(comp, each=2), unlist(grp), sep='::');
names(ora.s)
gset.src
gset.cll
ol
paste(names(ora.stat[[1]])[i[1]], names(ora.stat[[2]])[i[2]], sep=' and ')
nm <- rownames(ind)[1]
nm
ind
ol<-sapply(rownames(ind), function(nm) {
i<-ind[nm, ];
g<-intersect(ora.sets[[1]][[i[1]]], ora.sets[[2]][[i[2]]]);
f<-paste('ORA/', 'ora_', nm, '.html', sep='');
c <- paste(paste(comp, c(names(deg1)[i[1]], names(deg2)[i[2]]), sep='::'), collapse=' and ')
#c<-paste(names(ora.stat[[1]])[i[1]], names(ora.stat[[2]])[i[2]], sep=' and ');
t<-gset[[1]][g, ];
t$Name<-AddHref(t$Name, t$URL);
t<-t[, 1:3];
t<-cbind(t, ora.stat[[1]][[i[1]]][g, c(2, 4, 5, 6)], ora.stat[[2]][[i[2]]][g, c(2, 4, 5, 6)]);
colnames(t)[4:11]<-paste(colnames(t)[4:11], rep(names(grp), each=4), sep='_');
fn<-CreateDatatable(t, paste(path, f, sep='/'), rownames = FALSE, caption=c);
list(c, f);
});
ol
ind<-cbind(c(1, 1, 2, 2), c(1, 2, 1, 2));
rownames(ind)<-c('up-up', 'up-down', 'down-up', 'down-down');
par(mfrow=c(2,2));
apply(ind, 1, function(i) PlotVenn(ora.sets[[1]][[i[1]]], ora.sets[[2]][[i[2]]], c(names(ora.sets[[1]])[i[1]], names(ora.sets[[2]])[i[2]]), u=ora.univ))->vnn;
ol<-sapply(rownames(ind), function(nm) {
i<-ind[nm, ];
g<-intersect(ora.sets[[1]][[i[1]]], ora.sets[[2]][[i[2]]]);
f<-paste('ORA/', 'ora_', nm, '.html', sep='');
c <- paste(paste(comp, c(names(deg1)[i[1]], names(deg2)[i[2]]), sep='::'), collapse=' and ')
#c<-paste(names(ora.stat[[1]])[i[1]], names(ora.stat[[2]])[i[2]], sep=' and ');
t<-gset[[1]][g, ];
t$Name<-AddHref(t$Name, t$URL);
t<-t[, 1:3];
t<-cbind(t, ora.stat[[1]][[i[1]]][g, c(2, 4, 5, 6)], ora.stat[[2]][[i[2]]][g, c(2, 4, 5, 6)]);
colnames(t)[4:11]<-paste(colnames(t)[4:11], rep(names(grp), each=4), sep='_');
fn<-CreateDatatable(t, paste(path, f, sep='/'), rownames = FALSE, caption=c);
list(c, f);
});
ol
ol<-sapply(rownames(ind), function(nm) {
i<-ind[nm, ];
g<-intersect(gsea.st[[1]][[i[1]]], gsea.st[[2]][[i[2]]]);
f<-paste('GSEA/', 'gsea_', nm, '.html', sep='');
c <- paste(paste(comp, c(names(deg1)[i[1]], names(deg2)[i[2]]), sep='::'), collapse=' and ')
t<-gsea.stat[[1]][g, 1:3];
t<-t[, 1:3];
t<-cbind(t, gsea.stat[[1]][g, c(4, 5, 6)], gsea.stat[[2]][g, c(4, 5, 6)]);
colnames(t)[4:9]<-paste(colnames(t)[4:9], rep(names(grp), each=3), sep='_');
fn<-CreateDatatable(FormatNumeric(t), paste(path, f, sep='/'), rownames=FALSE, caption=c);
list(c, f);
});
gsea.st<-lapply(gsea.s, rownames);
gsea.st<-list(gsea.st[1:2], gsea.st[3:4]);
names(gsea.st)<-names(grp);
names(gsea.st[[1]])<-names(ora.sets[[1]]);
names(gsea.st[[2]])<-names(ora.sets[[2]]);
ind<-cbind(c(1, 1, 2, 2), c(1, 2, 1, 2));
rownames(ind)<-c('up-up', 'up-down', 'down-up', 'down-down');
par(mfrow=c(2,2));
apply(ind, 1, function(i) PlotVenn(gsea.st[[1]][[i[1]]], gsea.st[[2]][[i[2]]], c(names(gsea.st[[1]])[i[1]], names(gsea.st[[2]])[i[2]]), u=gsea.univ))->vnn;
ol<-sapply(rownames(ind), function(nm) {
i<-ind[nm, ];
g<-intersect(gsea.st[[1]][[i[1]]], gsea.st[[2]][[i[2]]]);
f<-paste('GSEA/', 'gsea_', nm, '.html', sep='');
c <- paste(paste(comp, c(names(deg1)[i[1]], names(deg2)[i[2]]), sep='::'), collapse=' and ')
t<-gsea.stat[[1]][g, 1:3];
t<-t[, 1:3];
t<-cbind(t, gsea.stat[[1]][g, c(4, 5, 6)], gsea.stat[[2]][g, c(4, 5, 6)]);
colnames(t)[4:9]<-paste(colnames(t)[4:9], rep(names(grp), each=3), sep='_');
fn<-CreateDatatable(FormatNumeric(t), paste(path, f, sep='/'), rownames=FALSE, caption=c);
list(c, f);
});
lns<-paste('  - [', ol[1, ], ']', sep='');
lns<-paste(lns, '(', ol[2, ], ')', sep='');
lns<-paste(lns, collapse='\n');
lns
ol
CreateReport('summarize_two.yaml')
setwd('../summarize_three/')
CreateReport('summarize_three.yaml')
CreateReport('summarize_three.yaml')
CreateReport('summarize_three.yaml')
CreateReport('summarize_three.yaml')
setwd('../summarize_two/')
ls()
rm(list=ls())
dir()
setwd('../summarize_three/')
dir()
name.yaml <- 'summarize_three.yaml';
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'MASS', 'gplots', 'scatterplot3d',
'VennDiagram', 'RoCA', 'rchive', 'DEGandMore');
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table');
knitr::opts_chunk$set(eval=TRUE, dpi=300, fig.pos="H", fig.width=8, fig.height=6, echo=FALSE, warning=FALSE, message=FALSE, fig.path='FIGURE/');
## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }
## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));
## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template
prms <- yml$parameter;
## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]);
## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
yml$input$comparison <- lapply(yml$input$comparison, function(c) {
if (is.list(c)) c else {
if (is.character(c) & dir.exists(c[1]))
list(result=paste(c, 'R/result.rds', sep='/'), index=paste(c, 'index.html', sep='/')) else
stop('Error: comparison results not found\n');
}
})
nm <- names(yml$input$comparison)[1]
nm
f <- yml$input$comparison[[nm]];
f
f$result
DownloadFile(f$result, path.input))
DownloadFile(f$result, path.input)
fn0 <- DownloadFile(f$result, path.input);
res <- lapply(names(yml$input$comparison), function(nm) {
f <- yml$input$comparison[[nm]];
fn0 <- DownloadFile(f$result, path.input);
fn1 <- sub('result.rds$', paste(nm, '.rds', sep=''), fn0);
if (fn1 != fn0) file.rename(fn0, fn1);
ImportR(fn1);
}
res <- lapply(names(yml$input$comparison), function(nm) {
f <- yml$input$comparison[[nm]];
fn0 <- DownloadFile(f$result, path.input);
fn1 <- sub('result.rds$', paste(nm, '.rds', sep=''), fn0);
if (fn1 != fn0) file.rename(fn0, fn1);
ImportR(fn1);
});
