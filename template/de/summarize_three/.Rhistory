ora.p.lo, P_Low_Range=apply(ora.p.lo, 1, function(x) min(x)/max(x)));
ora.tbl<-FormatNumeric(cbind(ora.n, ora.or, ora.p));
ora.tbl<-cbind(gset[[1]][rownames(ora.tbl), ], ora.tbl);
ora.tbl$Name<-AddHref(ora.tbl$Name, ora.tbl$URL);
ora.tbl<-ora.tbl[, -5];
dim(ora.tbl)
head(ora.tbl)
ora.stat<-lapply(ora, function(x) lapply(x[1:2], function(x) x[[1]]));
ora.sets<-lapply(ora.stat, function(x) lapply(x, rownames));
ora.univ<-lapply(ora, function(x) lapply(x[1:2], function(x) rownames(x[[3]])));
ora.univ<-Reduce('union', c(ora.univ[[1]], ora.univ[[2]]));
ora.n<-lapply(ora, function(o) sapply(o[1:2], function(o) o[[3]][, 'n11'][ora.univ]));
ora.n<-do.call('cbind', ora.n);
ora.n[is.na(ora.n)]<-0;
rownames(ora.n)<-ora.univ;
colnames(ora.n)<-paste('N', colnames(ora.n), sep='_');
dim(ora.n)
head(ora.n)
dim(ora.n)
ora.or<-lapply(ora, function(o) sapply(o[1:2], function(o) {
c<-o[[3]];
c<-(c[, 1]/c[, 2])*(c[, 4]/c[, 3]);
c<-c[ora.univ];
c;
}));
dim(ora.or)
str(ora.or)
head(ora.or[[1]])
ora.or<-do.call('cbind', ora.or);
ora.or[is.na(ora.or)]<-1;
head(ora.or)
summary(ora.or[, 1])
rownames(ora.or)<-ora.univ;
colnames(ora.or)<-paste('OR', colnames(ora.or), sep='_');
head(ora.or)
ora.or.hi<-ora.or[, seq(1, ncol(ora.or), 2)];
ora.or.lo<-ora.or[, seq(2, ncol(ora.or), 2)];
head(ora.or.hi)
ora.or<-cbind(ora.or.hi, OR_High_Range=apply(ora.or.hi, 1, function(x) max(x)-min(x)),
ora.or.lo, OR_Low_Range=apply(ora.or.lo, 1, function(x) max(x)-min(x)));
dim(ora.or)
head(ora.or)
ora.p<-lapply(ora.stat, function(o) sapply(o, function(o) o[, 'P_HyperGeo'][ora.univ]));
ora.p<-do.call('cbind', ora.p);
dim(ora.p)
head(ora.p)
o <- ora.stat[[1]]
dim(o)
str(o)
head(o[[1]])
length(ora.univ)
head(ora.univ)
ora.p<-lapply(ora.stat, function(o) sapply(o, function(o) o[, 'P_HyperGeo'][ora.univ]));
ora.p<-do.call('cbind', ora.p);
rownames(ora.p)<-ora.univ;
head(ora.p)
ora.p[is.na(ora.p)]<-0.5;
ora.p.hi<-ora.p[, seq(1, ncol(ora.p), 2)];
ora.p.lo<-ora.p[, seq(2, ncol(ora.p), 2)];
ora.p<-cbind(ora.p.hi, P_High_Range=apply(ora.p.hi, 1, function(x) min(x)/max(x)),
ora.p.lo, P_Low_Range=apply(ora.p.lo, 1, function(x) min(x)/max(x)));
head(ora.p)
ora.tbl<-FormatNumeric(cbind(ora.n, ora.or, ora.p));
ora.tbl<-cbind(gset[[1]][rownames(ora.tbl), ], ora.tbl);
ora.tbl$Name<-AddHref(ora.tbl$Name, ora.tbl$URL);
ora.tbl<-ora.tbl[, -5];
head(ora.tbl)
dim(ora.tbl)
head(ora.tbl)
ora.tbl<-FormatNumeric(cbind(ora.n, ora.or, ora.p));
head(ora.tbl)
length(gset)
dim(gset[[1]])
dir()
gset <- readRDS('human.rds')
dim(gset[[1]])
dim(ora.n)
path.ora<-paste(path, 'ORA', sep='/');
if (!file.exists(path.ora)) dir.create(path.ora, recursive = TRUE);
ora.stat<-lapply(ora, function(x) lapply(x[1:2], function(x) x[[1]]));
ora.sets<-lapply(ora.stat, function(x) lapply(x, rownames));
ora.univ<-lapply(ora, function(x) lapply(x[1:2], function(x) rownames(x[[3]])));
ora.univ<-Reduce('union', c(ora.univ[[1]], ora.univ[[2]]));
ora.n<-lapply(ora, function(o) sapply(o[1:2], function(o) o[[3]][, 'n11'][ora.univ]));
ora.n<-do.call('cbind', ora.n);
ora.n[is.na(ora.n)]<-0;
rownames(ora.n)<-ora.univ;
colnames(ora.n)<-paste('N', colnames(ora.n), sep='_');
ora.or<-lapply(ora, function(o) sapply(o[1:2], function(o) {
c<-o[[3]];
c<-(c[, 1]/c[, 2])*(c[, 4]/c[, 3]);
c<-c[ora.univ];
c;
}));
ora.or<-do.call('cbind', ora.or);
ora.or[is.na(ora.or)]<-1;
rownames(ora.or)<-ora.univ;
colnames(ora.or)<-paste('OR', colnames(ora.or), sep='_');
ora.or.hi<-ora.or[, seq(1, ncol(ora.or), 2)];
ora.or.lo<-ora.or[, seq(2, ncol(ora.or), 2)];
ora.or<-cbind(ora.or.hi, OR_High_Range=apply(ora.or.hi, 1, function(x) max(x)-min(x)),
ora.or.lo, OR_Low_Range=apply(ora.or.lo, 1, function(x) max(x)-min(x)));
ora.p<-lapply(ora.stat, function(o) sapply(o, function(o) o[, 'P_HyperGeo'][ora.univ]));
ora.p<-do.call('cbind', ora.p);
rownames(ora.p)<-ora.univ;
colnames(ora.p)<-paste('P', colnames(ora.p), sep='_');
ora.p[is.na(ora.p)]<-0.5;
ora.p.hi<-ora.p[, seq(1, ncol(ora.p), 2)];
ora.p.lo<-ora.p[, seq(2, ncol(ora.p), 2)];
ora.p<-cbind(ora.p.hi, P_High_Range=apply(ora.p.hi, 1, function(x) min(x)/max(x)),
ora.p.lo, P_Low_Range=apply(ora.p.lo, 1, function(x) min(x)/max(x)));
ora.tbl<-FormatNumeric(cbind(ora.n, ora.or, ora.p));
ora.tbl<-cbind(gset[[1]][rownames(ora.tbl), ], ora.tbl);
ora.tbl$Name<-AddHref(ora.tbl$Name, ora.tbl$URL);
ora.tbl<-ora.tbl[, -5];
CreateDatatable(ora.tbl, paste(path, 'ora_table.html', sep='/'), caption='Combined table of ORA statistics');
saveRDS(ora.tbl, paste(path.r, 'ora_stat.rds', sep='/'));
write.csv(ora.tbl, paste(path.tbl, 'ora_stat.csv', sep='/'));
# split significant gene sets into subgroups by sources
gset.src<-sort(unique(gset[[1]][, 'Source']));
ora.s<-do.call('c', ora.stat);
fn.tbl<-lapply(names(ora.s), function(nm) {
s<-ora.s[[nm]];
lapply(gset.src, function(src) {
a<-gset[[1]][rownames(s), ];
a$Name<-AddHref(a$Name, a$URL)
a<-a[, 1:3];
t<-cbind(a[a$Source==src, , drop=FALSE], FormatNumeric(s[a$Source==src, , drop=FALSE]))[, -1];
f<-paste('ORA/', src, '_', nm, '.html', sep='');
CreateDatatable(t, paste(path, f, sep='/'), rownames = FALSE, caption=paste(src, nm, sep=': '));
c<-nrow(t);
names(c)<-f;
c;
});
});
lnk<-sapply(fn.tbl, function(fn) {
c<-as.vector(unlist(fn));
f<-sapply(fn, names);
paste('[', c, '](', f, ')', sep='');
});
dimnames(lnk)<-list(gset.src, names(ora.s));
lnk
ora.up<-lapply(ora.sets, function(x) x[[1]]);
ora.dn<-lapply(ora.sets, function(x) x[[2]]);
ora.all<-list(up=ora.up, down=ora.dn);
fn.tbl<-lapply(names(ora.all), function(nm) {
gs<-ora.all[[nm]];
x<-c('up'='Higher', 'down'='Lower');
sapply(1:3, function(i) {
c<-comp[c(ind1[i], ind2[i])];
g<-intersect(gs[[ind1[i]]], gs[[ind2[i]]]);
t<-ora.tbl[g, c(1:4, grep(x[nm], colnames(ora.tbl))), drop=FALSE];
f<-paste(paste(nm, c[1], c[2], sep='_'), '.html', sep='');
CreateDatatable(t, paste(path.ora, f, sep='/'), caption=paste(nm, ', ', c[1], ' and ', c[2], sep=''));
names(f)<-paste(c, collapse=' and ');
f;
})
});
ora.up3<-Reduce('intersect', ora.up);
ora.dn3<-Reduce('intersect', ora.dn);
CreateDatatable(ora.tbl[ora.up3, c(1:4, grep('Higher', colnames(ora.tbl))), drop=FALSE], paste(path.ora, 'up_all3.html', sep='/'), caption='Gene sets up-regulated in all 3 comparisons')->f;
CreateDatatable(ora.tbl[ora.dn3, c(1:4, grep('Lower', colnames(ora.tbl))), drop=FALSE], paste(path.ora, 'down_all3.html', sep='/'), caption='Gene sets down-regulated in all 3 comparisons')->f;
lns<-sapply(fn.tbl, function(f) {
l<-paste('  - [', names(f), '](', paste('ORA', f, sep='/'), ')', sep='');
paste(l, collapse='\n');
})
lns.up<-paste(' - [All 3 comparisons](ORA/up_all3.html)', lns[[1]], sep='\n');
lns.dn<-paste(' - [All 3 comparisons](ORA/down_all3.html)', lns[[2]], sep='\n');
path.gsea<-paste(path, 'GSEA', sep='/');
if (!file.exists(path.gsea)) dir.create(path.gsea, recursive = TRUE);
gsea.stat<-lapply(gsea, function(x) x$stat);
gsea.stat<-lapply(gsea.stat, function(x) {
rownames(x)<-paste(x[[1]], x[[2]], sep=':');
x;
})
gsea.univ<-Reduce('union', lapply(gsea.stat, rownames));
gsea.stat<-lapply(gsea.stat, function(x) x[gsea.univ, ]);
for (i in 1:length(gsea.stat)) rownames(gsea.stat[[i]])<-gsea.univ;
x<-sapply(1:length(gsea.stat), function(i) 1-as.numeric(is.na(gsea.stat[[i]][, 1])));
y<-max.col(x, 'first');
gsea.anno<-lapply(1:3, function(i) gsea.stat[[i]][y==i, 1:3, drop=FALSE]);
gsea.anno<-do.call('rbind', gsea.anno)[gsea.univ, ];
dim(gsea.anno)
head(gsea.anno)
gsea.tbl<-FormatNumeric(do.call('cbind', lapply(gsea.stat, function(x) x[, 4:6])));
gsea.tbl<-cbind(gsea.anno, gsea.tbl);
colnames(gsea.tbl)[4:ncol(gsea.tbl)]<-paste(unlist(lapply(gsea.stat, function(x) colnames(x)[4:6]), use.names=FALSE), rep(names(grp), each=3), sep='_');
CreateDatatable(gsea.tbl, paste(path, 'gsea_table.html', sep='/'), rownames = FALSE, caption='GSEA statistics');
dim(gsea.tbl)
gsea.tbl[1, ]
saveRDS(gsea.tbl, paste(path.r, 'gsea_stat.rds', sep='/'));
write.csv(gsea.tbl, paste(path.tbl, 'gsea_stat.csv', sep='/'));
gsea.sets<-lapply(gsea.stat, function(x) split(x[x[, 'PValue']<=0.05, -ncol(x)], x[x[, 'PValue']<=0.05, ncol(x)])[2:1]);
gsea.s<-do.call('c', gsea.sets);
names(gsea.s)<-names(ora.s);
gset.cll<-sort(unique(unlist(lapply(gsea.s, function(x) x$Collection), use.names=FALSE)));
fn.tbl<-lapply(names(gsea.s), function(nm) {
s<-gsea.s[[nm]];
lapply(gset.cll, function(cll) {
t<-s[s$Collection==cll, , drop=FALSE];
t<-FormatNumeric(t);
f<-paste('GSEA/', cll, '_', nm, '.html', sep='');
CreateDatatable(t, paste(path, f, sep='/'), rownames = FALSE, caption=paste(cll, nm, sep=': '));
c<-nrow(t);
names(c)<-f;
c;
});
});
lnk<-sapply(fn.tbl, function(fn) {
c<-as.vector(unlist(fn));
f<-sapply(fn, names);
paste('[', c, '](', f, ')', sep='');
});
dimnames(lnk)<-list(gset.cll, names(ora.s));
lnk
gsea.nes<-sapply(gsea.stat, function(x) x[, 'NES']);
gsea.nes[is.na(gsea.nes)]<-0;
gsea.p<-sapply(gsea.stat, function(x) x[, 'PValue']);
gsea.p[is.na(gsea.p)]<-1;
corr<-round(sapply(1:3, function(i) cor(gsea.nes[, ind1[i]], gsea.nes[, ind2[i]])), 3);
lns<-paste('  - Corr(', comp[ind1], ':', comp[ind2], ') = ', corr, sep='');
lns<-paste(lns, collapse='\n');
dim(lnk)
lnk[1, ]
path.cl<-paste(path, 'CLUSTER', sep='/');
if (!file.exists(path.cl)) dir.create(path.cl, recursive = TRUE);
# normalize data
d1<-lapply(res, function(x) {
y<-x$input;
z<-y$expr[, unlist(y$comparison)];
z-rowMeans(z[, y$comparison[[1]]])
});
gs<-Reduce('intersect', lapply(d1, rownames));
d1<-do.call('cbind', lapply(d1, function(x) x[gs, , drop=FALSE]));
d1<-t(apply(d1, 1, function(x) x/sd(x)));
dim(d1)
head(d1)
x<-paov[order(paov[, 3]), ];
x<-x[x[,3]<=prms$geneset$cluster$panova, , drop=FALSE];
d0<-d1[rownames(d1) %in% rownames(x), ];
d0<-d0[1: min(nrow(d0), prms$geneset$cluster$top), , drop=FALSE];
# initiate clusters
hc<-hclust(as.dist(1-cor(t(d0))));
cl<-cutree(hc, k=prms$geneset$cluster$seed);
cl<-split(names(cl), cl);
flag<-TRUE;
while(flag) {
cat('Number of clusters ', length(cl), '\n');
ms<-sapply(cl, function(cl) colMeans(d0[cl, ]));
tr<-cutree(hclust(as.dist(1-cor(ms))), k=length(cl)-1); # find the 2 most similar clusters
i<-tr[duplicated(tr)];
c<-ms[, tr==i];
r<-cor(c[, 1], c[, 2]);
p<-cor.test(c[, 1], c[, 2])$p.value[[1]];
if (r>prms$geneset$cluster$merge$corr & p<prms$geneset$cluster$merge$p) {
cl[tr==i][[1]]<-as.vector(unlist(cl[tr==i]));
cl<-cl[names(cl)!=names(i)];
} else flag<-FALSE;
}
# Sort clusters
m<-sapply(cl, function(cl) colMeans(d1[cl, ]));
ind<-apply(m, 2, function(x) which(x==max(x)));
cl<-cl[order(ind)];
# re-cluster genes
reCl<-function(d, cl, r, dif, nmax) {
md<-sapply(cl, function(cl) apply(d[cl[cl %in% rownames(d)], , drop=FALSE], 2, median));
corr<-cor(t(d), md);
c<-lapply(1:ncol(corr), function(i) {
corr<-corr[rev(order(corr[, i])), ];
mx<-apply(corr[, -i, drop=FALSE], 1, max);
id<-rownames(corr)[corr[, i]>=r & (corr[, i]-mx)>dif];
id[1:min(length(id), nmax)];
});
c;
}
for (i in 1:prms$geneset$cluster$recluster$time)
cl<-reCl(d0, cl, prms$geneset$cluster$recluster$corr, prms$geneset$cluster$recluster$diff, prms$geneset$cluster$recluster$nmax);
cls<-reCl(d1, cl, prms$geneset$cluster$recluster$corr, prms$geneset$cluster$recluster$diff, prms$geneset$cluster$recluster$nmax);
ms<-t(sapply(cls, function(x) colMeans(d1[x, ])));
rownames(ms)<-names(cls)<-names(cl)<-paste('Cluster', 1:length(cls), sep='_');
str(cls)
path.cl<-paste(path, 'CLUSTER', sep='/');
if (!file.exists(path.cl)) dir.create(path.cl, recursive = TRUE);
# normalize data
d1<-lapply(res, function(x) {
y<-x$input;
z<-y$expr[, unlist(y$comparison)];
z-rowMeans(z[, y$comparison[[1]]])
});
gs<-Reduce('intersect', lapply(d1, rownames));
d1<-do.call('cbind', lapply(d1, function(x) x[gs, , drop=FALSE]));
d1<-t(apply(d1, 1, function(x) x/sd(x)));
# select seeds
x<-paov[order(paov[, 3]), ];
x<-x[x[,3]<=prms$geneset$cluster$panova, , drop=FALSE];
d0<-d1[rownames(d1) %in% rownames(x), ];
d0<-d0[1: min(nrow(d0), prms$geneset$cluster$top), , drop=FALSE];
# initiate clusters
hc<-hclust(as.dist(1-cor(t(d0))));
cl<-cutree(hc, k=prms$geneset$cluster$seed);
cl<-split(names(cl), cl);
str(cl)
flag<-TRUE;
while(flag) {
cat('Number of clusters ', length(cl), '\n');
ms<-sapply(cl, function(cl) colMeans(d0[cl, ]));
tr<-cutree(hclust(as.dist(1-cor(ms))), k=length(cl)-1); # find the 2 most similar clusters
i<-tr[duplicated(tr)];
c<-ms[, tr==i];
r<-cor(c[, 1], c[, 2]);
p<-cor.test(c[, 1], c[, 2])$p.value[[1]];
if (r>prms$geneset$cluster$merge$corr & p<prms$geneset$cluster$merge$p) {
cl[tr==i][[1]]<-as.vector(unlist(cl[tr==i]));
cl<-cl[names(cl)!=names(i)];
} else flag<-FALSE;
}
str(cl)
# Sort clusters
m<-sapply(cl, function(cl) colMeans(d1[cl, ]));
ind<-apply(m, 2, function(x) which(x==max(x)));
cl<-cl[order(ind)];
str(cl)
reCl<-function(d, cl, r, dif, nmax) {
md<-sapply(cl, function(cl) apply(d[cl[cl %in% rownames(d)], , drop=FALSE], 2, median));
corr<-cor(t(d), md);
c<-lapply(1:ncol(corr), function(i) {
corr<-corr[rev(order(corr[, i])), ];
mx<-apply(corr[, -i, drop=FALSE], 1, max);
id<-rownames(corr)[corr[, i]>=r & (corr[, i]-mx)>dif];
id[1:min(length(id), nmax)];
});
c;
}
str(reCl)
prms$geneset$cluster$recluster$time
prms$geneset$cluster$recluster$corr
prms$geneset$cluster$recluster$diff
prms$geneset$cluster$recluster$nmax
for (i in 1:prms$geneset$cluster$recluster$time)
cl<-reCl(d0, cl, prms$geneset$cluster$recluster$corr, prms$geneset$cluster$recluster$diff, prms$geneset$cluster$recluster$nmax);
str(cl)
cls<-reCl(d1, cl, prms$geneset$cluster$recluster$corr, prms$geneset$cluster$recluster$diff, prms$geneset$cluster$recluster$nmax);
str(cls)
dim(d1)
head(d1)
str(cl)
dim(d1)
dim(d0)
m2 <- rowMeans(d1);
d2 <- d1[m2 >= quantile(m2)[2], , drop=FALSE];
summary(d1[, 1])
reCl<-function(d, cl, r, dif, nmax) {
d <- d[!is.na(rowMeans(d)), , drop=FALSE];
cl <- lapply(cl, function(cl) cl[cl %in% rownames(d)]);
md<-sapply(cl, function(cl) apply(d[cl[cl %in% rownames(d)], , drop=FALSE], 2, median));
corr<-cor(t(d), md);
c<-lapply(1:ncol(corr), function(i) {
corr<-corr[rev(order(corr[, i])), ];
mx<-apply(corr[, -i, drop=FALSE], 1, max);
id<-rownames(corr)[corr[, i]>=r & (corr[, i]-mx)>dif];
id[1:min(length(id), nmax)];
});
c;
}
cls<-reCl(d1, cl, prms$geneset$cluster$recluster$corr, prms$geneset$cluster$recluster$diff, prms$geneset$cluster$recluster$nmax);
str(cls)
ms<-t(sapply(cls, function(x) colMeans(d1[x, ])));
rownames(ms)<-names(cls)<-names(cl)<-paste('Cluster', 1:length(cls), sep='_');
dim(ms)
ms
fn.htmp<-sapply(names(cls), function(nm) {
x<-d1[cls[[nm]], ];
f<-paste(path.cl, '/Heatmap_', nm, '.pdf', sep='');
sz<-CalculateColoredBlockSize(x);
pdf(f, width = max(sz[2]/3, sz[1]), height = sz[2]);
PlotColoredBlock(x, num.breaks = 31, key = 'Normalized expression', groups = grps);
dev.off();
f;
});
saveRDS(list(cluster=cls, initial=cl, seed=d0, data=d1), file=paste(path.r, 'cluster.rds', sep='/'));
fn.tbl<-lapply(names(cls), function(nm) {
cat(nm, '\n');
cl<-cls[[nm]];
s<-TestGSE(cl, gid, gset[[2]])[[1]];
t<-gset[[1]][rownames(s), ];
t$Name<-AddHref(t$Name, t$URL);
t<-cbind(t[, 1:3], FormatNumeric(s));
f<-paste('CLUSTER/ORA_', nm, '.html', sep='');
CreateDatatable(t, paste(path, f, sep='/'), rownames=FALSE, caption=paste('Over-represented gene set in', nm));
c<-nrow(t);
names(c)<-f;
t<-do.call('cbind', lapply(stat, function(s) s[cl, c(1, 2, 4, 5, 6)]));
t<-FormatNumeric(t);
colnames(t)[-grep('^Mean', colnames(t))]<-paste(colnames(t)[-grep('^Mean', colnames(t))], rep(names(grp), each=3), sep='_');
t<-data.frame(anno[rownames(t), ], t, stringsAsFactors = FALSE);
CreateDatatable(t, paste(path.cl, '/', nm, '.html', sep=''), caption=nm);
c;
});
mm<-round(sapply(grps, function(x) rowMeans(ms[, x, drop=FALSE])), 4);
n<-as.vector(unlist(fn.tbl));
sz<-sapply(cls, length);
lnk<-paste('[', n, '](', sapply(fn.tbl, names), ')', sep='');
lnk
dim(lnk)
cl.tbl<-data.frame(Size=sz, mm, Gene_set=lnk, stringsAsFactors = FALSE);
cl.tbl[, 1]<-paste('[', sz, '](CLUSTER/', names(cls), '.html)', sep='');
cl.tbl<-cbind(ID=rownames(cl.tbl), cl.tbl);
cl.tbl[, 1]<-paste('[', cl.tbl[, 1], '](CLUSTER/Heatmap_', names(cls), '.pdf)', sep='');
cl.tbl
dim(cl.tbl)
s<-smpl[colnames(d), ]
s
yml <- yaml.load_file('summarize_three.yaml')
prms <- yml$parameter
d1<-lapply(res, function(x) {
y<-x$input;
z<-y$expr[, unlist(y$comparison)];
z-rowMeans(z[, y$comparison[[1]]])
});
x <- d1[[1]]
head(x)
summary(x[, 1])
d1 <- lapply(res, function(x) {
y<-x$input;
y$expr[, unlist(y$comparison)];
});
d1 <- do.call('cbind', d1);
dim(d1)
head(d1)
colnames(d1)
grps
x <- d1[, unlist(grps[[i]])]
x <- d1[, unlist(grps[[1]])]
dim(x)
head(x)
length(grps)
i<-1
y <- as.vector(unlist(res[[i]]$input$comparison));
y
d1 <- lapply(res, function(x) {
y<-x$input;
y$expr[, unlist(y$comparison)];
});
d1 <- do.call('cbind', d1);
if (!prms$gene$processing$logged) d1 <- log2(d1+1);
if (!prms$gene$processing$normalized) d1 <- NormLoess(d1+1);
for (i in 1:3) {
y <- res[[i]]$input$comparison;
d1[, unlist(y)] <- d1[, unlist(y)] - rowMeans(z[, y$comparison[[1]]])
}
for (i in 1:3) {
y <- res[[i]]$input$comparison;
d1[, unlist(y)] <- d1[, unlist(y)] - rowMeans(z[, y[[1]]]);
}
for (i in 1:3) {
y <- res[[i]]$input$comparison;
d1[, unlist(y)] <- d1[, unlist(y)] - rowMeans(d1[, y[[1]]]);
}
dim(d1)
head(d1)
d1[1, ]
mean(d1[1, 1:3])
mean(d1[1, 7:9])
mean(d1[1, 7:9+3])
mean(d1[1, 13:15])
# normalize data
d1 <- lapply(res, function(x) {
y<-x$input;
y$expr[, unlist(y$comparison)];
});
d1 <- do.call('cbind', d1);
if (!prms$gene$processing$logged) d1 <- log2(d1+1);
if (!prms$gene$processing$normalized) d1 <- NormLoess(d1+1);
for (i in 1:3) {
y <- res[[i]]$input$comparison;
d1[, unlist(y)] <- d1[, unlist(y)] - rowMeans(d1[, y[[1]]]);
d1[, unlist(y)] <- t(apply(d1[, unlist(y)], 1, function(x) x/sd(x)));
}
mean(d1[, 7:9])
sd(d1[1001, 1:6])
sd(d1[1001, 7:12])
rm(list=ls())
CreateReport('summarize_three.yaml')
ls()
CreateReport('summarize_three.yaml')
name.yaml <- 'summarize_three.yaml';
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'MASS', 'gplots', 'scatterplot3d',
'VennDiagram', 'RoCA', 'rchive', 'DEGandMore');
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table');
knitr::opts_chunk$set(eval=TRUE, dpi=300, fig.pos="H", fig.width=8, fig.height=6, echo=FALSE, warning=FALSE, message=FALSE, fig.path='FIGURE/');
## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }
## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));
## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template
prms <- yml$parameter;
## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]);
## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
