---
title: "Two-group differential gene expression"
author: "`r if (exists('yml')) yml$analyst else 'Jim Zhang'`"
date: "`r Sys.Date()`"
output:
  html_document:
    number_sections: yes
    self_contained: no
    toc: yes
    toc_float:
      collapsed: no
---

<div style="border:black 1px solid; padding: 0.5cm 0.5cm">
**Introduction** 
</div>

&nbsp;

```{r global_setup, include=FALSE}
name.yaml <- 'pairwise_comparison.yaml'; 
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'MASS', 'gplots', 'pathview', 'flexclust', 'colorspace',
                   'RoCA', 'rchive', 'awsomics', 'DEGandMore'); 
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table', 'path.deg'='DEG', 'path.ora'='ORA');

## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));

## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
  if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
    yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template

prms <- yml$parameter;

## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]); 

## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
```

```{r load_data, include=FALSE}
inputs<-yml$input;

# All input variables
anno <- ImportTable(DownloadFile(inputs$anno, path.input));
expr <- as.matrix(ImportTable(DownloadFile(inputs$expr, path.input)));
grps <- ImportR(DownloadFile(inputs$comparison, path.input));
geneset <- ImportR(DownloadFile(inputs$geneset, path.input));

genome  <- prms$genome;
paired  <- prms$paired;
g1.ind  <- intersect(colnames(expr), grps[[1]]);
g2.ind  <- intersect(colnames(expr), grps[[2]]);
g1.name <- gsub('-', '_', names(grps)[1]);
g2.name <- gsub('-', '_', names(grps)[2]);

anno <- anno[rownames(anno) %in% rownames(expr), , drop=FALSE]; 
expr <- expr[rownames(anno), , drop=FALSE]; 
if (is.null(paired)) paired <- FALSE; 
if (paired & length(g1.ind)!=length(g2.ind)) paired <- FALSE;
if (is.null(g1.name)) g1.name <- 'Group_1';
if (is.null(g2.name)) g2.name <- 'Group_2';

# Check validity of inputs
if (nrow(expr) < 3)   stop('Less than 3 genes in the data set, cannot continue.\n');
if (is.null(g1.ind))  stop('Error: Index of samples in group 1 unknown\n');
if (is.null(g2.ind))  stop('Error: Index of samples in group 2 unknown\n');
if (length(g1.ind)<2) stop('Error: Not enough samples in group ', g1.name, ' (minimum=2), cannot continue.\n');
if (length(g2.ind)<2) stop('Error: Not enough samples in group ', g2.name, ' (minimum=2), cannot continue.\n');

# Re-process gene expression matrix
e1<-expr[, g1.ind, drop=FALSE];
e2<-expr[, g2.ind, drop=FALSE];
e1.2<-cbind(e1, e2); 
pctl<-apply(e1.2, 2, function(e) 100*rank(e)/length(e)); # percentile

inputs$expr<-e1.2;
if (!prms$processing$logged) inputs$logged <- e1.2 <- log2(e1.2+1); 
if (!prms$processing$normalized) inputs$normalized <- e1.2 <- NormLoess(e1.2); 

res<-list(inputs=inputs);  # Result set
```

`r home.url` 

# Analysis and results

## Sample analysis
  
This section analyzes the samples by summarizing their global expression patterns, through descriptive statistics, unsupervised clustering, and sample-sample correlation.
  
### Data distribution

Distribution of average expression level and between-sample variance. 

<div align='center'>
```{r data_distribution, include=TRUE, fig.width=6.4, fig.height=8, out.width='640px'}
par(mfrow=c(3,1), mar=c(4,5,2,2));

# Distribution of average expression level
m<-rowMeans(e1.2);
d<-density(m);
x<-d$x;
y<-d$y;
plot(d, type='n', yaxs='i', xaxs='i', xlim=c(min(x), max(x)), ylim=c(0, 1.1*max(y)), xlab='', ylab='Density', main='A. Distribution of Expression Level', cex.lab=2, cex.main=1.5);
title(xlab='Average expression level of genes', line=2, cex=2);

x0<-as.vector(summary(m))[2:5];
y0<-sapply(x0, function(x0, x, y) y[which(abs(x-x0)==min(abs(x-x0)))], x=x, y=y);
col<-c('blue', 'red', 'orange', 'green');
segments(x0, 0, x0, y0, lty=1, col=col, lwd=1);
lines(d, col='darkgrey', lwd=4); 
text(x0, y0/2, srt=90, labels=round(x0, 3));
legend('topright', legend=c('First quantile', 'Median', 'Mean', 'Third quantile'), lty=1, col=col, bty='n', lwd=2);

# Distribution of standard deviation across samples
sd<-apply(e1.2, 1, sd);
d<-density(sd); 
x<-d$x;
y<-d$y;
plot(d, type='n', yaxs='i', xaxs='i', xlim=c(min(x), max(x)), ylim=c(0, 1.1*max(y)), xlab='', ylab='Density', main='B. Distribution of Variance', cex.lab=2, cex.main=1.5);
title(xlab='Standard deviation of genes', line=2, cex=2);

x0<-as.vector(summary(sd))[2:5];
y0<-sapply(x0, function(x0, x, y) y[which(abs(x-x0)==min(abs(x-x0)))], x=x, y=y);
col<-c('blue', 'red', 'orange', 'green');
segments(x0, 0, x0, y0, lty=1, col=col, lwd=1);
lines(d, col='darkgrey', lwd=4);
text(x0, y0/2, srt=90, labels=round(x0, 3));
legend('topright', legend=c('First quantile', 'Median', 'Mean', 'Third quantile'), lty=1, col=col, bty='n', lwd=2);

plot(m, sd, xlab='', ylab='Standard Deviation', main='C. Variance vs. Expression Level', cex.lab=2, cex.main=1.5, cex=0.5, col='darkgrey');
title(xlab='Average expression level of genes', line=2, cex=2);
lines(lowess(m, sd), lwd=3, col=2);
```
</div>

<div style="color:darkblue; padding:0 1cm">
 - **Figure 1A.** This figure is based on the average expression measurements of all genes. If the measurements have been log-transformed, they often have a bi-modal (two-peak) distribution: a high and narrow peak on the left corresponding to inactive genes and a relatively lower and wider peak on the right corresponding to actively expressed genes. If the base of log-transformation is 2, a difference of 1.0 on the x-axis corresponds to a 2-fold change of expression. Similarly, if the base is 10, the corresponding expression change is 10-fold per 1.0 difference on the x-axis. (note that microarray measurements, raw or processed, are not exactly proportional to the actual mRNA abundancy, so the term fold change should not be taken literally.)
 - **Figure 1B.** This figure is based on the between-sample standard deviations of all genes. The distribution usually has a single peak and a long tail on the right side. An enlarged tail usually indicates more genes are differentially expressed between samples. In a high quality data set, a gene not differentially expressed between samples should have small variance. So, if we assume that the majority of genes have no or little differential expression, the skewness of the peak towards the left side roughly represents data quality. 
 - **Figure 1C.** This figure summarizes the relationship between gene expression measurements and their between-sample variance. Genes having smaller variance are more likely to get significant results from Student t test and similar methods. So, if there is a strong dependency of variance on expression measurements, the analysis of differential expression will be affected by the baseline expression level of genes. Variance stabilization procedure is commonly used during data normalization to minimize such dependency. In the figure, the red line is the result of LOWESS smoothing and the majority of this line should be approximately straight and horizontal if the data has been normalized properly. In practice, the LOWESS line is usually a curve higher in the middle.
</div>

### Sample similarity

By comparing gene expression patterns of different samples, observations can be made about the sample similarity. This section compares samples via data distribution, hierarchical clustering, and principal components analysis, which can potentially be used to identify outliers and confounding variables. 

<div align='center'>
```{r analysis_boxplot, include=TRUE, fig.width=6.4, fig.height=4, out.width='640px'}
par(mfrow=c(1,1), mai=c(0.7, 0.6, .1,.1))
plot(0, type='n', xlim=c(0.5, 0.5+ncol(e1.2)), ylim=c(min(e1.2), max(e1.2)), ylab='', xlab='', xaxt='n'); 
lines(1:ncol(e1.2), apply(e1.2, 2, median), col='green', lwd=1);
title(ylab='Expression Level', line=2);
cex<-max(strwidth(colnames(e1.2), unit='in'));
boxplot(data.frame(e1.2), las=3, notch=TRUE, boxwex=.6, col=c(rep('lightgrey', ncol(e1)), rep('lightblue', ncol(e2))), names=colnames(e1.2), cex.axis=min(1, 0.4/cex), yaxt='n', add=TRUE, pch=19, cex=0.4)->x;
```
</div>

<div style="color:darkblue; padding:0 1cm">
Each boxplot summarizes the expression measurements of all genes in one sample. Based on the assumption that all samples have approximately the same global distribution of gene expression measurements, all boxes should look similar regardless of which group they belong to. This assumption is not always true though. For example, normal cells and cancer cells could have dramatically different global patterns of gene expression. The notches of each box indicate the median, the lower and upper sides of the box represent the first and third quantile, and the individual data points out of the whiskers are the outliers (more than 1.5 inter-quantile range from the median).
</div>

<div align='center'>
```{r analysis_clustering, include=TRUE, fig.width=6.4, fig.height=4.8, out.width='640px'}
par(mfrow=c(1,1), mai=c(0.2, 0.8, .2 , .2));
plot(hclust(dist(t(e1.2))), main='', ylab='', xlab='', sub='', cex=min(1, 5/ncol(e1.2)/0.12), frame.plot=TRUE);
title(ylab='Distance', line=2.5, cex.lab=2);
```
</div>

<div style="color:darkblue; padding:0 1cm">
**Figure 3.** This is an unsupervised clustering of samples used all genes in the data set. On the clustering tree, the vertical location of their lowest common node of any two samples represents their similarity (lower = more similar). Since the sample grouping information is not used, the splitting of samples into two sub-trees will indicate that these samples belong to different groups due to a known or unknown factor. Unexpected splitting often suggest outliers or confounding variables. 
</div>

<div align='center'>
```{r analysis_pca, include=TRUE, fig.width=6.4, fig.height=4.8, out.width='640px'}
pca<-prcomp(t(e1.2));

X<-pca$x[,1];
Y<-pca$x[,2];
per<-round(summary(pca)$importance[2, 1:2]*100, 2);
pca$importance<-summary(pca)$importance;
res$pca<-pca;

col<-rep(c('darkgreen', 'deeppink1'), c(length(g1.ind), length(g2.ind)));

layout(matrix(1:2, nrow=1), width=c(3,1));
par(mai=c(1,1,.25,.25));

cx<-max(0.5, min(3, 64/length(X)))
plot(X, Y, col=col, pch=19, cex=cx, xlim=c(min(X)*1.1, max(X)*1.1), ylim=c(min(Y)*1.1, max(Y)*1.1), 
     xlab=paste('PC1', ', ', per[1], '%', sep=''), ylab=paste('PC2', ', ', per[2], '%', sep=''), cex.lab=1.5);

text(X, Y, label=1:length(X), col='white', cex=.3*cx);

par(mai=c(1, 0, 0.25, 0));
plot(0, type='n', xlim=c(0, 100), ylim=c(1, 100), axes=FALSE, bty='n', xaxs='i', yaxs='i', xlab='', ylab='');

w<-strwidth(1:length(X), cex=1.2);
w0<-1.2*80/max(w, 80);
h0<-1.2*(100/length(X))/4.0;
cex<-min(1.2, w0, h0); 

points(rep(5, length(X)), 100-(1:length(X))*4.0*cex, col=col, pch=19, cex=1.5*cex);
text(5+cex*5, 100-(1:length(X))*4.0*cex, labels=colnames(e1.2), adj=0, col=col, pch=19, cex=cex);
text(rep(5, length(labels)), 100-(1:length(X))*4.0*cex, labels=1:length(X), col='white', cex=0.8*cex);
```
</div>

<div style="color:darkblue; padding:0 1cm">
**Figure 4.** Principal Components Analysis (PCA) is also an unsupervised analysis that converts a large number of correlated variables (genes) into a smaller set of uncorrelated variables called principal components (PCs). Each principal component accounts for certain percentage of total variability of a data set so the PCs can be ordered by their percentages. This figure plots the top two PCs on the two axes. In general, samples closer to each other have more similar gene expression patterns. PCA can be used to identify sample features, such as age, disease, and treatment, that are associated with one or two PCs. It then can be concluded that these features are responsible for part of the total variability in the data set.
</div>

`r home.url` 

## Differential gene expression

  - **Fold change, percentage change, ratio, or log2-ratio:** These statistics indicate the magnitude of the difference of group averages. They are the same values in different scale and can be easily converted to each other (see **Appendix 1**). Given the data has been log2-transformed, the difference of group averages is equivalent to the log2-ratio of unlogged data as _log2(A/B)==log2(A)-log2(B)_. So, group difference will be referred as log2-ratio throughout this report. 

  - **p value, q value, or FDR:** These statistics indicates the statistical significance of group difference.  P value refers to type I error of statistical test, or the chance to mistakenly conclude the differential expression of a gene while the gene is actually unchanged. RP estimates both p values and FDR based on a permutation procedure during which the ranked gene lists were shuffled to generate a background distribution of rank products.

```{r analysis_deg, include=FALSE}
deg.sub <- paste(c('Higher', 'Lower'), 'in', g2.name, sep='_'); 

# parameters of differential expression
deg.method <- prms$deg$method;
cutoff.l2r <- prms$deg$cutoff.l2r;
cutoff.p   <- prms$deg$cutoff.p;
cutoff.fdr <- prms$deg$cutoff.fdr;
num.top    <- prms$deg$num.top;
nperm      <- prms$deg$nperm;

means<-cbind(rowMeans(e1.2[, g1.ind]), rowMeans(e1.2[, g2.ind]));
colnames(means)<-c(g1.name, g2.name);
l2r<-means[,2]-means[,1]; 
l2r[is.na(l2r)]<-0;
fc<-exp(l2r*log(2));
mn<-cbind(means, l2r, fc);
colnames(mn)<-c(paste('Mean', names(grps), sep='_'), 'LogFC', 'FoldChange');

# Adjust expr matrix if a penalty is given for large between-sample variance
penalty <- prms$deg$penalty;
if (is.na(penalty) | is.null(penalty)) penalty <- 0; 
if(penalty>0) {
  if (penalty>1) penalty<-1;
  colnames(means)<-paste('Mean_', c(g1.name, g2.name), sep='');
  if (paired) sd<-apply(e1.2[, g2.ind]-e1.2[, g1.ind], 1, sd) else {
    v1<-apply(e1.2[, g1.ind], 1, var);
    v2<-apply(e1.2[, g2.ind], 1, var);
    df1<-length(g1.ind)-1;
    df2<-length(g2.ind)-1;
    sd<-sqrt((df1*v1+df2*v2)/(df1+df2));
    sd[sd==0]<-min(sd[sd>0])/2;
  }
  pnl<-quantile(sd, probs=seq(0, 1, 0.01))[100*round(1-penalty,2)+1];
  e<-e1.2; # keep the original
  e[, g2.ind]<-apply(e[, g2.ind], 2, function(d) means[,1]+(d-means[,1])/(pnl+sd));
} else e<-e1.2;

if (!prms$deg$reprocessed) e <- expr[, colnames(e1.2)]; 

#######################################################################
de<-DeWrapper(e, grps, deg.method, list(nperm=nperm, paired=paired)); #
#######################################################################

#de$results$stat[, c(1,2,4)]<-mn[, 1:3];
#de$results$stat[, 3]<-de$results$stat[, 2]-de$results$stat[, 1]; 
if (deg.method == DeMethods()[3]) { # Rank Product methods
  s<-de$results$stat; 
  rp<-de$results$rp$summarized; 
  out<-lapply(rp, function(x) x[, c('Rank', 'Pvalue', 'FDR')]);
  out[[3]]<-cbind(out[[1]], out[[2]]);
  cnm<-rep(deg.sub, each=3);
  colnames(out[[3]])<-paste(colnames(out[[3]]), cnm, sep='_')
  out<-lapply(out, function(out) cbind(mn[rownames(out), , drop=FALSE], out));
  names(out)<-c(deg.sub, 'Single_rank');
  degs<-lapply(out[1:2], function(x) {
    deg<-x[x[, 'Pvalue']<=cutoff.p & x[, 'FDR']<=cutoff.fdr & abs(x[, 'LogFC'])>=cutoff.l2r, , drop=FALSE];
    if (nrow(deg) < num.top) deg<-x[x[, 'Pvalue']<=cutoff.p & x[, 'Rank']<=num.top, , drop=FALSE]; 
    deg;
  }); 
  degs<-lapply(degs, function(d) d[order(d[, 'Rank']), ]);
} else {
  out<-de$results$stat;
  degs<-lapply(c(1, -1), function(di) {
    x<-out[sign(out[, 'LogFC'])==di, , drop=FALSE];
    deg<-x[x[, 'Pvalue']<=cutoff.p & x[, 'FDR']<=cutoff.fdr & abs(x[, 'LogFC'])>=cutoff.l2r, , drop=FALSE];
    if (nrow(deg) < num.top) deg<-x[x[, 'Pvalue']<=cutoff.p & abs(x[, 'LogFC'])>=sort(abs(x[, 'LogFC']), decreasing = TRUE)[min(num.top, nrow(x))], , drop=FALSE]; 
    deg;
  }); 
  degs<-lapply(degs, function(d) d[order(-1*abs(d[, 'LogFC'])), , drop=FALSE]);
}

stat<-de$results$stat[, 1:6];
z <- tolower(prms$deg$rank[1]);
if (length(z) == 0) z <-'both'; 
if (z=='p') rnk <- -log10(stat[, 'Pvalue'])*sign(stat[,'LogFC']) else 
  if (z=='fc') rnk <- stat[, 'LogFC'] else 
    rnk <- sign(stat[,'LogFC'])*sqrt(abs(log10(stat[, 'Pvalue'])*stat[, 'LogFC'])); 
x <- -rank(rnk); 
y <- rank(-rnk); 
rk <- rep(NA, length(x));
rk[rnk>0] <- y[rnk>0];
rk[rnk<0] <- x[rnk<0];
stat <- cbind(stat, Rank=rk); 

stat.table<-cbind(anno[rownames(stat), ], stat);
stat.formatted<-FormatNumeric(cbind(ID=rownames(stat.table), stat.table));
stat.formatted$ID<-AddHref(stat.formatted$ID, UrlEntrezGene(stat.formatted$ID));
CreateDatatable(stat.formatted, fn = paste(path, 'DEG', 'all_genes.html', sep='/'), rownames = FALSE, caption = "Differential expression of all genes");

names(degs) <- deg.sub;
de$data<-e; 
de$DEG <- degs;
up <- degs[[1]];
dn <- degs[[2]];
saveRDS(de, file=paste(path.r, 'deg_all.rds', sep='/')); 
saveRDS(stat, paste(path.r, 'deg_stat.rds', sep='/')); 
```

### DEG summary

<div align='center'>
```{r deg_plot, include=TRUE, fig.width=6.4, fig.height=4.8, out.width='800px'}
par(mai=c(0.4, 0.5, 0.3, 0.05), mfrow=c(2,2));

#if (class(out)=='list') d<-out[[length(out)]] else d<-out;
d<-cbind(mn, de$results$stat[, 5:6]);

# M-A Plot
x <- rowMeans(mn[, 1:2]); 
y <- stat[, 4];
plot(x, y, main='A. M-A Plot', pch=19, col='darkgrey',  cex=.25, xlab='', ylab='', cex.axis=.75);
abline(h=0, lwd=1, col=1);
lines(lowess(y~x), lwd=2, col=3);
ylab<-paste('Log2(', g2.name, '/', g1.name, ')', sep='');
xlab<-paste('Log2(', g1.name, ')/2 + Log2(', g2.name, ')/2', sep='');
title(xlab=xlab, ylab=ylab, line=1.6, cex.lab=.75);

#Volcano Plot
x<-stat[,'LogFC'];
p<-stat[,'Pvalue'];
y<--1*log10(p);
y[y==Inf] <- max(y[y<Inf])+1; 
z<-sqrt(abs(x*y));
cx<-z/(max(z));
ylim <- min(10, ceiling(max(y))); 
plot(x, y, main='B. Volcano Plot', pch=19, col='darkgrey',  cex=0.8*cx, xlab='', ylab='', cex.axis=.75, ylim=c(0, 1.1*ylim), yaxs='i', xlim=c(-1*max(abs(x)), max(abs(x))), yaxt='n');
xlab<-paste('Log2(', g2.name, '/', g1.name, ')', sep='');
title(xlab=xlab, ylab='P value', line=1.6, cex.lab=.75);
axis(2, at=0:ylim, labels=10^(-1*(0:ylim)));
abline(h=-1*log10(0.05), v=c(-1,1), col=4, lty=3);
box();

# P Value Distribution
hist(p[p<1], br=seq(0, 1, 0.01), cex.axis=.75, main='C. P Value Distribution');
title(xlab='P value', ylab='Count', line=1.6, cex.lab=.75);
box();

# FDR
q<-round(stat[, 'FDR'], 2);
n<-sapply(seq(min(q), 1, 0.01), function(x) length(q[q<=x]));
plot(1, type='n', log='y', xlab='', ylab='', cex.axis=.75, xlim=0.01*c(1, 100), ylim=c(1, nrow(expr)), 
     main='D. False Discovery Rate');
abline(v=seq(0, 1, .05), lty=3, col=8);
lines(seq(min(q), 1, 0.01), n, lwd=2, col=2);
title(xlab='FDR cutoff', ylab='Count', line=1.6, cex.lab=.75);
box();
```
</div>

<div style="color:darkblue; padding:0 0.5cm">
**Figure 5.** The differential expression of all [`r nrow(expr)`](./DEG/all_genes.html) genes can be visualized in different ways: 

  - **5A:** ***M-A Plot.*** This plot visualizes global pattern of group difference (as log2-ratio). **M** (Y axis) is the log2-ratio and **A** (X axis) is the average measurements of the two groups. Each dot represents a gene and the green line is generated by LOWESS smoothing. The location and shape of the LOWESS line indicate whether there is an overall skewness of differential expression or expression level-dependent differential expression.
  - **5B:** ***Volcano Plot.*** This plot puts together both types of variables (usually **p value** and **log2-ratio**) used to represent differential expression and their association. A common strategy is to only consider genes with both small p values and large log2-ratios as GOI (genes of interest). Each dot represents a gene and its size is proportional to its distance from the [0, 1] point. The horizontal line corresponds to a p value of 0.05 and the vertical lines correspond to 2.0 fold change on both sides. 
  - **5C:** ***P Value Distribution.*** This plot shows the counts of genes whose Rank Product p values are located in each 0.01 interval. So, the leftmost bar indicates the number of genes having p values less than 0.01. If the data is completely random and there are enough samples, the p values will have a uniform distribution, with approximately the same number of genes in each interval. If there are indeed a number of genes differentially expressed between the compared groups and the microarray experiments are properly designed and executed, we expect that the p values have a distribution with the highest density on the left side. If the highest density of the distribution is in the middle or on the right side, we will suspect a confounding factor that has a bigger influence on the data than the factor distinguishing the two compared groups. 
  - **5D:** ***FDR.*** This plots traces the number of genes corresponding to each FDR (false discovery rate) cutoff. **Table 1** lists the number of genes corresponding to commonly used FDR cutoffs. 
</div>

```{r deg_fdr, include=FALSE}
#FDR counts
c<-c(0.01, 0.02, 0.05, 0.1, 0.15, 0.2, 0.25);
n.fdr<-sapply(c, function(c) sapply(c(1, -1), function(di) 
  nrow(stat[sign(stat[, 'LogFC'])==di & stat[, 'FDR']<=c, , drop=FALSE])));
fdr.table<-cbind(c, t(n.fdr), colSums(n.fdr)); 
colnames(fdr.table)<-c('FDR', deg.sub, 'Total')
saveRDS(fdr.table, paste(path.r, 'FDR_count.rds', sep='/')); 

# pre-ranking of genes
rnk<-sign(stat[, 'LogFC'])*sqrt(stat[,'LogFC']^2+log10(p)^2);
```

<div style="color:darkblue; padding:0 2cm">
**Table 1.** Number of top DEGs selected via different cutoffs of FDR. FDRs are calculated using the Benjamini&Hochberg method (_Controlling the false discovery rate: a practical and powerful approach to multiple testing_. Journal of the Royal Statistical Society Series B 57, 289â€“300. 1995)
</div>

<div align='center', style="padding:0 2.5cm">
`r kable(fdr.table, row.names=FALSE)`
</div>

### Top genes

```{r write_deg, include=FALSE}
path.deg1<-paste(path.deg, deg.sub[1], sep='/');
path.deg2<-paste(path.deg, deg.sub[2], sep='/');
path.deg1.bars<-paste(path.deg1, '/bars', sep='');
path.deg2.bars<-paste(path.deg2, '/bars', sep='');

if (!exists(path.deg)) dir.create(path.deg, showWarnings = FALSE);
if (!exists(path.deg1.bars)) dir.create(path.deg1.bars, showWarnings = FALSE, recursive = TRUE);
if (!exists(path.deg2.bars)) dir.create(path.deg2.bars, showWarnings = FALSE, recursive = TRUE);
ids<-c(up=rownames(up), dn=rownames(dn));
names(ids)<-paste(rep(c(path.deg1.bars, path.deg2.bars), c(nrow(up), nrow(dn))), '/', ids, '.pdf', sep='');

col<-rep(c('lightgrey', 'lightblue'), c(length(g1.ind), length(g2.ind)));
wid<-min(1.8, 1.2/(0.1*max(nchar(colnames(expr[, c(g1.ind, g2.ind)])))));
fn.barplot<-sapply(names(ids), function(nm) {
  pdf(nm, w=8, h=6); 
  par(mai=c(1.2, 1, 0.6, 0.2));
  barplot(expr[ids[nm], c(g1.ind, g2.ind)], las=3, col=col, ylab='Expression level', cex.lab=wid, cex.names=wid);
  title(main=paste(ids[nm], CleanHtmlTags(as.vector(anno[ids[nm], 1])), sep=' - '), cex.main=2);
  #plot.new();
  par(mai=c(1.2, 1, 0.6, 0.2));
  barplot(pctl[ids[nm], c(g1.ind, g2.ind)], las=3, col=col, ylab='Percentile (%)', ylim=c(0, 100), cex.lab=2, cex.names=wid);
  title(main=paste(ids[nm], CleanHtmlTags(as.vector(anno[ids[nm], 1])), sep=' - '), cex.main=2);
  
  dev.off();
  nm;
});

# Write index tables of DEGs
cnm<-c(colnames(anno), colnames(up), 'Samples');
up.tbl<-data.frame(anno[rownames(up), , drop=FALSE], up, rep('Figure', nrow(up)));
colnames(up.tbl)<-cnm;
up.tbl$Samples<-AddHref(up.tbl$Samples, paste('./bars/', rownames(up), '.pdf', sep='')); 
up.formatted<-GeneList2Datatable(FormatNumeric(up.tbl), paste(path.deg1, 'index.html', sep='/'), col.symbol=1, genome=genome, title=paste('Genes with higher expression in', g2.name));

dn.tbl<-data.frame(anno[rownames(dn), , drop=FALSE], dn, rep('Figure', nrow(dn)));
colnames(dn.tbl)<-cnm;
dn.tbl$Samples<-AddHref(dn.tbl$Samples, paste('./bars/', rownames(dn), '.pdf', sep='')); 
dn.formatted<-GeneList2Datatable(FormatNumeric(dn.tbl), paste(path.deg2, 'index.html', sep='/'), col.symbol=1, genome=genome, title=paste('Genes with lower expression in', g2.name));
```

<div align='center'>
```{r deg_top, include=TRUE, fig.width=6.4, fig.height=2.4, out.width='800px'}
# Plot top genes
par(mfrow=c(1,2), mai=c(0.7, 0.35, 0.3, 0.05));
ind<-c(rownames(up)[1], rownames(dn)[1]);

cex<-min(0.75, min(0.5/max(strwidth(colnames(e1.2), unit='in'))));
col<-rep(c('grey', 'lightblue'), c(length(g1.ind), length(g2.ind)));
for (ii in 1:2) barplot(e1.2[ind[ii], ], las=3, cex.names=cex, main=CleanHtmlTags(anno[ind[ii], 1], FALSE), cex.main=.75, cex.axis=.75, col=col);
```
</div>

<div style="color:darkblue; padding:0 0.5cm">
**Figure 6.** Top-ranked genes with increased (left) and decreased (right) expression in `r g2.name`. Click [here](./DEG/all_genes.html) to view differential expression of all genes.
</div>

<div align='center'>
```{r deg_heatmap, include=TRUE, fig.width=6.4, fig.height=6.4, out.width='800px'}
# Plot heatmap of top genes
par(mfrow=c(1,1));
goi<-e1.2[c(rownames(up), rownames(dn)), ];
rownames(goi)<-as.vector(anno[rownames(goi), 1]);
DegHeatmap(goi,  col=rep(c('chartreuse1', 'deeppink1'), c(length(g1.ind), length(g2.ind))), plot.new=FALSE);
```
</div>

<div style="color:darkblue; padding:0 0.5cm">
**Figure 7.** Heatmap of the top `r nrow(up)` and `r nrow(dn)` DEGs with higher (red) and lower (yellow) expression in `r g2.name`. Each row represents a DEG, whose expression measurements are normalized across samples. Samples are clustered by these genes and the columns are colored (green = `r g1.name` and red = `r g2.name`). Click links below to view full statistical results of DEGs:

  - [Higher in `r g2.name`](./DEG/`r deg.sub[1]`/index.html)
  - [Lower in `r g2.name`](./DEG/`r deg.sub[2]`/index.html)

</div>

## Gene-set analysis

Predefined gene sets are the unit of all analyses in this section. The assumption is that if genes of the same gene set, such as those in the same signaling pathway or regulated by the same master regulator, are more likely to be differentially expressed between two compared sample groups, the gene set is somehow associated with the biological difference between the groups.

### Over-representation analysis (ORA)

```{r analysis_ora, include=FALSE}
########################################################################################
ora <- lapply(degs, function(gs) TestGSE(rownames(gs), rownames(expr), geneset$list)); #
########################################################################################

names(ora) <- names(degs); 
saveRDS(ora, paste(path.r, 'ora_all.rds', sep='/')); 

ora.table<-lapply(ora, function(ora) {
  g<-ora$stat;
  lst<-ora$list[rownames(g)];
  rand<-sapply(lst, function(l) { 
    mtrx<-e1.2[rownames(e1.2) %in% l, , drop=FALSE];
    randIndex(table(kmeans(t(mtrx), 2)[[1]], rep(1:2, sapply(grps, length))));
  })
  an<-geneset[[1]][rownames(g), ];
  data.frame(row.names = rownames(g), stringsAsFactors = TRUE, Source=an[,1], Collection=an[,2], Term=an[, 'Name'], 
             Total=rowSums(ora$size[rownames(g), 3:4]), Within=ora$size[rownames(g), 4], Enrichment=g[, 'Odds_Ratio'], 
             Rand=rand, Pvalue=g[, 'P_HyperGeo'], FDR=g[, 'FDR_BH']);
}); 

########################################################################################################
# Biclustering
bic<-lapply(ora, function(g) if (nrow(g[[1]])<5) NA else BiclusterFromList(g[[2]][rownames(g[[1]])[1:min(250, nrow(g[[1]]))]]));
ora$bicluster<-bic;

bic2gs<-lapply(bic, function(bic) lapply(bic[[2]], rownames));
gs2bic<-lapply(bic2gs, function(b) lapply(split(rep(1:length(b), sapply(b, length)), unlist(b, use.names=FALSE)), function(x) sort(unique(x))));
gs2bic<-lapply(gs2bic, function(b) sapply(b, function(b) paste(b, collapse=';')));

########################################################################################################
# Output tables
ora.table<-lapply(names(ora.table), function(nm) {
  b<-gs2bic[[nm]];
  b<-b[rownames(ora.table[[nm]])];
  b[is.na(b)]<-'';
  ora.table[[nm]]$Cluster<-b;
  ora.table[[nm]];
});
names(ora.table)<-names(bic);
```

```{r write_ora, include=FALSE}
# Split results into tables by collections
ora.wrapped<-lapply(names(ora.table), function(nm) {
  pth<-paste(path.ora, nm, 'table', sep='/');
  if (!file.exists(pth)) dir.create(pth, recursive = TRUE); 
  WrapGSE(ora.table[[nm]][, -(1:3)], geneset$meta, pth, TRUE); 
});
names(ora.wrapped)<-names(ora.table);

# create index.html file
ora.tbl<-lapply(ora.wrapped, function(o) {
  n<-lapply(o$formatted, function(o) sapply(o, nrow)); 
  fn<-unlist(o$file, use.names=FALSE); 
  fn<-sub(paste(path.ora, '/', sep=''), '', fn); 
  s<-rep(names(n), sapply(n, length));
  c<-unlist(lapply(n, names), use.names=FALSE); 
  n<-as.vector(unlist(n, use.names=FALSE)); 
  tbl<-data.frame(Source=s, Collection=c, N=n, stringsAsFactors = FALSE);
  tbl$N<- AddHref(tbl$N, fn);
  rownames(tbl)<-paste(tbl[[1]], tbl[[2]], sep='_'); 
  tbl
});
u<-sort(union(rownames(ora.tbl[[1]]), rownames(ora.tbl[[2]]))); 
ora.tbl<-lapply(ora.tbl, function(t) {
  t<-t[u, ];
  t[is.na(t[,3]), 3]<-0; 
  rownames(t)<-u; 
  t;
});
ora.ind<-cbind(ora.tbl[[1]], N2=ora.tbl[[2]]$N); 
ora.ind[is.na(ora.ind[,1]), 1]<-ora.tbl[[2]][is.na(ora.ind[,1]), 1]; 
ora.ind[is.na(ora.ind[,2]), 2]<-ora.tbl[[2]][is.na(ora.ind[,2]), 2]; 
names(ora.ind)<-c('Source', 'Collection', names(ora.wrapped)); 
CreateDatatable(ora.ind, paste(path.ora, 'index.html', sep='/'), rownames = FALSE, caption = "Click on number to see list"); 

# All tested gene sets
gs.table<-lapply(split(geneset[[1]][, 'Collection'], geneset[[1]][, 'Source']), table);
gs.table<-data.frame(stringsAsFactors = FALSE, Source=rep(names(gs.table), sapply(gs.table, length)), 
                     Collection=unlist(lapply(gs.table, names), use.names=FALSE), Geneset=as.numeric(unlist(gs.table)));
CreateDatatable(gs.table, paste(path.ora, 'geneset.html', sep='/'), rownames = FALSE, caption = "Gene set collections");

# Formatted tables of ORA results
stat.slim<-data.frame(anno[rownames(stat), 1, drop=FALSE], FormatNumeric(stat));
ora.formatted<-lapply(names(ora.table), function(nm) {  
  if (!file.exists(paste(path.ora, nm, sep='/'))) dir.create(paste(path.ora, nm, sep='/'));
  if (!file.exists(paste(path.ora, nm, 'term', sep='/'))) dir.create(paste(path.ora, nm, 'term', sep='/'));
  
  t<-ora.table[[nm]];
  an<-geneset[[1]][rownames(t), ];
  t$Term<-AddHref(t$Term, an[, 'URL']);
  t$Total[1:min(250, nrow(t))]<-AddHref(t$Total[1:min(250, nrow(t))], paste('./term/term_', 1:min(250, nrow(t)), '.html', sep=''));

  t<-FormatNumeric(t);
  CreateDatatable(t, fn=paste(path.ora, nm, 'term.html', sep='/'), rownames = FALSE);
  sapply(1:min(250, nrow(t)), function(i) { 
    g<-geneset$list[rownames(t)[i]][[1]];
    t1<-stat.slim[rownames(stat.slim) %in% g, , drop=FALSE];
    t1<-t1[order(abs(t1[, 'Rank'])), , drop=FALSE];
    fn<-paste(path.ora, nm, 'term', paste('term_', i, '.html', sep=''), sep='/');
    GeneList2Datatable(t1, fn, genome = genome, title = rownames(t)[i]);
  });
  
  t;
}); 
names(ora.formatted)<-names(ora.table);

# Formatted table of biclustering
bic.formatted<-lapply(names(bic), function(nm) {
  if (!file.exists(paste(path.ora, nm, sep='/'))) dir.create(paste(path.ora, nm, sep='/'));
  if (!file.exists(paste(path.ora, nm, 'bicluster', sep='/'))) dir.create(paste(path.ora, nm, 'bicluster', sep='/'));
  
  t<-awsomics::FormatNumeric(bic[[nm]]$summary);
  
  # write individual files of biclusters
  fns<-sapply(1:nrow(t), function(i) {
    fn<- paste(path.ora, nm, 'bicluster', paste(t[i, 1], c('_terms.html', '_genes.html', '_heatmap.pdf'), sep=''), sep='/');
    t1<-ora.formatted[[nm]][rownames(bic[[nm]][[2]][[i]]), ];
    CreateDatatable(t1, fn[1], FALSE, caption=paste('Terms of', t[i,1]));
    t2<-stat.slim[colnames(bic[[nm]][[2]][[i]]), , drop=FALSE];
    t2<-t2[order(t2[, 'Rank']), , drop=FALSE];
    GeneList2Datatable(t2, fn[2], genome = genome, title=paste('Genes of', t[i,1])); 
    t3<-bic[[nm]][[2]][[i]];
    rownames(t3)<-paste(ora.table[[nm]][rownames(t3), 2], ora.table[[nm]][rownames(t3), 3], sep=' - ');
    colnames(t3)<-paste(rownames(anno[colnames(t3), , drop=FALSE]), CleanHtmlTags(anno[colnames(t3), 1]), sep=' - ');
    if (min(t3)==1) col.min<-'#0000FF' else col.min<-'#999999';
    PlotHeatmap(t3, size.max=Inf, fn=sub('.pdf$', '', fn[3]), col.min=col.min, col.max='#0000FF');
    fn;
  });
  bic.fn<-t(fns);
  
  # write index table
  t$Num_Terms<-AddHref(t$Num_Terms, sub(paste(path.ora, nm, sep='/'), '\\.', bic.fn[, 1]));
  t$Num_Genes<-AddHref(t$Num_Genes, sub(paste(path.ora, nm, sep='/'), '\\.', bic.fn[, 2]));
  t$ID<-AddHref(t$ID, sub(paste(path.ora, nm, sep='/'), '\\.', bic.fn[, 3]));
  CreateDatatable(t, fn=paste(path.ora, nm, 'bicluster.html', sep='/'), rownames = FALSE);
  
  t;
});

# Summary table in the report
rownames(gs.table) <- paste(gs.table[, 1], gs.table[, 2], sep='_'); 
t <- cbind(ora.ind, Total=gs.table[rownames(ora.ind), 3])[, c(1, 2, 5, 3, 4)];
CreateDatatable(t, paste(path.ora, 'index.html', sep='/'), rownames = FALSE, caption = "Click on number to see list"); 
t[, 4:5] <- sapply(4:5, function(i) CleanHtmlTags(t[, i])); 
t[, 4:5] <- sapply(colnames(t)[4:5], function(nm) {
  x <- as.numeric(as.vector(t[, nm])); 
  y <- paste('[', x, '](ORA/', nm, '/table/', as.vector(t[, 1]), '/', as.vector(t[, 2]), '.html', ')', sep=''); 
  y[x==0] <- '0';
  y;
});
```

ORA evaluates whether the genes of any predefined gene sets, such as a KEGG pathway or GO term, are over-represented in lists of DEGs. Hypergeometric test evaluates whether ***N/Nt*** is significantly greater than ***M0/Mt***, where ***Mt*** is the total number of genes in the data set, ***M*** is the total number of genes in both of the data set and a gene set, ***Nt*** is the total number of DEGs previously selected, and ***N*** is the overlapping of ***M*** and ***Nt***. 

Gene sets of several model animals have been collected and can be found [here](https://github.com/zhezhangsh/RoCA/tree/master/data/gene.set). All gene sets with at least `r min(geneset[[1]][, 'Size'])` genes measured by the data set are tested and organized into collections, such as KEGG pathways and miRNA targets. False discovery rate is estimated within gene set collections separately.

<div style="color:darkblue; padding:0 1cm">
**Table 2.** Summary of ORA results. Numbers indicate the significant gene sets (p < 0.05) enriched in the DEGs with higher and lower expression in `r g2.name`. Click the numbers to view the full statistical results of individual gene sets.
</div>

<div align='center', style="padding:0 1cm">
`r kable(t, row.names=FALSE, align=c('l', 'l', 'c', 'c', 'c'))`
</div>

***
_END OF DOCUMENT_


