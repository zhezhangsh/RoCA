---
title: "Two-group differential gene expression"
author: "`r if (exists('yml')) yml$analyst else 'Jim Zhang'`"
date: "`r Sys.Date()`"
output:
  html_document:
    number_sections: yes
    self_contained: no
    toc: yes
    toc_float:
      collapsed: no
---

<div style="border:black 1px solid; padding: 0.5cm 0.5cm">
**Introduction** This procedure performs a two-group comparison of all genes in a transcriptome data set. It accepts both signal intensities from microarray and read counts from RNA-seq. All genes must be annotated with NCBI [Entrez](http://www.ncbi.nlm.nih.gov/gene) unique gene IDs. The main elements of this procedure include:

  - Sample-level analysis
    - Overall distribution of gene expression level and between-sample variance
    - Sample similarity evaluated via sample-sample correlation, hierarchical clustering and principal components analysis
  - Gene-level analysis
    - Statistical test of group means on each genes. Call DeWrapper() to find available statistical tests, such as [Significance Analysis of Microarrays](http://statweb.stanford.edu/~tibs/SAM/) for microarray data and [edgeR](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2796818/) for RNA-seq read count data
    - Visualization of differential gene expression through M-A plot, Volcano plot, heatmap, etc.
    - Selection of top-ranked differentially expressed genes (DEGs)
  - Gene set-level analysis
    - Over-representation analysis (ORA)
    - [Gene set enrichment analysis (GSEA)](http://software.broadinstitute.org/gsea/index.jsp)
    - Visualization of [KEGG pathway](http://www.genome.jp/kegg/pathway.html) maps
    - Gene-gene set biclustering
    
</div>

&nbsp;

```{r global_setup, include=FALSE}
name.yaml <- 'pairwise_comparison.yaml'; 
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'MASS', 'gplots', 'pathview', 'PGSEA', 
                   'flexclust', 'colorspace', 'RoCA', 'rchive', 'awsomics', 'DEGandMore'); 
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table', 'path.deg'='DEG', 
                     'path.ora'='ORA', 'path.gsea'='GSEA');

## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);

if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));

## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
  if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
    yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template

prms <- yml$parameter;

## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]); 

## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
```

```{r load_data, include=FALSE}
inputs<-yml$input;

# All input variables
anno <- inputs$anno <- ImportTable(DownloadFile(inputs$anno, path.input));
expr <- inputs$expr <- as.matrix(ImportTable(DownloadFile(inputs$expr, path.input)));
grps <- inputs$comparison <- ImportR(DownloadFile(inputs$comparison, path.input));
geneset <- inputs$geneset <- ImportR(DownloadFile(inputs$geneset, path.input));

genome  <- prms$genome;
paired  <- prms$paired;
g1.ind  <- intersect(colnames(expr), grps[[1]]);
g2.ind  <- intersect(colnames(expr), grps[[2]]);
g1.name <- gsub('-', '_', names(grps)[1]);
g2.name <- gsub('-', '_', names(grps)[2]);

anno <- anno[rownames(anno) %in% rownames(expr), , drop=FALSE]; 
expr <- expr[rownames(anno), , drop=FALSE]; 
if (is.null(paired)) paired <- FALSE; 
if (paired & length(g1.ind)!=length(g2.ind)) paired <- FALSE;
if (is.null(g1.name)) g1.name <- 'Group_1';
if (is.null(g2.name)) g2.name <- 'Group_2';

# Check validity of inputs
if (nrow(expr) < 3)   stop('Less than 3 genes in the data set, cannot continue.\n');
if (is.null(g1.ind))  stop('Error: Index of samples in group 1 unknown\n');
if (is.null(g2.ind))  stop('Error: Index of samples in group 2 unknown\n');
if (length(g1.ind)<2) stop('Error: Not enough samples in group ', g1.name, ' (minimum=2), cannot continue.\n');
if (length(g2.ind)<2) stop('Error: Not enough samples in group ', g2.name, ' (minimum=2), cannot continue.\n');

# Re-process gene expression matrix
e1<-expr[, g1.ind, drop=FALSE];
e2<-expr[, g2.ind, drop=FALSE];
e1.2<-cbind(e1, e2); 
pctl<-apply(e1.2, 2, function(e) 100*rank(e)/length(e)); # percentile
norm<-NormQQ(e1.2); 

inputs$expr <- e1.2;
inputs$anno <- anno[rownames(e1.2), ]; 
if (!prms$processing$logged) inputs$logged <- e1.2 <- log2(e1.2+1); 
if (!prms$processing$normalized) inputs$normalized <- e1.2 <- NormLoess(e1.2); 

yml$gsea$jar <- DownloadFile(yml$input$gsea, path.input); 

dir.gmt <- paste(path.input, 'gmt', sep='/'); 
if (file.exists(dir.gmt)) unlink(dir.gmt, recursive = TRUE); 
dir.create(dir.gmt, recursive = TRUE); 
yml$gsea$gmt <- lapply(yml$input$gmt, function(x) DownloadFile(x, dir.gmt)); 

# .xml files of KEGG pathway maps 
dir.kegg <- paste(path.input, 'kegg', sep='/'); 
if (file.exists(dir.kegg)) unlink(dir.kegg, recursive = TRUE); 
dir.create(dir.kegg, recursive = TRUE); 
if (!is.null(yml$input$kegg)) {
  if (dir.exists(yml$input$kegg)) {
    kegg.fns <- dir(yml$input$kegg); 
    kegg.fns <- kegg.fns[grep('.xml$', kegg.fns, ignore.case = TRUE)]; 
    file.copy(paste(yml$input$kegg, kegg.fns, sep='/'), paste(dir.kegg, kegg.fns, sep='/'), overwrite = TRUE) -> x; 
  } else if (url.exists(yml$input$kegg)) {
    x <- DownloadFile(yml$input$kegg, dir.kegg);
    if (grepl('.zip$', x)) {
      fns.xml <- unzip(x, exdir=dir.kegg);
      file.rename(fns.xml, paste(dir.kegg, TrimPath(fns.xml), sep='/')) -> x; 
    }
  }
}

inputs$parameters<-prms;
res<-list(inputs=inputs);  # Result set
```

`r home.url` 

<div align='center'> <span style="color:blue; font-family:Georgia; font-size:2.5em;"> `r g1.name` </span> <span style="color:black; font-family:Georgia; font-size:2em;"> vs. </span> <span style="color:red; font-family:Georgia; font-size:2.5em;"> `r g2.name` </span> </div>

# Results at a glance

```{r analysis_deg, include=FALSE}
deg.sub <- paste(c('Higher', 'Lower'), 'in', g2.name, sep='_'); 

# parameters of differential expression
deg.method <- prms$deg$method;
cutoff.l2r <- prms$deg$cutoff.l2r;
cutoff.p   <- prms$deg$cutoff.p;
cutoff.fdr <- prms$deg$cutoff.fdr;
num.top    <- prms$deg$num.top;
nperm      <- prms$deg$nperm;

means <- cbind(rowMeans(e1.2[, g1.ind]), rowMeans(e1.2[, g2.ind]));
colnames(means) <- c(g1.name, g2.name);
l2r <- means[,2]-means[,1]; 
l2r[is.na(l2r)] <- 0;
fc <- exp(l2r*log(2));
mn <- cbind(means, l2r, fc);
colnames(mn) <- c(paste('Mean', names(grps), sep='_'), 'LogFC', 'FoldChange');

# Adjust expr matrix if a penalty is given for large between-sample variance
penalty <- prms$deg$penalty;
if (is.na(penalty) | is.null(penalty) | prms$deg$method!='DeRankP') penalty <- 0; 
if(penalty>0) {
  if (penalty>1) penalty<-1;
  colnames(means)<-paste('Mean_', c(g1.name, g2.name), sep='');
  if (paired) sd<-apply(e1.2[, g2.ind]-e1.2[, g1.ind], 1, sd) else {
    v1<-apply(e1.2[, g1.ind], 1, var);
    v2<-apply(e1.2[, g2.ind], 1, var);
    df1<-length(g1.ind)-1;
    df2<-length(g2.ind)-1;
    sd<-sqrt((df1*v1+df2*v2)/(df1+df2));
    sd[sd==0]<-min(sd[sd>0])/2;
  }
  pnl <- quantile(sd, probs=seq(0, 1, 0.01))[100*round(1-penalty,2)+1];
  e <- e1.2; # keep the original
  e[, g2.ind] <- apply(e[, g2.ind], 2, function(d) means[,1]+(d-means[,1])/(pnl+sd));
} else e<-e1.2;

if (!prms$deg$reprocessed) e <- expr[, colnames(e1.2)]; 

##########################################################################################################################
de<-DeWrapper(mtrx=e, grps=grps, mthd=deg.method, paired=paired, logged=prms$processing$logged, args=list(nperm=nperm)); #
##########################################################################################################################

#de$results$stat[, c(1,2,4)]<-mn[, 1:3];
#de$results$stat[, 3]<-de$results$stat[, 2]-de$results$stat[, 1]; 
if (deg.method == "DeRankP") { # Rank Product methods
  s<-de$results$stat; 
  rp<-de$results$rp$summarized; 
  out<-lapply(rp, function(x) x[, c('Rank', 'Pvalue', 'FDR')]);
  out[[3]]<-cbind(out[[1]], out[[2]]);
  cnm<-rep(deg.sub, each=3);
  colnames(out[[3]])<-paste(colnames(out[[3]]), cnm, sep='_')
  out<-lapply(out, function(out) cbind(mn[rownames(out), , drop=FALSE], out));
  names(out)<-c(deg.sub, 'Single_rank');
  degs<-lapply(out[1:2], function(x) {
    deg<-x[x[, 'Pvalue']<=cutoff.p & x[, 'FDR']<=cutoff.fdr & abs(x[, 'LogFC'])>=cutoff.l2r, , drop=FALSE];
    if (nrow(deg) < num.top) deg<-x[x[, 'Pvalue']<=cutoff.p & x[, 'Rank']<=num.top, , drop=FALSE]; 
    deg;
  }); 
  degs<-lapply(degs, function(d) d[order(d[, 'Rank']), ]);
} else {
  out<-de$results$stat;
  degs<-lapply(c(1, -1), function(di) {
    x<-out[sign(out[, 'LogFC'])==di, , drop=FALSE];
    deg<-x[x[, 'Pvalue']<=cutoff.p & x[, 'FDR']<=cutoff.fdr & abs(x[, 'LogFC'])>=cutoff.l2r, , drop=FALSE];
    if (nrow(deg) < num.top) deg<-x[x[, 'Pvalue']<=cutoff.p & abs(x[, 'LogFC'])>=sort(abs(x[, 'LogFC']), decreasing = TRUE)[min(num.top, nrow(x))], , drop=FALSE]; 
    deg;
  }); 
  degs<-lapply(degs, function(d) d[order(-1*abs(d[, 'LogFC'])), , drop=FALSE]);
}

stat<-de$results$stat[, 1:6];
z <- tolower(prms$deg$rank[1]);
if (length(z) == 0) z <-'both'; 
if (z=='p') rnk <- -log10(stat[, 'Pvalue'])*sign(stat[,'LogFC']) else 
  if (z=='fc') rnk <- stat[, 'LogFC'] else 
    rnk <- sign(stat[,'LogFC'])*sqrt(abs(log10(stat[, 'Pvalue'])*stat[, 'LogFC'])); 
x <- -rank(rnk); 
y <- rank(-rnk); 
rk <- rep(NA, length(x));
rk[rnk>0] <- y[rnk>0];
rk[rnk<0] <- x[rnk<0];
stat <- cbind(stat, Rank=rk); 
names(rk) <- names(rnk) <- rownames(stat); 

stat.table<-cbind(anno[rownames(stat), ], stat);
stat.formatted<-FormatNumeric(cbind(ID=rownames(stat.table), stat.table));
stat.formatted$ID<-AddHref(stat.formatted$ID, UrlEntrezGene(stat.formatted$ID));
CreateDatatable(stat.formatted, fn = paste(path, 'DEG', 'all_genes.html', sep='/'), rownames = FALSE, caption = "Differential expression of all genes");

names(degs) <- deg.sub;
de$data<-e; 
de$DEG <- degs;
up <- degs[[1]];
dn <- degs[[2]];
#saveRDS(de, file=paste(path.r, 'deg_all.rds', sep='/')); 
```

```{r glance, include=FALSE}
if (yml$zip) l <- paste('; [All files](', TrimPath(path) ,'.zip)', sep='') else l <- '';
```
<div style="background-color:rgba(0, 0, 0, 0.025); font-size:1.5em; padding:60px 0">
    
Click links below to go directly to results or read the rest of this report for details: 
  
  - [Differential gene expression](DEG/all_genes.html)
    - [`r nrow(degs[[1]])` DEGs with higher expression in `r g2.name`](`r paste('DEG', names(degs)[1], 'index.html', sep='/')`)
    - [`r nrow(degs[[2]])` DEGs with lower expression in `r g2.name`](`r paste('DEG', names(degs)[2], 'index.html', sep='/')`)
  - [ORA](ORA/index.html) (Over-representation analysis) 
  - [GSEA](GSEA/index.html) (Gene set enrichment analysis)
    - [All top hits](GSEA/full_table.html)
    - [KEGG pathway maps](GSEA/kegg/index.html)
  - [Biclustering](table/bicluster_index.html) of significant genes and gene sets
  - Download [Figures](figure/figures.zip); [Tables](table/tables.zip); [R objects](R/R.zip)`r l`
</div>

`r home.url` 

# Description
  
`r WriteDescription(yml$description)`

`r home.url` 

# Data and methods

```{r data_methods, include=FALSE}
rank <- tolower(prms$deg$method)[1];
if (rank == 'p') l1 <- 'p value only' else if (rank == 'fc') l1 <- 'fold change only' else l1 <- 'both p value and fold change'
```

This report is generated based on the following inputs:

  - **Gene expression data**: 
    - **File location:** `r yml$input$expr`
    - **Number of genes:** `r nrow(expr)`
    - **Number of samples:** `r ncol(e1.2)`
    - **Log2-transformed:** `r prms$processing$logged`
    - **Normalized:** `r prms$processing$normalized`
  - **Gene annotation:** 
    - **File location:** `r yml$input$anno`
    - **Column names:** `r paste(colnames(anno), collapse='; ')`
    - **Genome:** `r prms$genome`
  - **Comparison:** 
    - **Group0, `r g1.name`:** `r paste(colnames(e1), collapse='; ')` (n=`r ncol(e1)`)
    - **Group1, `r g2.name`:** `r paste(colnames(e2), collapse='; ')` (n=`r ncol(e1)`)
    - **Paired:** `r prms$paired`
  - **Differential gene expression:** 
    - **Statistical method:** `r prms$deg$method`
    - **Rank gene:** `r l1`
    - **Use reprocessed data:** `r prms$deg$reprocessed`
  - **Select top genes:**
    - **P value cutoff:** `r prms$deg$cutoff.p`
    - **FDR cutoff:** `r prms$deg$cutoff.fdr`
    - **Log2(fold change) cutoff:** `r prms$deg$cutoff.l2r`
    - **Maximum number of genes:** `r prms$deg$num.top`
  - **Gene set analysis:**
    - **Gene set collection:** `r yml$input$geneset` (`r nrow(geneset[[1]])` total gene sets)
    - **GSEA Java program:** `r yml$input$gsea`
    - **GSEA .gmt files:**
    
`r paste(paste('        - **', names(yml$gsea$gmt), ':** ', unlist(yml$gsea$gmt), sep=''), collapse='\n')`

  - **Path to all outputs:** `r path`

`r home.url` 

# Analysis and results

## Sample analysis
  
This section analyzes the samples by summarizing their global expression patterns, through descriptive statistics, unsupervised clustering, and sample-sample correlation.
  
### Data distribution

Distribution of average expression level and between-sample variance. 

<div align='center'>
```{r data_distribution, include=TRUE, fig.width=6.4, fig.height=8, out.width='640px'}
par(mfrow=c(3,1), mar=c(4,5,2,2));

# Distribution of average expression level
m<-rowMeans(e1.2);
d<-density(m);
x<-d$x;
y<-d$y;
plot(d, type='n', yaxs='i', xaxs='i', xlim=c(min(x), max(x)), ylim=c(0, 1.1*max(y)), xlab='', ylab='Density', main='A. Distribution of Expression Level', cex.lab=2, cex.main=1.5);
title(xlab='Average expression level of genes', line=2, cex=2);

x0<-as.vector(summary(m))[2:5];
y0<-sapply(x0, function(x0, x, y) y[which(abs(x-x0)==min(abs(x-x0)))], x=x, y=y);
col<-c('blue', 'red', 'orange', 'green');
segments(x0, 0, x0, y0, lty=1, col=col, lwd=1);
lines(d, col='darkgrey', lwd=4); 
text(x0, y0/2, srt=90, labels=round(x0, 3));
legend('topright', legend=c('First quantile', 'Median', 'Mean', 'Third quantile'), lty=1, col=col, bty='n', lwd=2);

# Distribution of standard deviation across samples
sd<-apply(e1.2, 1, sd);
d<-density(sd); 
x<-d$x;
y<-d$y;
plot(d, type='n', yaxs='i', xaxs='i', xlim=c(min(x), max(x)), ylim=c(0, 1.1*max(y)), xlab='', ylab='Density', main='B. Distribution of Variance', cex.lab=2, cex.main=1.5);
title(xlab='Standard deviation of genes', line=2, cex=2);

x0<-as.vector(summary(sd))[2:5];
y0<-sapply(x0, function(x0, x, y) y[which(abs(x-x0)==min(abs(x-x0)))], x=x, y=y);
col<-c('blue', 'red', 'orange', 'green');
segments(x0, 0, x0, y0, lty=1, col=col, lwd=1);
lines(d, col='darkgrey', lwd=4);
text(x0, y0/2, srt=90, labels=round(x0, 3));
legend('topright', legend=c('First quantile', 'Median', 'Mean', 'Third quantile'), lty=1, col=col, bty='n', lwd=2);

plot(m, sd, xlab='', ylab='Standard Deviation', main='C. Variance vs. Expression Level', cex.lab=2, cex.main=1.5, cex=0.5, col='darkgrey');
title(xlab='Average expression level of genes', line=2, cex=2);
lines(lowess(m, sd), lwd=3, col=2);
```
</div>

<div style="color:darkblue; padding:0 0.5cm">
 - **Figure 1A.** This figure is based on the average expression measurements of all genes. If the measurements have been log-transformed, they often have a bi-modal (two-peak) distribution: a high and narrow peak on the left corresponding to inactive genes and a relatively lower and wider peak on the right corresponding to actively expressed genes. If the base of log-transformation is 2, a difference of 1.0 on the x-axis corresponds to a 2-fold change of expression. Similarly, if the base is 10, the corresponding expression change is 10-fold per 1.0 difference on the x-axis. (note that microarray measurements, raw or processed, are not exactly proportional to the actual mRNA abundancy, so the term fold change should not be taken literally.)
 - **Figure 1B.** This figure is based on the between-sample standard deviations of all genes. The distribution usually has a single peak and a long tail on the right side. An enlarged tail usually indicates more genes are differentially expressed between samples. In a high quality data set, a gene not differentially expressed between samples should have small variance. So, if we assume that the majority of genes have no or little differential expression, the skewness of the peak towards the left side roughly represents data quality. 
 - **Figure 1C.** This figure summarizes the relationship between gene expression measurements and their between-sample variance. Genes having smaller variance are more likely to get significant results from Student t test and similar methods. So, if there is a strong dependency of variance on expression measurements, the analysis of differential expression will be affected by the baseline expression level of genes. Variance stabilization procedure is commonly used during data normalization to minimize such dependency. In the figure, the red line is the result of LOWESS smoothing and the majority of this line should be approximately straight and horizontal if the data has been normalized properly. In practice, the LOWESS line is usually a curve higher in the middle.
</div>

`r home.url` 

### Sample similarity

By comparing gene expression patterns of different samples, observations can be made about the sample similarity. This section compares samples via data distribution, hierarchical clustering, and principal components analysis, which can potentially be used to identify outliers and confounding variables. 

<div align='center'>
```{r analysis_boxplot, include=TRUE, fig.width=6.4, fig.height=4, out.width='640px'}
par(mfrow=c(1,1), mai=c(0.7, 0.6, .1,.1))
plot(0, type='n', xlim=c(0.5, 0.5+ncol(e1.2)), ylim=c(min(e1.2), max(e1.2)), ylab='', xlab='', xaxt='n'); 
lines(1:ncol(e1.2), apply(e1.2, 2, median), col='green', lwd=1);
title(ylab='Expression Level', line=2);
cex<-max(strwidth(colnames(e1.2), unit='in'));
boxplot(data.frame(e1.2), las=3, notch=TRUE, boxwex=.6, col=c(rep('lightgrey', ncol(e1)), rep('lightblue', ncol(e2))), names=colnames(e1.2), cex.axis=min(1, 0.4/cex), yaxt='n', add=TRUE, pch=19, cex=0.4)->x;
```
</div>

<div style="color:darkblue; padding:0 0.5cm">
**Figure 2.** Each boxplot summarizes the expression measurements of all genes in one sample. Based on the assumption that all samples have approximately the same global distribution of gene expression measurements, all boxes should look similar regardless of which group they belong to. This assumption is not always true though. For example, normal cells and cancer cells could have dramatically different global patterns of gene expression. The notches of each box indicate the median, the lower and upper sides of the box represent the first and third quantile, and the individual data points out of the whiskers are the outliers (more than 1.5 inter-quantile range from the median).
</div>

<div align='center'>
```{r analysis_clustering, include=TRUE, fig.width=6.4, fig.height=4.8, out.width='640px'}
par(mfrow=c(1,1), mai=c(0.2, 0.8, .2 , .2));
plot(hclust(dist(t(e1.2))), main='', ylab='', xlab='', sub='', cex=min(1, 5/ncol(e1.2)/0.12), frame.plot=TRUE);
title(ylab='Distance', line=2.5, cex.lab=2);
```
</div>

<div style="color:darkblue; padding:0 1cm">
**Figure 3.** This is an unsupervised clustering of samples used all genes in the data set. On the clustering tree, the vertical location of their lowest common node of any two samples represents their similarity (lower = more similar). Since the sample grouping information is not used, the splitting of samples into two sub-trees will indicate that these samples belong to different groups due to a known or unknown factor. Unexpected splitting often suggest outliers or confounding variables. 
</div>

<div align='center'>
```{r analysis_pca, include=TRUE, fig.width=6.4, fig.height=4.8, out.width='640px'}
pca<-prcomp(t(e1.2));

X<-pca$x[,1];
Y<-pca$x[,2];
per<-round(summary(pca)$importance[2, 1:2]*100, 2);
pca$importance<-summary(pca)$importance;
res$pca<-pca;

col<-rep(c('darkgreen', 'deeppink1'), c(length(g1.ind), length(g2.ind)));

layout(matrix(1:2, nrow=1), width=c(3,1));
par(mai=c(1,1,.25,.25));

cx<-max(0.5, min(3, 64/length(X)))
plot(X, Y, col=col, pch=19, cex=cx, xlim=c(min(X)*1.1, max(X)*1.1), ylim=c(min(Y)*1.1, max(Y)*1.1), 
     xlab=paste('PC1', ', ', per[1], '%', sep=''), ylab=paste('PC2', ', ', per[2], '%', sep=''), cex.lab=1.5);

text(X, Y, label=1:length(X), col='white', cex=.3*cx);

par(mai=c(1, 0, 0.25, 0));
plot(0, type='n', xlim=c(0, 100), ylim=c(1, 100), axes=FALSE, bty='n', xaxs='i', yaxs='i', xlab='', ylab='');

w<-strwidth(1:length(X), cex=1.2);
w0<-1.2*80/max(w, 80);
h0<-1.2*(100/length(X))/4.0;
cex<-min(1.2, w0, h0); 

points(rep(5, length(X)), 100-(1:length(X))*4.0*cex, col=col, pch=19, cex=1.5*cex);
text(5+cex*5, 100-(1:length(X))*4.0*cex, labels=colnames(e1.2), adj=0, col=col, pch=19, cex=cex);
text(rep(5, length(labels)), 100-(1:length(X))*4.0*cex, labels=1:length(X), col='white', cex=0.8*cex);
```
</div>

<div style="color:darkblue; padding:0 1cm">
**Figure 4.** Principal Components Analysis (PCA) is also an unsupervised analysis that converts a large number of correlated variables (genes) into a smaller set of uncorrelated variables called principal components (PCs). Each principal component accounts for certain percentage of total variability of a data set so the PCs can be ordered by their percentages. This figure plots the top two PCs on the two axes. In general, samples closer to each other have more similar gene expression patterns. PCA can be used to identify sample features, such as age, disease, and treatment, that are associated with one or two PCs. It then can be concluded that these features are responsible for part of the total variability in the data set.
</div>

`r home.url` 

## Differential gene expression

  - **Fold change, percentage change, ratio, or log2-ratio:** These statistics indicate the magnitude of the difference of group averages. They are the same values in different scale and can be easily converted to each other (see **Appendix 1**). Given the data has been log2-transformed, the difference of group averages is equivalent to the log2-ratio of unlogged data as _log2(A/B)==log2(A)-log2(B)_. So, group difference will be referred as log2-ratio throughout this report. 

  - **p value, q value, or FDR:** These statistics indicates the statistical significance of group difference.  P value refers to type I error of statistical test, or the chance to mistakenly conclude the differential expression of a gene while the gene is actually unchanged. RP estimates both p values and FDR based on a permutation procedure during which the ranked gene lists were shuffled to generate a background distribution of rank products.

### DEG summary

<div align='center'>
```{r deg_plot, include=TRUE, fig.width=6.4, fig.height=4.8, out.width='800px'}
par(mai=c(0.4, 0.5, 0.3, 0.05), mfrow=c(2,2));

#if (class(out)=='list') d<-out[[length(out)]] else d<-out;
d<-cbind(mn, de$results$stat[, 5:6]);

# M-A Plot
x <- rowMeans(mn[, 1:2]); 
y <- stat[, 4];
plot(x, y, main='A. M-A Plot', pch=19, col='darkgrey',  cex=.25, xlab='', ylab='', cex.axis=.75);
abline(h=0, lwd=1, col=1);
lines(lowess(y~x), lwd=2, col=3);
ylab<-paste('Log2(', g2.name, '/', g1.name, ')', sep='');
xlab<-paste('Log2(', g1.name, ')/2 + Log2(', g2.name, ')/2', sep='');
title(xlab=xlab, ylab=ylab, line=1.6, cex.lab=.75);

#Volcano Plot
x<-stat[,'LogFC'];
p<-stat[,'Pvalue'];
y<--1*log10(p);
y[y==Inf] <- max(y[y<Inf])+1; 
z<-sqrt(abs(x*y));
cx<-z/(max(z));
ylim <- min(10, ceiling(max(y))); 
plot(x, y, main='B. Volcano Plot', pch=19, col='darkgrey',  cex=0.8*cx, xlab='', ylab='', cex.axis=.75, ylim=c(0, 1.1*ylim), yaxs='i', xlim=c(-1*max(abs(x)), max(abs(x))), yaxt='n');
xlab<-paste('Log2(', g2.name, '/', g1.name, ')', sep='');
title(xlab=xlab, ylab='P value', line=1.6, cex.lab=.75);
axis(2, at=0:ylim, labels=10^(-1*(0:ylim)));
abline(h=-1*log10(0.05), v=c(-1,1), col=4, lty=3);
box();

# P Value Distribution
hist(p[p<1], br=seq(0, 1, 0.01), cex.axis=.75, main='C. P Value Distribution');
title(xlab='P value', ylab='Count', line=1.6, cex.lab=.75);
box();

# FDR
q<-round(stat[, 'FDR'], 2);
n<-sapply(seq(min(q), 1, 0.01), function(x) length(q[q<=x]));
plot(1, type='n', log='y', xlab='', ylab='', cex.axis=.75, xlim=0.01*c(1, 100), ylim=c(1, nrow(expr)), 
     main='D. False Discovery Rate');
abline(v=seq(0, 1, .05), lty=3, col=8);
lines(seq(min(q), 1, 0.01), n, lwd=2, col=2);
title(xlab='FDR cutoff', ylab='Count', line=1.6, cex.lab=.75);
box();
```
</div>
  
<div style="color:darkblue; padding:0 0.5cm">
**Figure 5.** The differential expression of all [`r nrow(expr)`](DEG/all_genes.html) genes can be visualized in different ways: 
  
  - **5A:** ***M-A Plot.*** This plot visualizes global pattern of group difference (as log2-ratio). **M** (Y axis) is the log2-ratio and **A** (X axis) is the average measurements of the two groups. Each dot represents a gene and the green line is generated by LOWESS smoothing. The location and shape of the LOWESS line indicate whether there is an overall skewness of differential expression or expression level-dependent differential expression.
  - **5B:** ***Volcano Plot.*** This plot puts together both types of variables (usually **p value** and **log2-ratio**) used to represent differential expression and their association. A common strategy is to only consider genes with both small p values and large log2-ratios as GOI (genes of interest). Each dot represents a gene and its size is proportional to its distance from the [0, 1] point. The horizontal line corresponds to a p value of 0.05 and the vertical lines correspond to 2.0 fold change on both sides. 
  - **5C:** ***P Value Distribution.*** This plot shows the counts of genes whose Rank Product p values are located in each 0.01 interval. So, the leftmost bar indicates the number of genes having p values less than 0.01. If the data is completely random and there are enough samples, the p values will have a uniform distribution, with approximately the same number of genes in each interval. If there are indeed a number of genes differentially expressed between the compared groups and the microarray experiments are properly designed and executed, we expect that the p values have a distribution with the highest density on the left side. If the highest density of the distribution is in the middle or on the right side, we will suspect a confounding factor that has a bigger influence on the data than the factor distinguishing the two compared groups. 
- **5D:** ***FDR.*** This plots traces the number of genes corresponding to each FDR (false discovery rate) cutoff. **Table 1** lists the number of genes corresponding to commonly used FDR cutoffs. 
</div>
  
```{r deg_fdr, include=FALSE}
#FDR counts
c<-c(0.01, 0.02, 0.05, 0.1, 0.15, 0.2, 0.25);
n.fdr<-sapply(c, function(c) sapply(c(1, -1), function(di) 
  nrow(stat[sign(stat[, 'LogFC'])==di & stat[, 'FDR']<=c, , drop=FALSE])));
fdr.table<-cbind(c, t(n.fdr), colSums(n.fdr)); 
colnames(fdr.table)<-c('FDR', deg.sub, 'Total')
de$FDR <- fdr.table;
de$parameter <- prms; 

# pre-ranking of genes
rnk<-sign(stat[, 'LogFC'])*sqrt(stat[,'LogFC']^2+log10(p)^2);
```

<div style="color:darkblue; padding:0 2cm">
  **Table 1.** Number of top DEGs selected via different cutoffs of FDR. FDRs are calculated using the Benjamini&Hochberg method (_Controlling the false discovery rate: a practical and powerful approach to multiple testing_. Journal of the Royal Statistical Society Series B 57, 289â€“300. 1995)
</div>
  
<div align='center', style="padding:0 2.5cm">
`r kable(fdr.table, row.names=FALSE)`
</div>

`r home.url` 

### Top genes
  
```{r write_deg, include=FALSE}
path.deg1<-paste(path.deg, deg.sub[1], sep='/');
path.deg2<-paste(path.deg, deg.sub[2], sep='/');
path.deg1.bars<-paste(path.deg1, '/bars', sep='');
path.deg2.bars<-paste(path.deg2, '/bars', sep='');

if (!exists(path.deg)) dir.create(path.deg, showWarnings = FALSE);
if (!exists(path.deg1.bars)) dir.create(path.deg1.bars, showWarnings = FALSE, recursive = TRUE);
if (!exists(path.deg2.bars)) dir.create(path.deg2.bars, showWarnings = FALSE, recursive = TRUE);
ids<-c(up=rownames(up), dn=rownames(dn));
names(ids)<-paste(rep(c(path.deg1.bars, path.deg2.bars), c(nrow(up), nrow(dn))), '/', ids, '.pdf', sep='');

col<-rep(c('lightgrey', 'lightblue'), c(length(g1.ind), length(g2.ind)));
wid<-min(1.8, 1.2/(0.1*max(nchar(colnames(expr[, c(g1.ind, g2.ind)])))));
fn.barplot<-sapply(names(ids), function(nm) {
  pdf(nm, w=8, h=6); 
  par(mai=c(1.2, 1, 0.6, 0.2));
  barplot(norm[ids[nm], c(g1.ind, g2.ind)], las=3, col=col, ylab='Normalized expression', cex.lab=wid, cex.names=0.75*wid);
  title(main=paste(ids[nm], CleanHtmlTags(as.vector(anno[ids[nm], 1])), sep=' - '), cex.main=2);
  #plot.new();
  par(mai=c(1.2, 1, 0.6, 0.2));
  barplot(pctl[ids[nm], c(g1.ind, g2.ind)], las=3, col=col, ylab='Percentile (%)', ylim=c(0, 100), cex.lab=2, cex.names=wid);
  title(main=paste(ids[nm], CleanHtmlTags(as.vector(anno[ids[nm], 1])), sep=' - '), cex.main=2);
  
  dev.off();
  nm;
});

# Write index tables of DEGs
cnm<-c(colnames(anno), colnames(up), 'Samples');
up.tbl<-data.frame(anno[rownames(up), , drop=FALSE], up, rep('Figure', nrow(up)));
colnames(up.tbl)<-cnm;
up.tbl$Samples <- AddHref(up.tbl$Samples, paste('bars/', rownames(up), '.pdf', sep='')); 
up.formatted<-GeneList2Datatable(FormatNumeric(up.tbl), paste(path.deg1, 'index.html', sep='/'), col.symbol=1, genome=genome, title=paste('Genes with higher expression in', g2.name));

dn.tbl<-data.frame(anno[rownames(dn), , drop=FALSE], dn, rep('Figure', nrow(dn)));
colnames(dn.tbl)<-cnm;
dn.tbl$Samples <- AddHref(dn.tbl$Samples, paste('bars/', rownames(dn), '.pdf', sep='')); 
dn.formatted<-GeneList2Datatable(FormatNumeric(dn.tbl), paste(path.deg2, 'index.html', sep='/'), col.symbol=1, genome=genome, title=paste('Genes with lower expression in', g2.name));
```

<div align='center'>
```{r deg_top, include=TRUE, fig.width=6.4, fig.height=2.4, out.width='800px'}
# Plot top genes
par(mfrow=c(1,2), mai=c(0.7, 0.35, 0.3, 0.05));
ind<-c(rownames(up)[1], rownames(dn)[1]);

cex<-min(0.75, min(0.5/max(strwidth(colnames(e1.2), unit='in'))));
col<-rep(c('grey', 'lightblue'), c(length(g1.ind), length(g2.ind)));
for (ii in 1:2) barplot(e1.2[ind[ii], ], las=3, cex.names=cex, main=CleanHtmlTags(anno[ind[ii], 1], FALSE), cex.main=.75, cex.axis=.75, col=col);
```
</div>
  
<div style="color:darkblue; padding:0 0.5cm">
**Figure 6.** Top-ranked genes with increased (left) and decreased (right) expression in `r g2.name`. Click [here](DEG/all_genes.html) to view differential expression of all genes.
</div>
  
<div align='center'>
```{r deg_heatmap, include=TRUE, fig.width=6.4, fig.height=6.4, out.width='800px'}
# Plot heatmap of top genes
par(mfrow=c(1,1));
goi<-e1.2[c(rownames(up), rownames(dn)), ];
rownames(goi)<-as.vector(anno[rownames(goi), 1]);
DegHeatmap(goi,  col=rep(c('chartreuse1', 'deeppink1'), c(length(g1.ind), length(g2.ind))), plot.new=FALSE);
```
</div>
  
<div style="color:darkblue; padding:0 0.5cm">
**Figure 7.** Heatmap of the top `r nrow(up)` and `r nrow(dn)` DEGs with higher (red) and lower (yellow) expression in `r g2.name`. Each row represents a DEG, whose expression measurements are normalized across samples. Samples are clustered by these genes and the columns are colored (green = `r g1.name` and red = `r g2.name`). Click links below to view full statistical results of DEGs:
  
  - [Higher in `r g2.name`](DEG/`r deg.sub[1]`/index.html)
  - [Lower in `r g2.name`](DEG/`r deg.sub[2]`/index.html)
</div>

`r home.url` 
  
## Gene-set analysis
  
Predefined gene sets are the unit of all analyses in this section. The assumption is that if genes of the same gene set, such as those in the same signaling pathway or regulated by the same master regulator, are more likely to be differentially expressed between two compared sample groups, the gene set is somehow associated with the biological difference between the groups.

### Over-representation analysis (ORA)

```{r analysis_ora, include=FALSE}
########################################################################################
ora <- lapply(degs, function(gs) TestGSE(rownames(gs), rownames(expr), geneset$list)); #
########################################################################################

names(ora) <- names(degs); 
#saveRDS(ora, paste(path.r, 'ora_all.rds', sep='/')); 

ora.table<-lapply(ora, function(ora) {
  g<-ora$stat;
  lst<-ora$list[rownames(g)];
  rand<-sapply(lst, function(l) { 
    mtrx<-e1.2[rownames(e1.2) %in% l, , drop=FALSE];
    randIndex(table(kmeans(t(mtrx), 2)[[1]], rep(1:2, sapply(grps, length))));
  })
  an<-geneset[[1]][rownames(g), ];
  data.frame(row.names = rownames(g), stringsAsFactors = TRUE, Source=an[,1], Collection=an[,2], Term=an[, 'Name'], 
             Total=rowSums(ora$size[rownames(g), 3:4]), Within=ora$size[rownames(g), 4], Enrichment=g[, 'Odds_Ratio'], 
             Rand=rand, Pvalue=g[, 'P_HyperGeo'], FDR=g[, 'FDR_BH']);
}); 

########################################################################################################
# Biclustering
bic<-lapply(ora, function(g) if (nrow(g[[1]])<5) NA else BiclusterFromList(g[[2]][rownames(g[[1]])[1:min(250, nrow(g[[1]]))]]));
ora$bicluster<-bic;

bic2gs<-lapply(bic, function(bic) if (identical(bic, NA)) NA else lapply(bic[[2]], rownames));
gs2bic<-lapply(bic2gs, function(b) 
  lapply(split(rep(1:length(b), sapply(b, length)), unlist(b, use.names=FALSE)), function(x) sort(unique(x))));
gs2bic<-lapply(gs2bic, function(b) sapply(b, function(b) paste(b, collapse=';')));

########################################################################################################
# Output tables
ora.table<-lapply(names(ora.table), function(nm) {
  b<-gs2bic[[nm]];
  if (length(b) > 0) {
    b<-b[rownames(ora.table[[nm]])];
    b[is.na(b)]<-'';
    ora.table[[nm]]$Cluster<-b;
  }
  ora.table[[nm]];
});
names(ora.table)<-names(bic);
```

```{r write_ora, include=FALSE}
# Split results into tables by collections
ora.wrapped<-lapply(names(ora.table), function(nm) {
  pth<-paste(path.ora, nm, 'table', sep='/');
  if (!file.exists(pth)) dir.create(pth, recursive = TRUE); 
  t <- ora.table[[nm]];
  if (nrow(t) == 0) list(all=t, formatted=list(), file=c()) else WrapGSE(t[, -(1:3)], geneset$meta, pth, TRUE); 
});
names(ora.wrapped)<-names(ora.table);

# create index.html file
ora.tbl<-lapply(ora.wrapped, function(o) { 
  if (length(o$formatted) > 0) {
    n<-lapply(o$formatted, function(o) sapply(o, nrow)); 
    fn<-unlist(o$file, use.names=FALSE); 
    fn<-sub(paste(path.ora, '/', sep=''), '', fn); 
    s<-rep(names(n), sapply(n, length));
    c<-unlist(lapply(n, names), use.names=FALSE); 
    n<-as.vector(unlist(n, use.names=FALSE)); 
    tbl<-data.frame(Source=s, Collection=c, N=n, stringsAsFactors = FALSE);
    tbl$N <- AddHref(tbl$N, fn);
    rownames(tbl)<-paste(tbl[[1]], tbl[[2]], sep='_'); 
  } else tbl <- data.frame(Source='', Collection='', N=0, stringsAsFactors = FALSE)[0, , drop=FALSE];

  tbl
});
u<-sort(union(rownames(ora.tbl[[1]]), rownames(ora.tbl[[2]]))); 
ora.tbl<-lapply(ora.tbl, function(t) {
  t<-t[u, ];
  t[is.na(t[,3]), 3]<-0; 
  rownames(t)<-u; 
  t;
});
ora.ind<-cbind(ora.tbl[[1]], N2=ora.tbl[[2]]$N); 
ora.ind[is.na(ora.ind[,1]), 1]<-ora.tbl[[2]][is.na(ora.ind[,1]), 1]; 
ora.ind[is.na(ora.ind[,2]), 2]<-ora.tbl[[2]][is.na(ora.ind[,2]), 2]; 
names(ora.ind)<-c('Source', 'Collection', names(ora.wrapped)); 
ora.ind[, 3] <- as.character(ora.ind[, 3]); 
ora.ind[, 4] <- as.character(ora.ind[, 4]); 
CreateDatatable(ora.ind, paste(path.ora, 'index.html', sep='/'), rownames = FALSE, caption = "Click on number to see list", ); 

# All tested gene sets
gs.table<-lapply(split(geneset[[1]][, 'Collection'], geneset[[1]][, 'Source']), table);
gs.table<-data.frame(stringsAsFactors = FALSE, Source=rep(names(gs.table), sapply(gs.table, length)), 
                     Collection=unlist(lapply(gs.table, names), use.names=FALSE), Geneset=as.numeric(unlist(gs.table)));
CreateDatatable(gs.table, paste(path.ora, 'geneset.html', sep='/'), rownames = FALSE, caption = "Gene set collections");

# Formatted tables of ORA results
stat.slim<-data.frame(anno[rownames(stat), 1, drop=FALSE], FormatNumeric(stat));
colnames(stat.slim) <- c(names(anno)[1], colnames(stat)); 
ora.formatted<-lapply(names(ora.table), function(nm) {  
  pth0 <- paste(path.ora, nm, sep='/'); 
  if (!file.exists(pth0)) dir.create(pth0, recursive = TRUE);
  pth1 <- paste(path.ora, nm, 'term', sep='/');
  if (!file.exists(pth1)) dir.create(pth1, recursive = TRUE);
  
  t<-ora.table[[nm]];
  an<-geneset[[1]][rownames(t), ];
  if (nrow(t) > 0) {
    t$Term <- AddHref(t$Term, an[, 'URL']);
    t$Total[1:min(250, nrow(t))] <- AddHref(t$Total[1:min(250, nrow(t))], 
                                            paste('term/term_', 1:min(250, nrow(t)), '.html', sep=''));
    sapply(1:min(250, nrow(t)), function(i) { 
      g<-geneset$list[rownames(t)[i]][[1]];
      t1<-stat.slim[rownames(stat.slim) %in% g, , drop=FALSE];
      t1<-t1[order(abs(t1[, 'Rank'])), , drop=FALSE];
      fn<-paste(path.ora, nm, 'term', paste('term_', i, '.html', sep=''), sep='/');
      GeneList2Datatable(t1, fn, genome = genome, title = rownames(t)[i]);
    });
  }
  
  t<-FormatNumeric(t);
  CreateDatatable(t, fn=paste(path.ora, nm, 'term.html', sep='/'), rownames = FALSE);

  t;
}); 
names(ora.formatted)<-names(ora.table);

# Formatted table of biclustering
bic.formatted<-lapply(names(bic), function(nm) { 
  pth0 <- paste(path.ora, nm, sep='/'); 
  if (!file.exists(pth0)) dir.create(pth0, recursive = TRUE);
  pth1 <- paste(path.ora, nm, 'bicluster', sep='/'); 
  if (!file.exists(pth1)) dir.create(pth1, recursive = TRUE);
  
  t <- bic[[nm]]; 
  if (identical(t, NA)) {
    x <- data.frame('No biclusters found'='', stringsAsFactors = FALSE);
    CreateDatatable(x, paste(pth1, 'index.html', sep='/'), rownames = FALSE);
  } else {
    t <- FormatNumeric(t$summary);
    t[, 1] <- as.vector(t[, 1]); 
    
    # write individual files of biclusters
    fns<-sapply(1:nrow(t), function(i) {
      fn <- paste(pth1, paste(t[i, 1], c('_terms.html', '_genes.html', '_heatmap.png'), sep=''), sep='/');
      t1 <- ora.formatted[[nm]][rownames(bic[[nm]][[2]][[i]]), ];
      CreateDatatable(t1, fn[1], FALSE, rownames = FALSE, caption=paste('Terms of', t[i,1]));
      t2<-stat.slim[colnames(bic[[nm]][[2]][[i]]), , drop=FALSE];
      t2<-t2[order(t2[, 'Rank']), , drop=FALSE];
      GeneList2Datatable(t2, fn[2], genome = genome, title=paste('Genes of', t[i,1])); 
      t3<-bic[[nm]][[2]][[i]];
      rownames(t3)<-paste(ora.table[[nm]][rownames(t3), 2], ora.table[[nm]][rownames(t3), 3], sep=' - ');
      colnames(t3)<-paste(rownames(anno[colnames(t3), , drop=FALSE]), CleanHtmlTags(anno[colnames(t3), 1]), sep=' - ');
      if (min(t3)==1) col.min<-'#0000FF' else col.min<-'#999999';
      sz <- PlotHeatmap(t3, size.max=Inf, fn=sub('.png$', '', fn[3]), col.min=col.min, col.max='#0000FF');
      png(fn[3], width = sz[[1]], height = sz[[2]], res=150, unit='in'); 
      PlotHeatmap(t3, size.max=Inf, col.min=col.min, col.max='#0000FF', plot.new = FALSE);
      dev.off();
      paste(pth1, paste(t[i, 1], c('_terms.html', '_genes.html', '_heatmap.png'), sep=''), sep='/');
    });
    bic.fn<-t(fns);
    
    # write index table
    t$Num_Terms <- AddHref(t$Num_Terms, TrimPath(bic.fn[, 1]));
    t$Num_Genes <- AddHref(t$Num_Genes, TrimPath(bic.fn[, 2]));
    t$ID <- AddHref(t$ID, TrimPath(bic.fn[, 3]));
    CreateDatatable(t, fn=paste(pth1, 'index.html', sep='/'), rownames = FALSE);
  }
  t;
});

# Summary table in the report
rownames(gs.table) <- paste(gs.table[, 1], gs.table[, 2], sep='_'); 
t <- cbind(ora.ind, Total=gs.table[rownames(ora.ind), 3])[, c(1, 2, 5, 3, 4)];
CreateDatatable(t, paste(path.ora, 'index.html', sep='/'), rownames = FALSE, caption = "Click on number to see list"); 
t[, 4:5] <- sapply(4:5, function(i) CleanHtmlTags(t[, i])); 
t[, 4:5] <- sapply(colnames(t)[4:5], function(nm) {
  x <- as.numeric(as.vector(t[, nm])); 
  y <- paste('[', x, '](ORA/', nm, '/table/', as.vector(t[, 1]), '/', as.vector(t[, 2]), '.html', ')', sep=''); 
  y[x==0] <- '0';
  y;
});
```

ORA evaluates whether the genes of any predefined gene sets, such as a KEGG pathway or GO term, are over-represented in lists of DEGs. Hypergeometric test evaluates whether ***N/Nt*** is significantly greater than ***M0/Mt***, where ***Mt*** is the total number of genes in the data set, ***M*** is the total number of genes in both of the data set and a gene set, ***Nt*** is the total number of DEGs previously selected, and ***N*** is the overlapping of ***M*** and ***Nt***. 

Gene sets of several model animals have been collected and can be found [here](https://github.com/zhezhangsh/RoCA/tree/master/data/gene.set). All gene sets with at least `r min(geneset[[1]][, 'Size'])` genes measured by the data set are tested and organized into collections, such as KEGG pathways and miRNA targets. False discovery rate is estimated within gene set collections separately.

<div style="color:darkblue; padding:0 0.5cm">
**Table 2.** Summary of ORA results. Numbers indicate the significant gene sets (p < 0.05) enriched in the DEGs with higher and lower expression in `r g2.name`. Click the numbers to view the full statistical results of individual gene sets.
</div>
  
<div align='center', style="padding:0 0.5cm">
`r kable(t, row.names=FALSE, align=c('l', 'l', 'c', 'c', 'c'))`
</div>
  
<div align='center'>
```{r ora_ex_venn, include=TRUE, fig.width=4.8, fig.height=3.6, out.width='640px'}
if (nrow(ora[[1]][[1]]) == 0 & nrow(ora[[2]][[1]]) == 0) {
  plot(0:1, 0:1, type='n', axes=FALSE, xlab='', ylab='');
  text(0.5, 0.5, label='ORA found no significant gene sets', col='darkblue'); 
} else {
  if (nrow(ora[[1]][[1]]) > 0) {
    gs.id <- rownames(ora[[1]][[1]])[1]; 
    id1 <- geneset[[2]][[gs.id]];
    id2 <- rownames(degs[[1]]);
    l <- paste('DEG, higher in', g2.name);
  } else {
    gs.id <- rownames(ora[[2]][[1]])[1]; 
    id1 <- geneset[[2]][[gs.id]];
    id2 <- rownames(degs[[2]]);
    l <- paste('DEG, lower in', g2.name);
  }
  PlotVenn(id1, id2, c(geneset[[1]][gs.id, 'Name'], l), rownames(anno)) -> x;
}
```
</div>
  
<div style="color:darkblue; padding:0 2cm">
**Figure 8.** Example: One of the top gene sets over-represented in genes with differential expression in `r g2.name`.
</div>
  
`r home.url` 

### Gene set enrichment analysis (GSEA)

```{r prepare_gsea, include=FALSE}
tmp <- as.character(as.integer(Sys.time())); 
if (file.exists(tmp)) unlink(tmp, recursive = TRUE); 
dir.create(tmp, recursive = TRUE); 

rnk[is.na(rnk)] <- 0; 
qn <- abs(qnorm(((1:length(rnk))-0.5)/(2*length(rnk)))); 
rk <- sign(rnk)*qn[(length(rnk)+1)-abs(rank(abs(rnk)))]
names(rk) <- names(rnk) <- rownames(stat); 

e1.2_gsea <- e1.2; 
e1.2_gsea[, g1.ind] <- apply(e1.2[, g1.ind], 2, function(x) x-rowMeans(e1.2[, g1.ind])); 
e1.2_gsea[, g2.ind] <- apply(e1.2[, g2.ind], 2, function(x) x-rowMeans(e1.2[, g2.ind])+rk); 

fn.gsea<-PrepareGSEA(e1.2_gsea, grps, paste(tmp, 'input', sep='/'), desc = anno[[1]]); 

path.gmt <- paste(tmp, 'gmt', sep='/'); 
if (!file.exists(path.gmt)) dir.create(path.gmt, recursive = TRUE); 

input.gsea               <- yml$gsea;
gsea.yml                 <- list();
gsea.yml$jar             <- input.gsea$jar;
gsea.yml$preranked       <- FALSE;
gsea.yml$thread          <- input.gsea$thread; 
gsea.yml$name            <- tmp;
gsea.yml$groups$control  <- g1.name;
gsea.yml$groups$case     <- g2.name;
gsea.yml$out             <- path;
gsea.yml$input           <- fn.gsea[1];
gsea.yml$class           <- fn.gsea[2];
gsea.yml$chip            <- c();
gsea.yml$gmt             <- input.gsea$gmt;
gsea.yml$options         <- input.gsea$options

writeLines(as.yaml(gsea.yml), paste(tmp, 'pairwise_comparison.yaml', sep='/')); 
```

```{r analysis_gsea, include=FALSE}
######################################
gsea.cmmd <- GSEAviaJava(gsea.yml); ##
######################################

path.gsea <- paste(path, 'GSEA', sep='/'); 
if (dir.exists(path.gsea)) unlink(path.gsea, recursive = TRUE); 
dir.create(path.gsea, recursive = TRUE); 
file.rename(paste(path, tmp, sep='/'), path.gsea); 

gsea.tbl<-readRDS(paste(path.gsea, 'full_table.rds', sep='/'));
for (i in 1:ncol(gsea.tbl)) gsea.tbl[[i]]<-as.vector(gsea.tbl[[i]]); 
saveRDS(gsea.tbl, file=paste(path.gsea, 'full_table.rds', sep='/')); 

# Load gene lists of gene sets from GMT files
fn.gmt<-sub(tmp, path.gsea, unlist(gsea.yml$gmt));
gmts<-lapply(fn.gmt, readGmt); 
gsea.lst<-lapply(gmts, function(gmt) {
  nm<-sub(' $', '', sapply(gmt, function(g) g@reference)); 
  lst<-lapply(gmt, function(g) g@ids); 
  names(lst)<-toupper(nm); 
  lst;
}); 

t <- data.frame(Collection=names(gmts), Gene_Set=sapply(gmts, length), rep('List', length(gmts)), 
                rep('List', length(gmts)),stringsAsFactors = FALSE);
names(t)[3:4] <- c(paste(g1.name, g2.name, sep=' > '), paste(g2.name, g1.name, sep=' > ')); 
lnk <- sapply(names(gmts), function(nm) {
  x <- paste('GSEA', nm, sep='/'); 
  y <- dir(x); 
  y <- y[grep('.html$', y)]; 
  z <- sapply(c(g1.name, g2.name), function(x) y[grep(paste('^gsea_report_for_', x, sep=''), y)]);
  paste('GSEA', nm, z, sep='/'); 
}); 
t [, 3] <- paste('[', t[, 3], '](', lnk[1, ], ')', sep=''); 
t [, 4] <- paste('[', t[, 4], '](', lnk[2, ], ')', sep=''); 

########################################################################################################
# Biclustering
gsea.tbl.sig<-gsea.tbl[gsea.tbl$PValue<=0.05, ]; 
gsea.tbl.sig<-gsea.tbl.sig[order(gsea.tbl.sig$PValue), , drop=FALSE]; 
gsea.lst.sig<-lapply(1:nrow(gsea.tbl.sig), function(i) gsea.lst[[gsea.tbl.sig[i, 1]]][[gsea.tbl.sig[i, 2]]]); 
gsea.lst.sig<-lapply(gsea.lst.sig, function(l) l[l %in% unlist(lapply(degs, rownames), use.names=FALSE)]); 
names(gsea.lst.sig)<-rownames(gsea.tbl.sig); 
gsea.lst.sig<-gsea.lst.sig[sapply(gsea.lst.sig, length)>1];
gsea.gs<-split(gsea.lst.sig, gsea.tbl.sig[names(gsea.lst.sig), ncol(gsea.tbl.sig)]); 
#gsea.gs<-rev(gsea.gs); 
gsea.gs<-lapply(rev(gsea.gs), function(x) x[!duplicated(x)]); 
nms <- names(degs);
names(nms) <- c('Yes', 'No'); 
names(gsea.gs)<-nms[names(gsea.gs)];

gsea.bic<-lapply(gsea.gs, function(g) BiclusterFromList(g[1:min(250, length(g))])); 
gsea.bic2gs<-lapply(gsea.bic, function(bic) if (identical(NA, bic)) NA else lapply(bic[[2]], rownames));
gsea.gs2bic<-lapply(gsea.bic2gs, function(b) lapply(split(rep(1:length(b), sapply(b, length)), unlist(b, use.names=FALSE)), function(x) sort(unique(x))));
gsea.gs2bic<-lapply(gsea.gs2bic, function(b) sapply(b, function(b) paste(b, collapse=';')));

if (tolower(prms$deg$rank[1]) == 'p') l <- 'signed log10(p value) of the statistical test' else 
  if (tolower(prms$deg$rank[1]) == 'fc') l <- paste('fold change between in', g2.name) else 
    l <- 'combination of fold change and statistical p value';
```

GSEA is a similar gene set-level analysis applied. However, instead of using selected top DEGs like **ORA**, GSEA takes into account all genes in the data set after they were ranked by a test statistic of differential expression. The original [GSEA](http://www.broadinstitute.org/gsea/index.jsp) was developed by Broad Institute that is usually run as a stand-alone program. GSEA is run locally in this section using [gene set collections](https://github.com/zhezhangsh/RoCA/tree/master/data/gene.set/gmt) obtained from different sources, such as BioSystems and KEGG. To prepare for the input data of GSEA,

  - quantitate the differential expression of each gene using its `r l` to get a numeric vector.
  - rescale the vector so its values are quantiles of a standard normal distribution.
  - adjust the original data matrix, so all genes have means of the first sample group equal to zero and means of the second group equal to their rescaled vector.

<div style="color:darkblue; padding:0 1cm">
**Table 3.** Summary of GSEA results. Gene sets were analyzed as collections. Click the links the view GSEA results of individual collections.
</div>
  
<div align='center', style="padding:0 1cm">
`r kable(t, row.names=FALSE, align=c('l', 'c', 'c', 'c'))`
</div>
  
```{r gsea_ex_enrichment, eval=TRUE, include=FALSE}
gsea.ex <- gsea.tbl;
gsea.ex <- gsea.ex[!is.na(gsea.ex$NES), , drop=FALSE];
gsea.ex <- gsea.ex[abs(gsea.ex$NES)==max(abs(gsea.ex$NES)), ];
ex.gsea <- dir(paste(path.gsea, gsea.ex$Collection, sep='/')); 
ex.gsea <- ex.gsea[grep(gsea.ex$Gene_set[1], ex.gsea)];
ex.gsea <- paste(path.gsea, gsea.ex$Collection, ex.gsea[grep('^enplot', ex.gsea)][1], sep='/');
```

<div align='center'>![](`r TruncatePathPrefix(ex.gsea, path)`)</div>

<div style="color:darkblue; padding:0 2.5cm">
**Figure 9.** Example: The GSEA enrichment plot of the most significant gene set. The detailed intepretation of enrichment plot can be found [here](http://software.broadinstitute.org/gsea/doc/GSEAUserGuideTEXT.htm#_GSEA_Statistics). 
</div>

`r home.url` 

### KEGG pathways

```{r kegg_gsea, include=FALSE}
path.kegg<-paste(path.gsea, 'kegg', sep='/'); 
if (file.exists(path.kegg)) unlink(path.kegg, recursive = TRUE); 
dir.create(path.kegg, recursive = TRUE); 

kegg.stat<-gsea.tbl[gsea.tbl$Collection==yml$gsea$kegg$collection & gsea.tbl$PValue<=yml$gsea$kegg$p, , drop=FALSE];
# Run pathview, generate figures in a temp directory and copy them to output directory
path.temp<-as.character(as.integer(Sys.time()));
if (!file.exists(path.temp)) dir.create(path.temp);

if (nrow(kegg.stat) == 0) {
  if (!(yml$gsea$kegg$collection %in% names(gmts))) 
    l <- paste('The .gmt file of KEGG pathway collection: _',
               yml$gsea$kegg$collection, '_ is not provided for GSEA') else
                 l <- paste("There is no KEGG pathway having GSEA p value less than", yml$gsea$kegg$p);
  kegg.ind <- kegg.stat[, -1];
} else {
  kegg.stat <- kegg.stat[rev(order(abs(kegg.stat$NES))), , drop=FALSE]; 
  kegg.stat <- kegg.stat[1:max(1, min(nrow(kegg.stat), yml$gsea$kegg$top)), , drop=FALSE]; 
  kegg.id <- tolower(substr(kegg.stat$Gene_set, 1, 8)); 
  kegg.dff <- rk; 
  
  fn.kegg<-sapply(kegg.id, function(id) {
    capture.output(kegg<-pathview(kegg.dff, pathway.id=id, species = GetGenomeAlias(genome, "code"), 
                                  low = list(gene = "blue"), kegg.dir=dir.kegg))->x; 
    fn <- paste(id, '.pathview.png', sep='');
    if (file.exists(fn)) file.rename(fn, paste(path.temp, fn, sep='/')); 
    paste(path.temp, fn, sep='/')
  }); 
  names(fn.kegg)<-kegg.id;
  fn.kegg <- fn.kegg[file.exists(fn.kegg)]; 
  if (length(fn.kegg)>0) file.rename(fn.kegg, paste(path.kegg, TrimPath(fn.kegg), sep='/')); 
  unlink(path.temp, recursive = TRUE); 
  fn.kegg <- TrimPath(fn.kegg); 
  
  kegg.ind<-FormatNumeric(kegg.stat[kegg.id %in% names(fn.kegg), -1]);
  if (nrow(kegg.ind) > 0) kegg.ind$Gene_set <- AddHref(kegg.ind$Gene_set, fn.kegg); 
  kegg.ind<-kegg.ind[order(kegg.ind$NES), , drop=FALSE]; 
  l <- paste('There are a total of', nrow(kegg.stat), 'significant KEGG pathways based on GSEA');
}
CreateDatatable(kegg.ind, paste(path.kegg, 'index.html', sep='/'), rownames = FALSE); 
```

[KEGG pathways](http://www.genome.jp/kegg/pathway.html) are mostly canonical metabolic pathways conserved across species. Each pathway can include both genes(proteins) and chemical compounds. Color-coded map of KEGG pathway illustrates intuitively the differential expression of its genes and their position in the pathway map. In this analysis, GSEA was used to identify significant pathway first, and the test statistic from differential expression analysis, such as the normalized rank products, was used to plot the maps.

```{r ex_kegg, include=FALSE}
ex.kegg<-kegg.stat[rownames(kegg.ind), ];
if (nrow(ex.kegg) == 0) ex.id <- ex.kegg <- '' else {
  ex.kegg<- ex.kegg[abs(ex.kegg$NES)==max(abs(ex.kegg$NES)), ];
  ex.id<-tolower(substr(ex.kegg[1,2], 1, 8));
  ex.kegg<-paste('GSEA/kegg', paste(ex.id, '.pathview.png', sep=''), sep='/');
}
```

<div align='center'>![](`r TruncatePathPrefix(ex.kegg, path)`)</div>

<div style="color:darkblue; padding:0 0.5cm">
**Figure 10.** Example: The KEGG pathway with the highest enrichment score, with genes color-coded by their differential expression (red = higher in `r g2.name`). Click [here](`r paste("http://www.genome.jp/kegg-bin/show_pathway?", ex.id, sep='')`) to see the original pathway map on KEGG web site and [here](GSEA/kegg/index.html) to view the full GSEA results of KEGG pathways.`r l`.
</div>

`r home.url` 

### Gene-gene set biclustering

```{r bicluster_gsea, include=FALSE}
gsea.bic.formatted<-lapply(names(gsea.bic), function(nm) {
  path.bic<-paste(path.gsea, 'bicluster', nm, sep='/'); 
  if (!file.exists(path.bic)) dir.create(path.bic, recursive = TRUE);
  
  if (identical(NA, gsea.bic[[nm]])) t<-data.frame('No biclusters found'='', stringsAsFactors = FALSE) else {
    t<-FormatNumeric(gsea.bic[[nm]]$summary);
    t$ID<-as.vector(t$ID); 
    
    # write individual files of biclusters
    fns<-sapply(1:nrow(t), function(i) { print(i); 
      fn<-paste(path.bic, paste(t[i, 1], c('_terms.html', '_genes.html', '_heatmap.pdf'), sep=''), sep='/');
      t1<-gsea.tbl[rownames(gsea.bic[[nm]][[2]][[i]]), , drop=FALSE];
      CreateDatatable(FormatNumeric(t1[, 1:6]), fn[1], FALSE, caption=paste('Terms of', t[i,1]));
      t2<-stat.slim[colnames(gsea.bic[[nm]][[2]][[i]]), , drop=FALSE];
      t2<-t2[order(t2[, 'Rank']), , drop=FALSE];
      GeneList2Datatable(t2, fn[2], genome = genome, title=paste('Genes of', t[i,1])); 
      t3<-gsea.bic[[nm]][[2]][[i]];
      rownames(t3)<-paste(gsea.tbl[rownames(t3), 1], gsea.tbl[rownames(t3), 2], sep=' - ');
      colnames(t3)<-paste(rownames(anno[colnames(t3), , drop=FALSE]), CleanHtmlTags(anno[colnames(t3), 1]), sep=' - ');
      if (min(t3)==1) col.min<-'#0000FF' else col.min<-'#999999';
      sz <- PlotHeatmap(t3, size.max=Inf, fn=sub('.pdf$', '', fn[3]), col.min=col.min, col.max='#0000FF');
      png(filename=sub('.pdf$', '.png', fn[3]), width=sz[[1]], height=sz[[2]], unit='in', res=300); 
      PlotHeatmap(t3, size.max=Inf, col.min=col.min, col.max='#0000FF', plot.new=FALSE);
      dev.off();
      fn;
    });
    gsea.bic.fn<-t(fns);
    
    # write index table
    t$Num_Terms <- AddHref(t$Num_Terms, paste(t$ID, '_terms.html', sep=''));
    t$Num_Genes <- AddHref(t$Num_Genes, paste(t$ID, '_genes.html', sep=''));
    t$ID <- AddHref(t$ID, paste(t$ID, '_heatmap.pdf', sep=''));
  }
  
  CreateDatatable(t, fn=paste(path.bic, 'index.html', sep='/'), rownames = FALSE);
  
  t;
});

gsea<-list(path=gsea.yml$out, geneset=gsea.lst, stat=gsea.tbl, bicluster=gsea.bic); 
#saveRDS(gsea, file=paste(path.r, 'gsea_all.rds', sep='/')); 
```

```{r write_bic, include=FALSE}
t <- data.frame(matrix('List', nr=2, nc=2), stringsAsFactors = FALSE); 
t[1, ] <- AddHref(t[1, ], paste("../ORA", names(degs), 'bicluster/index.html', sep='/')); 
t[2, ] <- AddHref(t[2, ], paste("../GSEA/bicluster", names(degs), 'index.html', sep='/')); 
colnames(t) <- names(degs);
rownames(t) <- c('Over-representation analysis', 'Gene set enrichment analysis'); 
CreateDatatable(t, paste(path.tbl, 'bicluster_index.html', sep='/')); 
t[1, ] <- paste('[', rep('List', 2), '](', paste("ORA", names(degs), 'bicluster/index.html', sep='/'), ')', sep='');
t[2, ] <- paste('[', rep('List', 2), '](', paste("GSEA/bicluster", names(degs), 'index.html', sep='/'), ')', sep='');
```

A potential problem complicates the result intepretation of gene set analysis is that many gene sets are redundant to each other by including common DEGs. Biclustering of significant genes and gene sets can be used to reduce redundant information by identifying a smaller number of "modules". Each module includes multiple genes that are likely to be found in the same gene sets and gene sets that are likely to include the same DEGs. The biclustering was performed by **[Iterative Signature Algorithm](http://www.ncbi.nlm.nih.gov/pubmed/12689096)** in this analysis. 

<div style="color:darkblue; padding:0 2cm">
**Table 4.** Gene-gene set biclusters identified from results of both ORA and GSEA. Click links to view lists of biclusters.
</div>
  
<div align='center', style="padding:0 2cm">
`r kable(t, align=c('c', 'c'))`
</div>

```{r ex_bic, include=FALSE}
if (!identical(NA, gsea$bicluster[[1]])) {
  ex.bic <- gsea$bicluster[[1]]$summary;
  ex.bic <- ex.bic[ex.bic[,2]*ex.bic[,3]==max(ex.bic[,2]*ex.bic[,3]), , drop=FALSE];
  ex.bic <- paste(path.gsea, 'bicluster', names(degs)[1], paste(ex.bic[1,1], '_heatmap.png', sep=''), sep='/');
} else if (!identical(NA, gsea$bicluster[[2]])) {
  ex.bic <- gsea$bicluster[[2]]$summary 
  ex.bic <- ex.bic[ex.bic[,2]*ex.bic[,3]==max(ex.bic[,2]*ex.bic[,3]), , drop=FALSE];
  ex.bic <- paste(path.gsea, 'bicluster', names(degs)[2], paste(ex.bic[,1], '_heatmap.png', sep=''), sep='/');
} else ex.bic <- NA;
if (!identical(NA, ex.bic)) ln <- paste("![](", TruncatePathPrefix(ex.bic, path), ")", sep='') else ln <- "No bicluster found";
```

<div align='center'>
`r ln`  
</div>

<div style="color:darkblue; padding:0 1cm">
**Figure 11.** Example: a gene-gene set biclustering module. Blue means the gene is both a DEG and a member of the gene set.
</div>

```{r write_out, eval=TRUE, include=FALSE}
# Excel spreadsheets
xls<-list(stat.table, stat.table[rownames(up), , drop=FALSE], stat.table[rownames(dn), , drop=FALSE],
          ora.table[[1]], ora.table[[2]], gsea.tbl);
xls<-lapply(xls, function(x) { 
  for (i in 1:ncol(x)) 
    if (is.numeric(x[, i])) x[, i] <- FormatNumeric(x[, i, drop=FALSE]) else x[, i] <- CleanHtmlTags(x[, i], FALSE);
  x;
});
names(xls) <- c('DEG, complete list', 
                paste('Top', nrow(up), ', higher in ', g2.name, sep=''), 
                paste('Top', nrow(dn), ', lower in ', g2.name, sep=''),
                paste('ORA, higher in ', g2.name, sep=''),
                paste('ORA, lower in ', g2.name, sep=''),
                "GSEA");
xls <- lapply(xls, FormatNumeric);
xls <- lapply(xls, function(x) if (nrow(x) > 0) x else {
  x[1, ] <- rep('', ncol(x));
  x;
}); 
tbl<-sapply(names(xls), function(nm) write.csv(xls[[nm]], paste(path.tbl, paste(nm, '.csv', sep=''), sep='/'))); 
#fn.xls<-paste(path.tbl, paste(g1.name, g2.name, sep='-vs-'), sep='/');
#WriteExcel(xls, paste(path.tbl, fn.xls, sep='/')); 

res$de<-de;
res$ora<-ora;
res$gsea<-gsea;
saveRDS(res, file=paste(path.r, 'result.rds', sep='/'));

zip(paste(path.fig, 'figures.zip', sep='/'), path.fig, zip = 'zip'); 
zip(paste(path.tbl, 'tables.zip', sep='/'), path.tbl, zip = 'zip'); 
zip(paste(path.r, 'R.zip', sep='/'), path.r, zip = 'zip'); 
```

`r home.url` 

***

# Appendix 

Check out the **[RoCA home page](http://zhezhangsh.github.io/RoCA)** for more information.  

## Fold change vs. log(fold change)

The terms to represent differential expression can be used quite confusingly. In this report, **fold change** refers the ratio of two group means in their unlogged form. So a fold change of 2.0 means the average of the second group is increased to twice of the average of the first group; similarly, a fold change of 0.5 means the average is reduced to half. **Log2(fold change)** equals to the log2-transformation of the fold change. The table below gives a few examples of the conversion of these 2 variables. **Log2(fold change)** is more suitable for statistical analysis since it is symmetric around 0. 

<div style="color:darkblue; padding:0 3cm">
**Supplemental Table 1.** Fold Change vs. Log(Fold Change) vs. Percentage Change
</div>
  
<div align='center', style="padding:0 3cm">
```{r fold_change, eval=TRUE, include=TRUE}
c<-c(1.25, 1.5, 2, 4, 8);
fc<-c(1/rev(c), 1, c);
lg<-log2(fc);
pct<-100*(fc-1);
t<-round(cbind(fc, lg, pct), 3);
colnames(t)<-c('Fold change', 'Log2(fold change)', 'Percentage change (%)');
kable(t); 
```
</div>

## Methods and functions

The key steps of statistical analysis in this report use existing R/Bioconductor packages and functions.

<div style="color:darkblue; padding:0 1cm">
**Supplemental Table 2.** R/Bioconductor key functions
</div>
  
<div align='center', style="padding:0 3cm">
```{r biocondductor, include=TRUE}
t<-strsplit(
"Hierarchical clustering\tstats\thclust 
PCA\tstats\tprcomp
Differential expression\tDEGandMore\tDeWrapper
Heatmap\tstats\theatmap
Biclustering analysis\tisa2\tisa
Over-representation analysis\tawsomics\tTestGSE
Gene set enrichment analysis\tDEGandMore\tGSEAviaJava
Plot color-coded KEGG pathways\tpathview\tpathview
Write Java HTML datatables\tawsomics\tCreateDatatable
Write data to Excel\txlsx\tcreateWorkbook",
'\n')[[1]]; 
t<-do.call('rbind', strsplit(t, '\t'));
colnames(t)<-c('Task', 'R package', 'R function');
pander::pander(t);
```
</div>

##References

  - **R:** R Development Core Team, 2011. _R: A Language and Environment for Statistical Computing._ ISBN 3-900051-07-0. [Home page](http://www.R-project.org).
  - **Bioconductor:** Gentleman RC et al., 2004. _Bioconductor: open software development for computational biology and bioinformatics._ Genome Biology. [ Home page](http://www.bioconductor.org).
  - **Biclustering:** Ihmels J, Bergmann S, Barkai N, 2004 _Defining transcription modules using large-scale gene expression data._ Bioinformatics. [Home page](http://www2.unil.ch/cbg/index.php?title=ISA). 
  - **GSEA:** Subramanian A et al. 2005 _Gene set enrichment analysis: A knowledge-based approach for interpreting genome-wide expression profiles_ PNAS. [Home page](http://software.broadinstitute.org/gsea/index.jsp)
  - **[RoCA](http://zhezhangsh.github.io/RoCA)** 
  - **[Awsomics](awsomics.org)**


## Reproduce this report

To reproduce this report: 

  1. Find the data analysis template you want to use and an example of its pairing YAML file  [here](https://github.com/zhezhangsh/RoCA/wiki/Templates-and-examples) and download the YAML example to your working directory

  2. To generate a new report using your own input data and parameter, edit the following items in the YAML file:

    - _output_        : where you want to put the output files
    - _home_          : the URL if you have a home page for your project
    - _analyst_       : your name
    - _description_   : background information about your project, analysis, etc.
    - _input_         : where are your input data, read instruction for preparing them
    - _parameter_     : parameters for this analysis; read instruction about how to prepare input data

  3. Run the code below within ***R Console*** or ***RStudio***, preferablly with a new R session:

```{r reproduce_report, eval=FALSE, echo=TRUE}
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

CreateReport(filename.yaml);  # filename.yaml is the YAML file you just downloaded and edited for your analysis
```

If there is no complaint, go to the _output_ folder and open the ***index.html*** file to view report. 

## Session information

```{r session_info, echo=FALSE}
sessionInfo(); 
```

`r home.url`

***
_END OF DOCUMENT_


