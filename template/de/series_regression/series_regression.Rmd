---
title: "Gene expression correlated to a series of conditions"
author: "`r if (exists('yml')) yml$analyst else 'Jim Zhang'`"
date: "`r Sys.Date()`"
output:
  html_document:
    self_contained: no
    number_sections: yes
    toc: yes
    toc_float: 
      collapsed: no
---

<div style="border:black 1px solid; padding: 0.5cm 0.5cm">

**Introduction: ** The goal of this analysis is to find genes in a microarray or RNA-seq data set correlated to a series of sample feature, such as time and drug dosage. It first calculates the correlation between the sample feature and the expression level of each gene. Depending on the nature of the sample feature, the correlation could be linear or non-linear. The genes with the strongest correlation are then selected based on their correlation coefficient, p value, false discovery rate, and range across samples. The selected genes are further analyzed to identify pre-defined gene sets over-represented in these genes. 

</div>

&nbsp;

```{r global_setup, eval=TRUE, include=FALSE}
name.yaml <- 'series_regression.yaml'; 
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'RoCA', 'rchive', 'awsomics'); 
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table',
                     'path.ora'='ora'); 

## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));

## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
  if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
    yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template

prms <- yml$parameter;

## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]); 

## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
```

```{r load_data, include=FALSE}
# Load input data
expr <- ImportTable(DownloadFile(yml$input$data, path.input)); 
anno <- ImportTable(DownloadFile(yml$input$annotation, path.input)); 
smpl <- ImportTable(DownloadFile(yml$input$sample, path.input)); 
gset <- ImportR(DownloadFile(yml$input$geneset, path.input)); 
term <- prms$term[1]; 

saveRDS(expr, file=paste(path.input, TrimPath(yml$input$data), sep='/')); 
saveRDS(anno, file=paste(path.input, TrimPath(yml$input$annotation), sep='/')); 
saveRDS(smpl, file=paste(path.input, TrimPath(yml$input$sample), sep='/')); 
saveRDS(gset, file=paste(path.input, TrimPath(yml$input$geneset), sep='/')); 

if (nrow(anno[rownames(anno) %in% rownames(expr), , drop=FALSE]) <= 1) stop("Not enough genes to perform clustering.\n");
if (nrow(smpl[rownames(smpl) %in% colnames(expr), , drop=FALSE]) <= 1) stop("Not enough samples to perform clustering.\n");
if (!(term %in% colnames(smpl))) stop('"', term, '" is not a column name in sample table.\n'); 

anno <- anno[rownames(anno) %in% rownames(expr), , drop=FALSE]; 
smpl <- smpl[rownames(smpl) %in% colnames(expr), , drop=FALSE];
expr <- expr[rownames(anno), rownames(smpl)];  # Original matrix
phen <- as.vector(smpl[, term]); 
grps <- split(rownames(smpl), phen)[unique(phen)]; 

if (prms$normalization[1] == 2) {
  expr <- apply(expr, 2, function(e) e - rowMeans(expr[, grps[[1]], drop=FALSE])); 
  expr <- t(apply(expr, 1, function(x) x/sd(x))); 
} else if (prms$normalization[1] == 1) expr <- t(scale(t(expr))); 

CreateDatatable(smpl, paste(path.tbl, 'sample.html', sep='/'));
```

`r home.url`

# Description

`r WriteDescription(yml$description)`

`r home.url`

## Data and samples

```{r normalization, include=FALSE}
if (prms$normalization == 2) ln<-paste('The input data matrix was normalized using sample group _', phen[1], '_ as control, so the data of each gene was substracted by control group mean and had SD equal to 1.0', sep='') else if (prms$normalization == 1) ln<-paste('The input data matrix was normalized so each gene had mean of 0 and SD of 1.0') else 
  ln<-'It was presumed that the input data matrix had been properly processed for this analysis, so no further normalization was done'
```

  - There are **`r nrow(expr)`** total genes.
  - There are **`r ncol(expr)`** total [samples](table/sample.html).
  - There are **`r length(grps)`** sample groups: ***`r paste(names(grps), collapse='; ')`***. 
  
`r ln`

`r home.url`

# Analysis and results

## Selection of correlated genes

```{r stats, include=FALSE}
if (!(tolower(prms$correlation[1]) %in% c("pearson", "kendall", "spearman"))) mthd <- 'spearman' else 
  mthd <- tolower(prms$correlation[1]); 
if (mthd == 'pearson' & is.numeric(phen)) X <- phen else X <- rep(1:length(grps), sapply(grps, length)); 

crr <- apply(expr, 1, function(e) cor.test(e, X, method=mthd, use='pair')); 
pvl <- sapply(crr, function(x) x$p.value); 
qvl <- p.adjust(pvl, method='BH'); 
crr <- sapply(crr, function(x) x$estimate); 
rng <- t(apply(expr, 1, function(x) range(x, na.rm=TRUE))); 
mns <- sapply(grps, function(g) rowMeans(expr[, g, drop=FALSE], na.rm=TRUE)); 
colnames(mns)   <- paste("Mean", names(grps), sep='_');
pvl[is.na(pvl)] <- 1;
qvl[is.na(qvl)] <- 1;
crr[is.na(crr)] <- 0;

stat <- cbind(Min=rng[, 1], Max=rng[, 2], Corr=crr, Pval=pvl, FDR=qvl, mns); 
tbl  <- cbind(anno, stat); 
saveRDS(stat, paste(path.r, 'stat.rds', sep='/')); 
CreateDatatable(tbl, paste(path.tbl, 'stat.html', sep='/')); 
for (i in 1:ncol(anno)) tbl[, i] <- CleanHtmlTags(tbl[, i], remove.empty = FALSE); 
write.csv(tbl, paste(path.tbl, 'stat.csv', sep='/')); 
```

```{r gene_selection, include=FALSE}
ss  <- list(positive = stat[stat[, 3] > 0, , drop=FALSE], negative = stat[stat[, 3] < 0, , drop=FALSE]);

# Select top genes
sel <- lapply(names(ss), function(nm) {
  s <- ss[[nm]]; 
  # Select by correlation coefficient
  if (nrow(s) > prms$selection$min) {
    s <- s[rev(order(abs(s[, 3]))), , drop=FALSE]; 
    s <- s[1:max(prms$selection$min, max(which(abs(s[, 3]) >= prms$selection$corr))), , drop=FALSE];
  }
  
  # Select by p value
  if (nrow(s) > prms$selection$min) {
    s <- s[order(s[, 4]), , drop=FALSE]; 
    s <- s[1:max(prms$selection$min, max(which(s[, 4] <= prms$selection$p))), , drop=FALSE];
  }
  
  # Select by FDR
  if (nrow(s) > prms$selection$min) {
    s <- s[order(s[, 5]), , drop=FALSE]; 
    s <- s[1:max(prms$selection$min, max(which(s[, 5] <= prms$selection$fdr))), , drop=FALSE];
  }
  
  # Select by range
  if (nrow(s) > prms$selection$min) {
    s <- s[rev(order(s[, 2] - s[, 1])), , drop=FALSE];
    s <- s[1:max(prms$selection$min, max(which((s[,2]-s[,1]) >= prms$selection$range))), , drop=FALSE];
  }
  
  # Limit to maximum number of genes
  if (nrow(s) > prms$selection$min) {
    s <- s[rev(order(abs(s[, 3]))), , drop=FALSE]; 
    s <- s[1:min(nrow(s), prms$selection$max), , drop=FALSE]; 
  }
  
  CreateDatatable(cbind(anno[rownames(s), , drop=FALSE], s), paste(path.tbl, paste('stat_', nm, '.html', sep=''), sep='/'));
  s;
});
names(sel) <- names(ss);

smm <- sapply(sel, function(s) c(nrow(s), min(abs(s[, 3])), max(s[, 4]), max(s[, 5]), min(s[, 2]-s[, 1])));
smm <- FormatNumeric(t(smm)); 
dimnames(smm) <- list(c('Positive', 'Negative'), c('Num_Gene', 'Min_Corr', 'Max_Pval', 'Max_FDR', 'Min_Range')); 
tbl <- data.frame(Direction=c('[Positive](table/stat_positive.html)', '[Negative](table/stat_negative.html)'), smm); 

saveRDS(sel, file=paste(path.r, 'selected_genes.rds', sep='/')); 
```

<div style="color:darkblue; padding:0 2cm">
**Table 1** Selected genes positively or negatively correlated to `r prms$series`. Click on the clicks veiw full gene list. Summary statistics are the maximums of p value and FDR and the minimums of correlation coefficient and data range of selected genes. 
</div>
  
<div align='center', style="padding:0 2cm">
`r kable(tbl, row.names=FALSE)`
</div>

<div align='center'>
```{r average_trend, include=TRUE, fig.width=8, fig.height=6, out.width='720px'}
mns <- sapply(sel, function(s) {
  d <- colMeans(expr[rownames(s), , drop=FALSE], na.rm=TRUE); 
}); 

par(mar=c(6,5,2,2)); 
plot(0, type='n', xlim=range(X), ylim=range(mns), xlab='', ylab='Average expression (normalized)', 
     cex.lab=2, xaxt='n'); 
if (mthd != 'pearson' | !is.numeric(phen)) axis(1, at=1:length(grps), labels=names(grps), las=3) else {
  title(xlab=prms$series, cex.lab=2);
  axis(1); 
}; 
abline(h=0, col='green');

cex <- min(4, 36/length(X));
points(X, mns[, 1], col='#FF6666DD', pch=18, cex=cex/2);
points(X, mns[, 2], col='#6666FFDD', pch=18, cex=cex/2);
lines(1:length(grps), sapply(grps, function(x) mean(mns[x, 1], na.rm=TRUE)), col='#FF6666DD', 
      lty=2, lwd=2, type='b', pch=18, cex=cex);
lines(1:length(grps), sapply(grps, function(x) mean(mns[x, 2], na.rm=TRUE)), col='#6666FFDD', 
      lty=2, lwd=2, type='b', pch=18, cex=cex);

heatmap.size <- c(min(6, 0.25*nrow(smpl)), min(8, 0.15*(nrow(sel[[1]])+nrow(sel[[2]]))));
```
</div>

<div style="color:darkblue; padding:0 2cm">
**Figure 1.** The averages of normalized expression level of selected genes positively (red) and negatively (blue) correlated to `r prms$series`. The larger diamonds are the averages of sample groups and the smaller ones correspond to the individual samples. 
</div>

`r home.url`

## Gene set enrichment analysis

Find predefined gene sets over-represented in the two groups of genes correlated to `r prms$series`. 
  
```{r ora_analysis, include=FALSE}
sel$both <- rbind(sel[[1]], sel[[2]]); 
gse<-lapply(names(sel), function(nm) {
  s <- sel[[nm]]; 
  mtrx<-expr[rownames(s), , drop=FALSE]; 
  gse<-TestGSE(rownames(mtrx), rownames(expr), gset[[2]])[[1]]; 
  gse<-WrapGSE(gse, gset[[1]], paste(path.ora, nm, sep='/'), FALSE); 
  fn<-TruncatePathPrefix(gse[[3]], path);   
  sapply(names(gse[[2]]), function(nm) paste('[', nrow(gse[[2]][[nm]]), '](', fn[nm], ')', sep='')); 
});
gs<-sort(unique(unlist(lapply(gse, names), use.names=FALSE)));
tbl<-t(sapply(gse, function(gse) gse[gs]));
dimnames(tbl)<-list(names(sel), gs); 
tbl[is.na(tbl)]<-'0';
```

<div style="color:darkblue; padding:0 2cm">
**Table 2** Predefined gene sets significantly over-represented in the genes correlated to the `r prms$series`. The test is run on the two groups of genes with positive and negative correlation separately and then jointly. Click on links to see full tables of statistical results.
</div>
  
<div align='center', style="padding:0 2cm">
`r kable(tbl, row.names=FALSE)`
</div>

<div align='center'>
```{r heatmap, include=TRUE, fig.width=heatmap.size[1], fig.height=heatmap.size[2], out.width='800px'}
e <- lapply(sel, function(s) {
  e <- expr[rownames(s), , drop=FALSE]; 
  e[hclust(as.dist(1-cor(t(e))))$order, , drop=FALSE]; 
}); 
m <- rowMeans(abs(sapply(e, function(e) colMeans(e, na.rm=TRUE))));
g <- lapply(grps, function(g) sort(m[g])); 
e <- rbind(e[[1]], e[[2]])[, unlist(lapply(g, names), use.names=FALSE), drop=FALSE]; 
x <- max(abs(e), na.rm=TRUE); 
PlotColoredBlock(e, groups=grps, min=-x, max=x, key='Normalized expression'); 
abline(h=nrow(sel[[2]]), lwd=1); 
```
</div>

<div style="color:darkblue; padding:0 1cm">
**Figure 2.** Heatmap of all genes correlated, positively or negatively, to `r prms$series`. The colors represent the normalized expression levels (red = higher). 
</div>

`r home.url`

***

# Appendix 

Check out the **[RoCA home page](http://zhezhangsh.github.io/RoCA)** for more information.  

## Reproduce this report

To reproduce this report: 

  1. Find the data analysis template you want to use and an example of its pairing YAML file  [here](https://github.com/zhezhangsh/RoCA/wiki/Templates-and-examples) and download the YAML example to your working directory

  2. To generate a new report using your own input data and parameter, edit the following items in the YAML file:

    - _output_        : where you want to put the output files
    - _home_          : the URL if you have a home page for your project
    - _analyst_       : your name
    - _description_   : background information about your project, analysis, etc.
    - _input_         : where are your input data, read instruction for preparing them
    - _parameter_     : parameters for this analysis; read instruction about how to prepare input data

  3. Run the code below within ***R Console*** or ***RStudio***, preferablly with a new R session:

```{r reproduce_report, eval=FALSE, echo=TRUE}
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

CreateReport(filename.yaml);  # filename.yaml is the YAML file you just downloaded and edited for your analysis
```

If there is no complaint, go to the _output_ folder and open the ***index.html*** file to view report. 
## Session information

```{r session_info, echo=FALSE}
sessionInfo(); 
```

`r home.url`

***
_END OF DOCUMENT_

