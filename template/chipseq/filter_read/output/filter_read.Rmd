---
title: "Filter ChIP-seq reads"
author: "Jim Zhang"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    fig_caption: yes
---

**Introduction** This is a procedure that summarizes and fitlers a set of BAM files based on alignment statistics such as mapping quality scores and CIGAR strings. It was designed to be used on ChIP-seq data sets.

```{r global_setup, include=FALSE}
knitr::opts_chunk$set(dpi=300, fig.pos="H", dev=c('png', 'pdf'), fig.width=8, fig.height=6, echo=FALSE, warning=FALSE, message=FALSE);

require(gplots);
require(knitr);
require(rmarkdown); 
require(yaml);
require(GenomicRanges);
require(GenomicAlignments);
require(awsomics);
require(CHOPseq);

## for development only
#fn.yaml<-'~/R/source/RoCA/template/chipseq/filter_read/filter_read.yml';
#yml<-yaml.load_file(fn.yaml); 

smpl<-yml$input$sample;
prms<-yml$parameter;
rngs<-readRDS(yml$input$range);

path<-yml$output;
path.r<-paste(path, 'R', sep='/');
path.tbl<-paste(path, 'table', sep='/');
path.html<-paste(path, 'html', sep='/');

if (!file.exists(path)) dir.create(path);
if (!file.exists(path.r)) dir.create(path.r);
if (!file.exists(path.tbl)) dir.create(path.tbl);
if (!file.exists(path.html)) dir.create(path.html);

if (is.null(yml$home)) home.url<-'' else 
  home.url<-paste("<div align='right'>**_[Go back to project home](", yml$home, ")_**</div>", sep='');
```

`r home.url`

# Description

```{r description, eval=TRUE, include=FALSE}

lns<-lapply(names(yml$description), function(nm) {
  c(paste('##', nm), '\n', yml$description[[nm]], '\n'); 
});
lns<-paste(do.call('c', lns), collapse='\n'); 
```

`r lns`

```{r functions, include=FALSE}
summarize<-function(s, yml) {
  fn<-yml$input$sample[[s]]; 
  gr<-readRDS(fn); 
  meta<-elementMetadata(gr); 
  bef<-length(gr); 
  
  # summarize flag values
  flag<-meta$flag
  v<-sort(unique(flag)); 
  flag<-sapply(v, function(v) length(flag[flag==v])); 
  names(flag)<-v;
  
  # summarize mapping quality
  mapq<-meta$mapq
  v<-sort(unique(mapq));
  mapq<-sapply(v, function(v) length(mapq[mapq==v])); 
  names(mapq)<-v;
  
  # strand
  strd<-strand(gr); 
  v<-levels(strd);
  strd<-sapply(v, function(s) length(strd[strd==s]));   

  # split by chromosomes
  rngs<-readRDS(yml$input$range); 
  c<-seqlevels(rngs);
  chrs<-sapply(c, function(c) length(gr[seqnames(gr)==c]));
  
  # dissect cigar strings
  cigar<-meta$cigar;
  cigar<-CHOPseq::SplitLongCigar(cigar, yml$parameter$cigar, 10^6, 8); 

  # filter reads
  gr<-gr[countOverlaps(gr, rngs)>0 & meta$mapq>=yml$parameter$mapq & cigar[, 'M']>=yml$parameter$length];
  if (!identical(yml$parameter$flag, -1)) gr<-gr[elementMetadata(gr)[, 'flag'] %in% yml$parameter$flag]; 
  
  f<-rev(strsplit(fn, '/')[[1]])[1]; 
  f<-sub(paste(f, '$', sep=''), paste('filtered_', f, sep=''), fn); 
  saveRDS(gr, f); 
  
  list(count=c(bef, length(gr)), flag=flag, strand=strd, mapq=mapq, chromosome=chrs, cigar=colSums(cigar)); 
}
```

```{r summarize, include=FALSE}
stat<-sapply(names(smpl), function(s) summarize(s, yml)); 
saveRDS(stat, paste(path.r, 'stat.rds', sep='/')); 

# Read count before/after filtering
cnt<-t(do.call('cbind', stat[1, ]));
colnames(cnt)<-c('before', 'after');

# Count SAM flag field
flg<-stat[2, ];
v<-unique(base::unlist(lapply(flg, names), use.names=FALSE)); 
flg<-t(sapply(flg, function(x) x[v]));
flg[is.na(flg)]<-0; 
flg<-flg[, order(as.numeric(colnames(flg)))]; 
colnames(flg)<-v; 

# Count strand
str<-stat[3, ];
v<-unique(base::unlist(lapply(str, names), use.names=FALSE)); 
str<-t(sapply(str, function(x) x[v]));
str[is.na(str)]<-0; 
colnames(str)<-v; 

# Count map scores
mpq<-stat[4, ];
v<-as.integer(unique(base::unlist(lapply(mpq, names), use.names=FALSE)));
v<-as.character(0:max(v)); 
mpq<-t(sapply(mpq, function(x) x[v]));
mpq[is.na(mpq)]<-0; 
colnames(mpq)<-v; 
mpq<-mpq[, colSums(mpq/10^6)>0, drop=FALSE]; 

# Count chromosomes
chr<-stat[5, ];
v<-seqlevels(rngs); 
chr<-t(sapply(chr, function(x) x[v]));
chr[is.na(chr)]<-0; 
colnames(chr)<-v;
chr<-chr[, colSums(chr/10^6)>0, drop=FALSE]; 

# Count cigar operations
cigar<-do.call('rbind', stat[6, ]); 
cigar<-cigar[, colSums(cigar/10^6)>0, drop=FALSE]; 
```

`r home.url`

# Read filtering

<div align='center', include=FALSE>
```{r read_count, fig.width=6, fig.height=6, out.width='600px'}
c<-cnt[, 1:2]/10^6;
par(mar=c(5, 5, 2, 2)); 
plot(c[, 1], c[, 2], pch=18, xlab='Before filtering (million reads)', ylab='After filtering (million reads)', cex=2, col='#88888888', cex.lab=2); 

sigma<-sapply(1:nrow(c), function(i) {
  x<-c[-i, ];
  mdl<-lm(x[, 2]~x[, 1]); 
  coe<-as.vector(coefficients(mdl)); 
  prd<-c[i, 1]*coe[2]+coe[1]; 
  sig<-summary(mdl)$sigma;
  (prd-c[i, 2])/sig; 
}); 

if (max(abs(sigma)) > 1.5) {
  x<-c[abs(sigma)>=1.5, , drop=FALSE]; 
  points(x, col='#FFBBBB', pch=18, cex=2); 
  if (max(abs(sigma)) > 3) {
    x<-c[abs(sigma)>=1.5, , drop=FALSE]; 
    points(x, col='#FF0000', pch=18, cex=2); 
  }
}

abline(lm(c[, 2]~c[, 1]), lwd=2, lty=2, col='blue');

legend(min(c[, 1]), max(c[, 2]), legend=c('Sigma < 1.5', 'Sigma >= 1.5', 'Sigma >=3.0'), cex=1.5, bty='n', pch=18, col=c('#88888888', '#FFBBBB', '#FF0000')); 

pct<-round(c[,2]/c[,1]*100, 2);
out<-rep('No', nrow(c)); 
out[abs(sigma)>=3.0]<-'Yes';

tbl<-data.frame('N_Before'=cnt[, 1], 'N_After'=cnt[, 2], 'Percent'=pct, 'Sigma'=round(sigma, 2), 'Outlier'=out, stringsAsFactors = FALSE);
CreateDatatable(tbl, paste(path.html, 'read_count.html', sep='/'), caption='Total reads, before vs. after filtering')->x; 
saveRDS(tbl, paste(path.r, 'read_count.rds', sep='/')); 
write.csv(tbl, paste(path.tbl, 'read_count.csv', sep='/')); 
```
</div>

Total number of reads before vs. after filtering. The percent of reads passed the filtering was also calculated, based on which outlier samples with much higher or lower percents than the others were identified. Click [here](html/read_count.html) to see the table with summary statistics.

**Figure 1** Numbers of reads before and after filtering. Sigma was estimated for each sample by fitting all the other samples to a linear model, using the model to predict this sample, and calculating the difference between its predicated and actual after-filtering reads. Samples with sigmas greater than 3.0 are likely outliers. The percents of reads passed the filter are between `r min(pct)`% and `r max(pct)`% (mean = `r round(mean(pct, 2))`%). 

# Summary statistics

## FLAGs and strands

```{r flag, include=FALSE}
N<-rowSums(flg);
n0<-flg[, '0'];
n16<-flg[, '16']; 
n<-N-n0-n16;
pct1<-round(100*n/N, 3); 

pct2<-round(100*str[,1]/rowSums(str[, 1:2]), 3); 

tbl<-cbind(n0, n16, n, pct1, str, pct2); 
colnames(tbl)<-c('FLAG_0', 'FLAG_16', 'FLAG_Others', 'Percent_Others', 'Strand_Forward', 'Strand_Backward', 'Strand_Ambiguous', 'Percent_Forward'); 
CreateDatatable(tbl, paste(path.html, 'flag_strand.html', sep='/'), caption='FLAGs and strands'); 
saveRDS(tbl, paste(path.r, 'flag_strand.rds', sep='/')); 
write.csv(tbl, paste(path.tbl, 'flag_strand.csv', sep='/')); 
```

Each alignment software could assign a bitwise value as a combination of FLAGs to each read to represent the result of the alignment, as descrbed in [SAM format manual](https://samtools.github.io/hts-specs/SAMv1.pdf), Section 1.4. The bitwise value is 0 if the read is aligned "normally" and uniquely to the forward strand, and is 16 if the read is aligned "normally" and uniquely to the reverse strand. Any other values would suggest that there is something "wrong" with the alignment. The majority of the alignment will assign a strand to the read, but in some rare occasions, the strand is ambiguous and there is no strand information available for the read. Click [here]() to view the summary statistics about the FLAGs and alignment strands. 

<div align='center', include=FALSE>
```{r strand, fig.width=6, fig.height=6, out.width='600px'}
c<-str[, 1:2]/10^6;
par(mar=c(5, 5, 2, 2)); 
plot(c[, 1], c[, 2], pch=18, xlab='Forward strand (million reads)', ylab='Reverse strand (million reads)', cex=2, col='#88888888', cex.lab=2, xlim=range(c), ylim=range(c)); 

sigma<-sapply(1:nrow(c), function(i) {
  x<-c[-i, ];
  mdl<-lm(x[, 2]~x[, 1]); 
  coe<-as.vector(coefficients(mdl)); 
  prd<-c[i, 1]*coe[2]+coe[1]; 
  sig<-summary(mdl)$sigma;
  (prd-c[i, 2])/sig; 
}); 

if (max(abs(sigma)) > 1.5) {
  x<-c[abs(sigma)>=1.5, , drop=FALSE]; 
  points(x, col='#FFBBBB', pch=18, cex=2); 
  if (max(abs(sigma)) > 3) {
    x<-c[abs(sigma)>=1.5, , drop=FALSE]; 
    points(x, col='#FF0000', pch=18, cex=2); 
  }
}

abline(lm(c[, 2]~c[, 1]), lwd=2, lty=2, col='blue');
abline(0, 1, lwd=2, col='blue');

legend(min(c), max(c), legend=c('Sigma < 1.5', 'Sigma >= 1.5', 'Sigma >=3.0'), cex=1.5, bty='n', pch=18, col=c('#88888888', '#FFBBBB', '#FF0000')); 
```
</div>

**Figure 2** Numbers of reads aligned to the forward and reverse strands. Outliers were identified via fitting linear models as described in **Figure 1**. The solid blue line corresponds to the same 50%-50% of the reads aligned to the 2 strands, and the dashed lines is the actual fitting lines of a linear model. The percents of reads aligned to the forward strand the are between `r min(pct2)`% and `r max(pct2)`% (mean = `r round(mean(pct2, 2))`%).

## Mapping quality scores, MAPQ

```{r mapq, include=FALSE}
CreateDatatable(mpq, paste(path.html, 'mapq_count.html', sep='/'), caption='Total reads, MAPQ scores');
saveRDS(mpq, paste(path.r, 'mapq_count.rds', sep='/')); 
write.csv(mpq, paste(path.tbl, 'mapq_count.csv', sep='/')); 

pct<-t(apply(mpq, 1, function(c) c/sum(c)*100)); 
CreateDatatable(round(pct, 4), paste(path.html, 'mapq_percent.html', sep='/'), caption='Percent of reads, MAPQ scores'); 
saveRDS(pct, paste(path.r, 'mapq_percent.rds', sep='/')); 
write.csv(pct, paste(path.tbl, 'mapq_percent.csv', sep='/')); 

plot.size<-c(1+min(0.25*ncol(pct), 6), 1+min(0.25*nrow(pct), 8)); 
plot.out<-paste(min(800, plot.size[1]*100), 'px', sep='');
```

Each alignment software could use its own algorithm to assign an alignment score to each align reads. The scores are usually non-negative integers, with 0 corresponding to the lowest mapping quality. Click [here](html/mapq_count.html) to view the number of reads in each sample with a given score, or [here](html/mapq_percent.html) to view the percent of reads in each sample with a given score.

<div align='center'>
```{r mapq_heatmap, fig.width=plot.size[1], fig.height=plot.size[2], out.width=plot.out}
mpq[mpq<1]<-1; 
pct<-t(apply(mpq, 1, function(c) c/sum(c)*100)); 
d<-t(sapply(1:nrow(pct), function(i) log2(pct[i, ]/colMeans(pct[-i, ]))));
rownames(d)<-rownames(pct);
PlotColoredBlock(d, min=-3, max=3, groups=as.list(colnames(pct)), key='Relative frequency'); 
```
</div>

**Figure 3** Each cell indicates the relative frequency of reads with a given mapping score, comparing to all the other samples. 

<div align='center'>
```{r mapq_hist, fig.width=9, fig.height=4, out.width='720px'}
ind<-c(1, which(colSums(pct)==max(colSums(pct))),  ncol(pct)); 
par(mfrow=c(1, 3), mar=c(5,2,3,1), omi=c(0, 0.6, 0, 0)); 
ttl<-paste(c('Lowest MAPQ =', 'Most common MAPQ =', 'Highest MAPQ ='), colnames(pct)[ind]);
sapply(1:3, function(i) hist(pct[, ind[i]], col='lightblue', xlab='Percent of reads (%)', ylab='', cex.lab=2, main=ttl[i]))->x; 
title(ylab='Number of samples', cex.lab=2, outer=TRUE, line=1);
```
</div>

**Figure 4** Each plot shows the distribution of read frequencies with the lowest, highest, and the most common mapping quality scores. 

## Reads by chromosomes

Alignment was broken down by chromosomes. Click [here](html/chromosome_count.html) to view the number of reads aligned to each chromosome, or [here](html/chromosome_percent.html) to view the percent of reads aligned to each chromosome.

```{r chromosome, include=FALSE}
CreateDatatable(chr, paste(path.html, 'chromosome_count.html', sep='/'), caption='Total reads aligned to each chromosome');
saveRDS(chr, paste(path.r, 'chromosome_count.rds', sep='/')); 
write.csv(chr, paste(path.tbl, 'chromosome_count.csv', sep='/')); 

pct<-t(apply(chr, 1, function(c) c/sum(c)*100)); 
CreateDatatable(round(pct, 4), paste(path.html, 'chromosome_percent.html', sep='/'), caption='Percent of reads aligned to each chromosome'); 
saveRDS(pct, paste(path.r, 'chromosome_percent.rds', sep='/')); 
write.csv(pct, paste(path.tbl, 'chromosome_percent.csv', sep='/')); 

plot.size<-c(1+min(0.25*ncol(pct), 6), 1+min(0.25*nrow(pct), 8)); 
plot.out<-paste(min(800, plot.size[1]*100), 'px', sep='');
```

<div align='center'>
```{r chromosome_heatmap, fig.width=plot.size[1], fig.height=plot.size[2], out.width=plot.out}
chr[chr<0]<-1;
pct<-t(apply(chr, 1, function(c) c/sum(c)*100)); 
d<-t(sapply(1:nrow(pct), function(i) log2(pct[i, ]/colMeans(pct[-i, ]))));
rownames(d)<-rownames(pct);
PlotColoredBlock(d, min=-3, max=3, groups=as.list(colnames(d)), key='Relative frequency'); 
```
</div>

**Figure 5** Each cell indicates the relative frequency of reads aligned to a chromosome, comparing to all the other samples. 

## CIGAR string

CIGAR strings indicate the internal structure of each alignment such as the base where insertion or deletion starts. Click [here](html/cigar_count.html) to view the number of bases per read with a given type of CIGAR character, or [here](html/cigar_percent.html) to view the percent of bases per read with a given type of CIGAR character.

```{r cigar, include=FALSE}
CreateDatatable(cigar, paste(path.html, 'cigar_count.html', sep='/'), caption='Total reads with a given CIGAR character');
saveRDS(cigar, paste(path.r, 'cigar_count.rds', sep='/')); 
write.csv(cigar, paste(path.tbl, 'cigar_count.csv', sep='/')); 

pct<-t(apply(cigar, 1, function(c) c/sum(c)*100)); 
CreateDatatable(round(pct, 4), paste(path.html, 'cigar_percent.html', sep='/'), caption='Percent of reads with a given CIGAR character'); 
saveRDS(pct, paste(path.r, 'cigar_percent.rds', sep='/')); 
write.csv(pct, paste(path.tbl, 'cigar_percent.csv', sep='/')); 

plot.size<-c(1+min(0.25*ncol(pct), 6), 1+min(0.25*nrow(pct), 8)); 
plot.out<-paste(min(800, plot.size[1]*100), 'px', sep='');
```

<div align='center'>
```{r cigar_heatmap, fig.width=plot.size[1], fig.height=plot.size[2], out.width=plot.out}
cigar[cigar<0]<-1;
pct<-t(apply(cigar, 1, function(c) c/sum(c)*100)); 
d<-t(sapply(1:nrow(pct), function(i) log2(pct[i, ]/colMeans(pct[-i, ]))));
rownames(d)<-rownames(pct);
PlotColoredBlock(d, min=-3, max=3, groups=as.list(colnames(d)), key='Relative frequency'); 
```
</div>

**Figure 6** Each cell indicates the relative frequency of reads with a given character in their CIGAR strings, comparing to all the other samples. 

`r home.url`

***
**END_OF_DOCUMENT**

