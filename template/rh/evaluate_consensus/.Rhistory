seq <- readRDS('UPID380_Read_57999844_Aln200_Selected.rds')
seq
seq[[1]]
seq[[1]] ->seq
dir()
saveRDS(seq, 'UPID380_Read_57999844_Aln200_Selected.rds')
as.character(seq[[1]])
seq
as.character(seq[[16]])
library("BSgenome", lib.loc="~/Library/R/3.3/library")
library("BSgenome.Hsapiens.NCBI.GRCh38", lib.loc="~/Library/R/3.3/library")
ref <- getSeq(Hsapiens, '1', 25397000,  25404000)
ref
ref <- getSeq(Hsapiens, '1', 25397001,  25404000)
seq
x <- pairwiseAlignment(seq, ref, type='global-local')
score(x)
y <- pairwiseAlignment(reverseComplement(seq), ref, type='global-local')
score(y)
table(x>y)
table(score(x)>score(y))
dir()
saveRDS(ref, 'hg38_1_25397001-25404000.rds')
name.yaml <- 'evaluate_consensus.yaml';
name.packages <- c('rmarkdown', 'knitr', 'kableExtra', 'yaml', 'DT', 'htmlwidgets', 'gplots', 'msa', 'vioplot',
'Biostrings', 'GenomicRanges', 'BSgenome', 'RoCA', 'awsomics', 'RH');
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table',
'path.align'='alignment');
## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE, fig.path = 'figure/');
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }
## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));
if (!exists('yml'))
if (file.exists(name.yaml))
yml <- yaml.load_file(name.yaml);   # rename the YAML file to fit this template
prms <- yml$parameter;
## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]);
## Automatical figure/table ordering
OrderFigure(reset=TRUE);
OrderTable(reset=TRUE);
## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
debug <- FALSE;
seq <- readRDS(yml$input$sequence);
ref <- readRDS(yml$input$reference);
if (class(seq) != 'DNAStringSet') seq <- DNAStringSet(seq);
if (is.null(names(seq))) names(seq) <- paste('s', 1:length(seq), sep='');
if (class(ref) != 'DNAStringSet') ref <- DNAStringSet(ref);
names(ref) <- 'Reference';
saveRDS(seq, paste(path.r, 'sequence.rds', sep='/'));
saveRDS(ref, paste(path.r, 'reference.rds', sep='/'));
wid <- c(width(ref), width(seq));
frq <- alphabetFrequency(seq);
frq <- rbind(alphabetFrequency(ref), frq);
tbl <- cbind(wid, frq[, 1:4], round(100*rowSums(frq[, 2:3])/rowSums(frq[, 1:4]), 1));
dimnames(tbl) <- list(c('Reference', names(seq)), c('Length', colnames(frq)[1:4], 'GC%'));
kable(tbl) %>% kable_styling(
bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE);
aln <- pairwiseAlignment(seq, ref, type='global-local');
fns <- paste('reference_', names(seq), '.txt', sep='');
for (i in 1:length(seq))
writePairwiseAlignments(aln[i], paste(path.align, fns[i], sep='/'), block.width = 100);
tbl <- cbind(Length=width(seq), Length_Alignment=nchar(as.character(pattern(aln))),
Score=score(aln), Match=nmatch(aln), Mismatch=nmismatch(aln),
Insertion=nindel(aln)@insertion[, 2], Deletion=nindel(aln)@deletion[, 2]);
tbl <- cbind(tbl, 'Match%'=round(100*tbl[, 'Match']/tbl[, 'Length_Alignment'], 1));
rownames(tbl) <- names(seq);
saveRDS(aln, paste(path.r, 'alignment_individual.rds', sep='/'));
saveRDS(tbl, paste(path.r, 'alignment_individual_summary.rds', sep='/'));
tbl <- data.frame(Sequence=paste('[', rownames(tbl), '](', paste('alignment', fns, sep='/'), ')', sep=''),
tbl, stringsAsFactors = FALSE);
colnames(tbl)[ncol(tbl)] <- 'Match%';
kable(tbl, row.names = FALSE) %>% kable_styling(
bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE);
if (debug) {
con <- readRDS('/Users/zhangz/Google Drive/Projects/Chou/result/evaluate_consensus/consensus_muscle.rds');
} else {
if (tolower(prms$method=='muscle')) con <- msaMuscle(seq[1:i], order='input') else
if (tolower(prms$method=='clustalomega')) con <- msaClustalOmega(seq[1:i], order='input') else
con <- msaClustalW(seq[1:i], order='input');
};
cap <- capture.output(msa::print(con, show='complete', showNames=TRUE, showConsensus=TRUE,
nameWidth=max(12, nchar(names(seq))+2)));
saveRDS(cap, 'cap.rds');
writeLines(cap, paste(path.align, 'full_alignment.txt', sep='/'));
aln <- do.call('cbind', strsplit(as.character(con)[names(seq)], ''));
rownames(aln) <- 1:nrow(aln);
wgt <- WeightConsensus(aln, method=tolower(prms$weight)[1]);
rng <- range(which(wgt$weighted[, 'Count']==ncol(aln)));
wtd <- wgt$weighted;
cll <- CallConsensus(wtd);
sub <- paste(cll[cll!='-'], collapse='');
ptn <- DNAStringSet(sub);
names(ptn) <- 'Consensus';
c2r <- AlignConsensus(ptn, ref);
pw0 <- c2r$alignment;
wmd <- tolower(prms$weight)[1];
if (!(wmd %in% c('rank', 'r', 'count'))) wmd <- 'none';
writePairwiseAlignments(pw0, paste(path.align, 'full_consensus_reference.txt', sep='/'), block.width = 100);
saveRDS(con, paste(path.r, 'consensus.rds', sep='/'));
devtools::install_github('zhezhangsh/RH')
rm(list=ls())
name.yaml <- 'evaluate_consensus.yaml';
name.packages <- c('rmarkdown', 'knitr', 'kableExtra', 'yaml', 'DT', 'htmlwidgets', 'gplots', 'msa', 'vioplot',
'Biostrings', 'GenomicRanges', 'BSgenome', 'RoCA', 'awsomics', 'RH');
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table',
'path.align'='alignment');
## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE, fig.path = 'figure/');
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }
## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));
if (!exists('yml'))
if (file.exists(name.yaml))
yml <- yaml.load_file(name.yaml);   # rename the YAML file to fit this template
prms <- yml$parameter;
## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]);
## Automatical figure/table ordering
OrderFigure(reset=TRUE);
OrderTable(reset=TRUE);
## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
debug <- FALSE;
seq <- readRDS(yml$input$sequence);
ref <- readRDS(yml$input$reference);
if (class(seq) != 'DNAStringSet') seq <- DNAStringSet(seq);
if (is.null(names(seq))) names(seq) <- paste('s', 1:length(seq), sep='');
if (class(ref) != 'DNAStringSet') ref <- DNAStringSet(ref);
names(ref) <- 'Reference';
saveRDS(seq, paste(path.r, 'sequence.rds', sep='/'));
saveRDS(ref, paste(path.r, 'reference.rds', sep='/'));
aln <- pairwiseAlignment(seq, ref, type='global-local');
fns <- paste('reference_', names(seq), '.txt', sep='');
for (i in 1:length(seq))
writePairwiseAlignments(aln[i], paste(path.align, fns[i], sep='/'), block.width = 100);
tbl <- cbind(Length=width(seq), Length_Alignment=nchar(as.character(pattern(aln))),
Score=score(aln), Match=nmatch(aln), Mismatch=nmismatch(aln),
Insertion=nindel(aln)@insertion[, 2], Deletion=nindel(aln)@deletion[, 2]);
tbl <- cbind(tbl, 'Match%'=round(100*tbl[, 'Match']/tbl[, 'Length_Alignment'], 1));
rownames(tbl) <- names(seq);
saveRDS(aln, paste(path.r, 'alignment_individual.rds', sep='/'));
saveRDS(tbl, paste(path.r, 'alignment_individual_summary.rds', sep='/'));
tbl <- data.frame(Sequence=paste('[', rownames(tbl), '](', paste('alignment', fns, sep='/'), ')', sep=''),
tbl, stringsAsFactors = FALSE);
colnames(tbl)[ncol(tbl)] <- 'Match%';
kable(tbl, row.names = FALSE) %>% kable_styling(
bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE);
if (debug) {
con <- readRDS('/Users/zhangz/Google Drive/Projects/Chou/result/evaluate_consensus/consensus_muscle.rds');
} else {
if (tolower(prms$method=='muscle')) con <- msaMuscle(seq[1:i], order='input') else
if (tolower(prms$method=='clustalomega')) con <- msaClustalOmega(seq[1:i], order='input') else
con <- msaClustalW(seq[1:i], order='input');
};
cap <- capture.output(msa::print(con, show='complete', showNames=TRUE, showConsensus=TRUE,
nameWidth=max(12, nchar(names(seq))+2)));
saveRDS(cap, paste(path.r, 'cap.rds', sep='/'));
writeLines(cap, paste(path.align, 'full_alignment.txt', sep='/'));
aln <- do.call('cbind', strsplit(as.character(con)[names(seq)], ''));
rownames(aln) <- 1:nrow(aln);
wgt <- WeightConsensus(aln, method=tolower(prms$weight)[1]);
rng <- range(which(wgt$weighted[, 'Count']==ncol(aln)));
wtd <- wgt$weighted;
cll <- CallConsensus(wtd);
sub <- paste(cll[cll!='-'], collapse='');
ptn <- DNAStringSet(sub);
names(ptn) <- 'Consensus';
c2r <- AlignConsensus(ptn, ref);
c2r <- AlignConsensus2Reference(ptn, ref);
c2r <- AlignConsensus2Reference(ptn, ref);
pw0 <- c2r$alignment;
pw0 <- c2r$alignment;
wmd <- tolower(prms$weight)[1];
wmd <- tolower(prms$weight)[1];
if (!(wmd %in% c('rank', 'r', 'count'))) wmd <- 'none';
writePairwiseAlignments(pw0, paste(path.align, 'full_consensus_reference.txt', sep='/'), block.width = 100);
saveRDS(con, paste(path.r, 'consensus.rds', sep='/'));
cl0 <- cll[cll!='-' & wtd[, 'Count']==ncol(aln)];
c2r <- AlignConsensus(paste(cl0, collapse=''), ref);
cl0 <- cll[cll!='-' & wtd[, 'Count']==ncol(aln)];
c2r <- AlignConsensus2Reference(paste(cl0, collapse=''), ref);
pw1 <- c2r$alignment;
writePairwiseAlignments(pw1, paste(path.align, 'core_consensus_reference.txt', sep='/'), block.width = 100);
ch1 <- strsplit(as.character(pattern(pw1)), '')[[1]];
ch2 <- strsplit(as.character(subject(pw1)), '')[[1]];
loc <- matrix(0, nr=length(ch1), nc=4);
loc[c2r$index$mismatch, 1] <- 1;
loc[c2r$index$insertion, 2] <- 1;
loc[ch1=='-', 3] <- 1;
loc[ch1!='-', 4] <- 1:length(ch1[ch1!='-']);
colnames(loc) <- c('mismatch', 'insertion', 'deletion', 'index');
gp1 <- wtd[names(cl0)[loc[rowSums(loc[, 1:2])==0, 4]], , drop=FALSE];
gp2 <- wtd[names(cl0)[loc[loc[, 1]>0, 4]], , drop=FALSE];
gp3 <- wtd[names(cl0)[loc[loc[, 2]>0, 4]], , drop=FALSE];
# Deletion
i1 <- c2r$index$deletion;
i1 <- as.numeric(names(cl0)[i1]);
i1 <- IRanges(start=i1+1, width=c2r$index$deletion.width);
gp4 <- lapply(1:length(i1), function(i) {
x <- wtd[as.character(start(i1)[i]:end(i1)[i]), , drop=FALSE];
c <- cll[rownames(x)];
a <- Rle(c=='-');
b <-
if (runValue(a)[1]) x[1:end(a)[1], , drop=FALSE] else NULL;
});
gp4 <- do.call('rbind', gp4);
grp <- list(Match=gp1, Mismatch=gp2, Insertion=gp3, Deletion=gp4);
grp <- lapply(grp, function(g) aln[rownames(g), , drop=FALSE]);
num <- lapply(grp, function(g) {
c <- cll[rownames(g)];
sapply(1:length(c), function(i) length(which(g[i, ]==c[i])));
});
gap <- lapply(grp, function(g) apply(g, 1, function(g) length(g[g=='-'])));
cnt <- sapply(num, function(n) table(n)[as.character(1:ncol(aln))])
rownames(cnt) <- 1:ncol(aln);
cnt[is.na(cnt)] <- 0;
cnt <- cnt[rowSums(cnt)>0, , drop=FALSE];
cnt <- t(cnt);
tbl <- cbind(Total=rowSums(cnt), cnt, Mean=round(sapply(num, mean), 2), Gap=round(sapply(gap, mean), 2));
saveRDS(tbl, paste(path.r, 'consensus_base_agreement', sep='/'));
kable(tbl) %>% kable_styling(
bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE);
col <- c('#E39C12', '#8E44AD', '#1ABC9C', '#3498DB');
par(mfrow=c(1, 2), mar=c(6, 5, 1, 1));
plot(0, type='n', ylim=range(unlist(num, use.names=FALSE)), xlim=c(0.4, 4.5),
ylab='Number of agreed sequences', cex.lab=1, xaxt='n', xlab='');
for (i in 1:length(num)) vioplot(num[[i]], at=i, add=TRUE, col=col[i]);
axis(1, at=1:4, label=names(num), las=3);
plot(0, type='n', ylim=range(unlist(gap, use.names=FALSE)), xlim=c(0.4, 4.5),
ylab='Number of gapped sequences', cex.lab=1, xaxt='n', xlab='');
for (i in 1:length(gap)) vioplot(gap[[i]], at=i, add=TRUE, col=col[i]);
axis(1, at=1:4, label=names(gap), las=3);
w <- wgt$weight;
if (wmd == 'none') o <- sample(names(w), length(w)) else o <- names(rev(sort(w)));
alt <- aln[rng[1]:rng[2], o];
ltt <- unique(as.vector(alt));
fll <- apply(alt, 2, function(x) gsub('-', '', paste(x, collapse='')));
fll <- DNAStringSet(fll);
con <- sapply(1:length(fll), function(i) {
if (i > 1) {
if (debug) {
con <- readRDS('/Users/zhangz/Google Drive/Projects/Chou/result/evaluate_consensus/consensus_step.rds');
con <- con[[i]];
saveRDS(con, paste(path.r, '/stepwise_', i, '.rds', sep=''));
} else {
if (tolower(prms$method=='muscle')) con <- msaMuscle(fll[1:i], order='input') else
if (tolower(prms$method=='clustalomega')) con <- msaClustalOmega(fll[1:i], order='input') else
con <- msaClustalW(fll[1:i], order='input');
saveRDS(con, paste(path.r, '/stepwise_1.rds', sep=''));
}
aln <- do.call('cbind', strsplit(as.character(con)[names(fll)[1:i]], ''));
rownames(aln) <- 1:nrow(aln);
wgt <- WeightConsensus(aln, method=tolower(prms$weight)[1]);
cll <- CallConsensus(wgt$weighted);
sub <- paste(cll[cll!='-'], collapse='');
} else sub <- as.character(fll[[1]]);
sub;
});
con <- as.character(con);
pws <- lapply(con, function(c) {
c <- DNAStringSet(c);
names(c) <- 'Consensus';
AlignConsensus2Reference(c, ref);
});
con <- DNAStringSet(con);
names(pws) <- names(con) <- names(fll);
cnt <- t(sapply(pws, function(x) x$count));
scs <- sapply(pws, function(x) score(x[[1]]));
pct <- 100*cnt[, 1]/seqlengths(con);
fns <- sapply(1:length(pws), function(i) {
f <- paste('stepwise_', i, '_', names(fll)[i], '.txt', sep='');
writePairwiseAlignments(pws[[i]]$alignment, paste(path.align, f, sep='/'), block.width = 100);
f;
});
tbl <- data.frame(rownames(cnt), scs, cnt[, c(1, 2, 4, 6)], pct, stringsAsFactors = FALSE);
colnames(tbl) <- c('Sequence_Added', 'Score', 'Match', 'Mismatch', 'Insertion', 'Deletion', 'Match%');
tbl[[1]] <- paste('[', tbl[[1]], '](alignment/', fns, ')', sep='');
rownames(tbl) <- paste('Step', 1:nrow(tbl), sep='_');
saveRDS(con, paste(path.r, 'stepwise_consensus.rds', sep='/'));
saveRDS(pws, paste(path.r, 'stepwise_alignment.rds', sep='/'));
saveRDS(tbl, paste(path.r, 'stepwise_summary.rds', sep='/'));
kable(tbl) %>% kable_styling(
bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE);
writePairwiseAlignments(pw1, paste(path.align, 'core_consensus_reference.txt', sep='/'), block.width = 100);
name.yaml <- 'evaluate_consensus.yaml';
name.packages <- c('rmarkdown', 'knitr', 'kableExtra', 'yaml', 'DT', 'htmlwidgets', 'gplots', 'msa', 'vioplot',
'Biostrings', 'GenomicRanges', 'BSgenome', 'RoCA', 'awsomics', 'RH');
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table',
'path.align'='alignment');
## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE, fig.path = 'figure/');
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }
## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));
if (!exists('yml'))
if (file.exists(name.yaml))
yml <- yaml.load_file(name.yaml);   # rename the YAML file to fit this template
prms <- yml$parameter;
## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]);
## Automatical figure/table ordering
OrderFigure(reset=TRUE);
OrderTable(reset=TRUE);
## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
debug <- FALSE;
args(RH::MakeConsensus)
length(palin)
library("snow", lib.loc="~/Library/R/3.3/library")
?makeCluster
?stopCluster
seq
dir()
seq <- readRDS("seq.rds")
class(seq)
length(seq)
seq <- seq[[1]]
seq[[1]]
length(seq[[1]])
seq
class(seq)
length(seq)
width(seq)
devtools::install_github('zhezhangsh/RH')
seq <- subseq(seq, 1, 25000)
seq
chr1_25348001_25402000
25348001 - 25402000
25372001-25378000
idl <- indel(pw0);
