---
title: "Select variables to plot a heatmap"
author: "`r if (exists('yml')) yml$analyst else 'Jim Zhang'`"
date: "`r Sys.Date()`"
output:
  html_document:
    number_sections: yes
    self_contained: no
    toc: yes
    toc_float:
      collapsed: no
---


<div style="border:black 1px solid; padding: 0.5cm 0.5cm">
**Introduction** This analysis runs a simple procedure that identifies variables significantly different across sample groups via ANOVA and then plots a heatmap of these variables.
</div>

&nbsp;

```{r global_setup, eval=TRUE, include=FALSE}
## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);

## Load required R packages
require(yaml);
require(knitr);
require(rmarkdown); 
require(awsomics);

## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                           # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
  if (file.exists('plot_heat.yaml'))          # assume the pairing YAML file exists in the current folder with the same name
      yml<-yaml.load_file('plot_heat.yaml');  # rename the YAML file to fit this template

# Path to output files
f <- GenerateFolder(yml$output, c('input', 'R', 'figure', 'table'));
path <- yml$output;
path.r <- f['R'];
path.tbl <- f['table'];
path.fig <- f['figure'];
path.input <- f['input'];

## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);

## Load input data
mtr<-as.matrix(ImportTable(DownloadFile(yml$input$data, path.input))); # tab-delimited data matrix
grp<-ImportVector(DownloadFile(yml$input$group, path.input));

if (length(grp) != ncol(mtr)) stop('Error: column number of data matrix not equal to number of samples\n');
if (length(unique(grp)) < 2) stop('Error: less than 2 sample groups, cannot run ANOVA\n');
if (length(unique(grp)) == length(grp)) stop('Error: none of the sample groups has replicates, cannot run ANOVA\n'); 
names(grp)<-colnames(mtr); 

saveRDS(mtr, paste(path.r, 'data.rds', sep='/')); 
saveRDS(grp, paste(path.r, 'group.rds', sep='/')); 

# re-order matrix column, so samples of the same group are next to each other
ind<-lapply(unique(grp), function(u) which(grp==u)); 
mtr<-mtr[, unlist(ind)]; 
grp<-grp[colnames(mtr)]; 

# paramaters
prm<-yml$parameter;
```

`r home.url`

# Description

`r WriteDescription(yml$description)`

`r home.url`

# Summary statistics

```{r missing, include=FALSE}
mss<-length(mtr[is.na(mtr)]); 
if (length(mss==0)) ln<-'there are no variables including missing values.' else {
  n.mss<-apply(mtr, 1, function(x) length(x[is.na(x)]));
  ln<-paste('there are', length(n.mss[n.mss>0]), 'variable(s) including missing values.')
}
```

The input data matrix has

  - `r length(unique(grp))` sample groups
  - `r ncol(mtr)` total samples
  - `r nrow(mtr)` total variables
    * `r ln`

```{r summary_statistics, include=FALSE}
stat<-cbind(Mean=rowMeans(mtr, na.rm=TRUE), 
            SD=apply(mtr, 1, function(x) sd(x, na.rm=TRUE)), 
            Range=apply(mtr, 1, function(x) diff(range(x, na.rm=TRUE))));
summ<-apply(stat, 2, summary); 
tbl1<-t(summ); 
```

<div style="color:darkblue; padding:0 3cm">
**Table 1.** The mean, standard deviation, and range of all variables.
</div>

<div align='center', style="padding:0 3cm">
`r kable(tbl1, row.names=TRUE, align=rep('c', ncol(tbl1)))`
</div>

`r home.url`

# Variable selection

## Run ANOVA

```{r anova, include=FALSE}
f<-as.factor(as.vector(grp)); 
dat<-data.frame(t(mtr));
dat$Group<-f;
formula = as.formula(paste0("cbind(", paste(names(dat)[-length(dat)],collapse=","), ")~Group") ) 
aov<-aov(formula, data=dat);
p<-as.vector(sapply(summary(aov), function(x) x[1, 5])); 
names(p)<-rownames(mtr);

ms<-sapply(unique(grp), function(g) rowMeans(mtr[, grp==g, drop=FALSE], na.rm=TRUE)); 
colnames(ms)<-paste('Mean', colnames(ms), sep='_'); 

stat<-cbind(stat, pANOVA=p, ms); 
saveRDS(stat, paste(path.r, 'stat.rds', sep='/')); 
write.csv(stat, paste(path.tbl, 'stat.csv', sep='/')); 
```

Run 1-way ANOVA on each variable to identify those significantly different across all sample groups.

<div align='center'>
```{r hist_p, include=TRUE, fig.width=6, fig.height=4, out.width='480px'}
# Plot histogram of p values
par(mar=c(5,5,2,2));
hist(p, br=100, xlab='ANOVA p value', ylab='Number of variables', main='', cex.lab=1.5); 
```
</div>

<div style="color:darkblue; padding:0 3cm">
**Figure 1.** Distribution of ANOVA p values. Number of variables with p values within each 0.01 interval.
</div>

## Select variables

```{r selection, include=FALSE}
p0<-sort(p); 
mtr0<-mtr[names(p0), , drop=FALSE]; 
len<-length(p0[p0<=prm$pvalue]); 
if (len < prm$min) sel<-mtr0[1:min(nrow(mtr0), prm$min), , drop=FALSE] else sel<-mtr0[1:min(len, prm$max), , drop=FALSE];
CreateDatatable(FormatNumeric(stat[rownames(sel), , drop=FALSE]), paste(path.tbl, 'selected.html', sep='/')); 
```

Significant variables were selected using the following criteria:

  - Select variables with ANOVA p values less than **`r prm$pvalue`**
  - Stop if the number of remaining variables is between **`r prm$min`** and **`r prm$max`**, else
    * if the number remaining variable is less than `r prm$min`, select the top `r prm$min` variables with the smallest p values
    * if the number remaining variable is greater than `r prm$max`, select the top `r prm$max` variables with the smallest p values

As a result, **`r nrow(sel)`** variables were selected. Click [here](table/selected.html) to view these variables.

`r home.url`

# Heatmap

```{r heatmap_prepare, include=FALSE}
# function to sort columns
sortColumn<-function(ms, g) {
  corr<-as.vector(cor(rowMeans(ms[, g[[2]], drop=FALSE]), ms[, g[[1]], drop=FALSE]));
  g[[1]]<-g[[1]][order(corr)];
  for (i in 2:length(g)) {
    corr<-as.vector(cor(rowMeans(ms[, g[[i-1]], drop=FALSE]), ms[, g[[i]], drop=FALSE]));
    g[[i]]<-g[[i]][rev(order(corr))]; 
  }
  ms[, as.vector(unlist(g))]; 
}

# prepare for heatmap plotting
if (prm$rescale) d<-t(scale(t(sel))) else d<-sel;
d<-d[hclust(as.dist(1-cor(t(d))))$order, , drop=FALSE];
g<-lapply(unique(grp), function(x) names(grp)[grp==x]);
d<-sortColumn(d, g);

w<-max(6, min(1.5+0.25*ncol(d), 10));
h<-min(1.5+0.15*nrow(d), 1.25*w); 
```

<div align='center'>
```{r heatmap, fig.width=w, fig.height=h, out.width='720px'}
if (prm$rescale) PlotColoredBlock(d, -3, 3, key = 'Normalized value', num.breaks = 127, groups=g) else 
  PlotColoredBlock(d, key = 'Value', num.breaks = 127, groups=g)
```
</div>

<div style="color:darkblue; padding:0 2cm">
**Figure 2.** Color-coded data of selected variables different across sample groups (red = higher). Variables (rows) were clustered based on their correlation to each other and samples were arranged by groups.
</div>

`r home.url`

***
_END OF DOCUMENT_
