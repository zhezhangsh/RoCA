key.h<-limit.h-nr;
key.x<-c(nc + 0.15*key.w, nc + 0.85*key.w);
key.y<-c(nr + 0.4*key.h, nr + 0.4*key.h + min(nr/20, 0.4*key.h));
image(seq(key.x[1], key.x[2], length.out=num.breaks+1), key.y, matrix(breaks, nc=1), col=col, breaks=breaks, add=TRUE);
}
abline(v=0:nc, h=0:nr, lwd=0.25, col='#333333');
box();
# plot heatmap
par(mar=c(0.1, 0.1, 0.1, 0.1));
limit.w<-ceiling(full.w/(block.w/nc));
limit.h<-ceiling(full.h/(block.h/nr));
plot(0, type='n', xlim=c(0, limit.w), ylim=c(0, limit.h), xaxs='i', yaxs='i', axes=FALSE, xlab='', ylab='');
image(0:nc, 0:nr, t(d[nr:1,]), col=col, breaks=breaks, add=TRUE);
# plot row names
space.w<-(1-nc/limit.w)*W;
cex.w<-(space.w-0.2)/wid.r;
cex.w<-min(cex.w, 0.75*(H/limit.h)/str.h);
text(nc, (nr:1)-0.5, pos=4, label=rnm, cex=cex.w);
# plot column names
space.h<-(1-nr/limit.h)*H;
cex.h<-(space.h-0.2)/wid.c;
cex.h<-min(cex.h, 0.75*(W/limit.w)/str.h);
text((1:nc)-0.5, (nr+limit.h)/2, srt=90, label=cnm, cex=cex.h);
if (!is.na(key) & key!='') {
# key name
key.w<-0.6*(space.w-0.2)/strwidth(key, units='inches');
key.h<-0.2*space.h/str.h
text((nc+limit.w)/2, nr, pos=3, label=key, col='purple', cex=min(key.w, key.h));
key.w<-limit.w-nc;
key.h<-limit.h-nr;
key.x<-c(nc + 0.15*key.w, nc + 0.85*key.w);
key.y<-c(nr + 0.4*key.h, nr + 0.4*key.h + min(nr/25, 0.4*key.h));
image(seq(key.x[1], key.x[2], length.out=num.breaks+1), key.y, matrix(breaks, nc=1), col=col, breaks=breaks, add=TRUE);
}
abline(v=0:nc, h=0:nr, lwd=0.25, col='#333333');
box();
round(3.2, 3)
format('3.22244443333')
format('3.22244443333', digit=5)
format('3.22244443333', digits=4)
format('3.22244443333', digits=1)
format('0.332345432534', digits=1)
args(format)
?format
format('0.332345432534', digits=1, trim=TRUE)
par(mar=c(0.1, 0.1, 0.1, 0.1));
limit.w<-ceiling(full.w/(block.w/nc));
limit.h<-ceiling(full.h/(block.h/nr));
plot(0, type='n', xlim=c(0, limit.w), ylim=c(0, limit.h), xaxs='i', yaxs='i', axes=FALSE, xlab='', ylab='');
image(0:nc, 0:nr, t(d[nr:1,]), col=col, breaks=breaks, add=TRUE);
# plot row names
space.w<-(1-nc/limit.w)*W;
cex.w<-(space.w-0.2)/wid.r;
cex.w<-min(cex.w, 0.75*(H/limit.h)/str.h);
text(nc, (nr:1)-0.5, pos=4, label=rnm, cex=cex.w);
# plot column names
space.h<-(1-nr/limit.h)*H;
cex.h<-(space.h-0.2)/wid.c;
cex.h<-min(cex.h, 0.75*(W/limit.w)/str.h);
text((1:nc)-0.5, (nr+limit.h)/2, srt=90, label=cnm, cex=cex.h);
if (!is.na(key) & key!='') {
# key name
key.w<-0.6*(space.w-0.2)/strwidth(key, units='inches');
key.h<-0.2*space.h/str.h
text((nc+limit.w)/2, nr, pos=3, label=key, col='purple', cex=min(key.w, key.h));
key.w<-limit.w-nc;
key.h<-limit.h-nr;
key.x<-c(nc + 0.15*key.w, nc + 0.85*key.w);
key.y<-c(nr + 0.4*key.h, nr + 0.4*key.h + min(nr/25, 0.4*key.h));
image(seq(key.x[1], key.x[2], length.out=num.breaks+1), key.y, matrix(breaks, nc=1), col=col, breaks=breaks, add=TRUE);
text(nc+0.15*key.w, nr + 0.4*key.h, pos=1, label=min, cex=0.5*cex.h);
}
abline(v=0:nc, h=0:nr, lwd=0.25, col='#333333');
box();
# plot heatmap
par(mar=c(0.1, 0.1, 0.1, 0.1));
limit.w<-ceiling(full.w/(block.w/nc));
limit.h<-ceiling(full.h/(block.h/nr));
plot(0, type='n', xlim=c(0, limit.w), ylim=c(0, limit.h), xaxs='i', yaxs='i', axes=FALSE, xlab='', ylab='');
image(0:nc, 0:nr, t(d[nr:1,]), col=col, breaks=breaks, add=TRUE);
# plot row names
space.w<-(1-nc/limit.w)*W;
cex.w<-(space.w-0.2)/wid.r;
cex.w<-min(cex.w, 0.75*(H/limit.h)/str.h);
text(nc, (nr:1)-0.5, pos=4, label=rnm, cex=cex.w);
# plot column names
space.h<-(1-nr/limit.h)*H;
cex.h<-(space.h-0.2)/wid.c;
cex.h<-min(cex.h, 0.75*(W/limit.w)/str.h);
text((1:nc)-0.5, (nr+limit.h)/2, srt=90, label=cnm, cex=cex.h);
if (!is.na(key) & key!='') {
# key name
key.w<-0.6*(space.w-0.2)/strwidth(key, units='inches');
key.h<-0.2*space.h/str.h
text((nc+limit.w)/2, nr, pos=3, label=key, col='purple', cex=min(key.w, key.h));
key.w<-limit.w-nc;
key.h<-limit.h-nr;
key.x<-c(nc + 0.15*key.w, nc + 0.85*key.w);
key.y<-c(nr + 0.4*key.h, nr + 0.4*key.h + min(nr/25, 0.4*key.h));
image(seq(key.x[1], key.x[2], length.out=num.breaks+1), key.y, matrix(breaks, nc=1), col=col, breaks=breaks, add=TRUE);
text(nc+0.15*key.w, nr + 0.4*key.h, pos=1, label=min, cex=0.75*cex.h);
text(nc+0.85*key.w, nr + 0.4*key.h, pos=1, label=max, cex=0.75*cex.h);
}
abline(v=0:nc, h=0:nr, lwd=0.25, col='#333333');
box();
par(mar=c(0.1, 0.1, 0.1, 0.1));
limit.w<-ceiling(full.w/(block.w/nc));
limit.h<-ceiling(full.h/(block.h/nr));
plot(0, type='n', xlim=c(0, limit.w), ylim=c(0, limit.h), xaxs='i', yaxs='i', axes=FALSE, xlab='', ylab='');
image(0:nc, 0:nr, t(d[nr:1,]), col=col, breaks=breaks, add=TRUE);
# plot row names
space.w<-(1-nc/limit.w)*W;
cex.w<-(space.w-0.2)/wid.r;
cex.w<-min(cex.w, 0.75*(H/limit.h)/str.h);
text(nc, (nr:1)-0.5, pos=4, label=rnm, cex=cex.w);
# plot column names
space.h<-(1-nr/limit.h)*H;
cex.h<-(space.h-0.2)/wid.c;
cex.h<-min(cex.h, 0.75*(W/limit.w)/str.h);
text((1:nc)-0.5, (nr+limit.h)/2, srt=90, label=cnm, cex=cex.h);
if (!is.na(key) & key!='') {
# key name
key.w<-0.6*(space.w-0.2)/strwidth(key, units='inches');
key.h<-0.2*space.h/str.h
text((nc+limit.w)/2, nr, pos=3, label=key, col='purple', cex=min(key.w, key.h));
key.w<-limit.w-nc;
key.h<-limit.h-nr;
key.x<-c(nc + 0.15*key.w, nc + 0.85*key.w);
key.y<-c(nr + 0.4*key.h, nr + 0.4*key.h + min(nr/25, 0.4*key.h));
image(seq(key.x[1], key.x[2], length.out=num.breaks+1), key.y, matrix(breaks, nc=1), col=col, breaks=breaks, add=TRUE);
if (min > 0.01) {
min<-round(min, 3);
max<-round(max, 3);
}
text(nc+0.15*key.w, nr + 0.4*key.h, pos=1, label=min, cex=0.75*cex.h);
text(nc+0.85*key.w, nr + 0.4*key.h, pos=1, label=max, cex=0.75*cex.h);
}
abline(v=0:nc, h=0:nr, lwd=0.25, col='#333333');
box();
# plot heatmap
par(mar=c(0.1, 0.1, 0.1, 0.1));
limit.w<-ceiling(full.w/(block.w/nc));
limit.h<-ceiling(full.h/(block.h/nr));
plot(0, type='n', xlim=c(0, limit.w), ylim=c(0, limit.h), xaxs='i', yaxs='i', axes=FALSE, xlab='', ylab='');
image(0:nc, 0:nr, t(d[nr:1,]), col=col, breaks=breaks, add=TRUE);
# plot row names
space.w<-(1-nc/limit.w)*W;
cex.w<-(space.w-0.2)/wid.r;
cex.w<-min(cex.w, 0.75*(H/limit.h)/str.h);
text(nc, (nr:1)-0.5, pos=4, label=rnm, cex=cex.w);
# plot column names
space.h<-(1-nr/limit.h)*H;
cex.h<-(space.h-0.2)/wid.c;
cex.h<-min(cex.h, 0.75*(W/limit.w)/str.h);
text((1:nc)-0.5, (nr+limit.h)/2, srt=90, label=cnm, cex=cex.h);
if (!is.na(key) & key!='') {
# key name
key.w<-0.6*(space.w-0.2)/strwidth(key, units='inches');
key.h<-0.2*space.h/str.h
text((nc+limit.w)/2, nr, pos=3, label=key, col='purple', cex=min(key.w, key.h));
key.w<-limit.w-nc;
key.h<-limit.h-nr;
key.x<-c(nc + 0.15*key.w, nc + 0.85*key.w);
key.y<-c(nr + 0.4*key.h, nr + 0.4*key.h + min(nr/25, 0.4*key.h));
image(seq(key.x[1], key.x[2], length.out=num.breaks+1), key.y, matrix(breaks, nc=1), col=col, breaks=breaks, add=TRUE);
if (min > 0.01) {
min<-round(min, 3);
max<-round(max, 3);
}
text(nc+0.15*key.w, nr + 0.4*key.h, pos=1, label=min, cex=0.6*cex.h);
text(nc+0.85*key.w, nr + 0.4*key.h, pos=1, label=max, cex=0.6*cex.h);
}
abline(v=0:nc, h=0:nr, lwd=0.25, col='#333333');
box();
?text
if (num.breaks<1) num.breaks<-32;
col<-GetBluePickogramColors(num.breaks);
if (min > min(d, na.rm=TRUE)) d[!is.na(d) & d<min]<-min;
if (max < max(d, na.rm=TRUE)) d[!is.na(d) & d>max]<-max;
breaks<-seq(min, max, length.out = length(col)+1);
# column/row names
rnm<-rownames(d);
cnm<-colnames(d);
nr<-nrow(d);
nc<-ncol(d);
# Current device size in inch
W<-par()$fin[1] - .2;
H<-par()$fin[2] - .2;
str.h<-strheight('', unit='inches'); # default string height
# Total block size
block.w<-1.2*str.h*nc;
block.h<-1.2*str.h*nr;
ratio<-c(0.1, 10); # minimal and maximal label/block ratio
# lable size
wid.r<-max(strwidth(rnm, units='inches'));
wid.c<-max(strwidth(cnm, units='inches'));
str.r<-wid.r/max(1, str.h/(0.75*H/nr));
str.c<-wid.c/max(1, str.h/(0.75*W/nc));
str.r<-max(ratio[1]*block.w, min(ratio[2]*block.w, str.r));
str.c<-max(ratio[1]*block.h, min(ratio[2]*block.h, str.c));
# label + block size
full.w<-block.w+str.r;
full.h<-block.h+str.c;
# ratio to device size
ratio.w<-W/full.w;
ratio.h<-H/full.h;
# plot heatmap
par(mar=c(0.1, 0.1, 0.1, 0.1));
limit.w<-ceiling(full.w/(block.w/nc));
limit.h<-ceiling(full.h/(block.h/nr));
plot(0, type='n', xlim=c(0, limit.w), ylim=c(0, limit.h), xaxs='i', yaxs='i', axes=FALSE, xlab='', ylab='');
image(0:nc, 0:nr, t(d[nr:1,]), col=col, breaks=breaks, add=TRUE);
# plot row names
space.w<-(1-nc/limit.w)*W;
cex.w<-(space.w-0.2)/wid.r;
cex.w<-min(cex.w, 0.75*(H/limit.h)/str.h);
text(nc, (nr:1)-0.5, pos=4, label=rnm, cex=cex.w);
# plot column names
space.h<-(1-nr/limit.h)*H;
cex.h<-(space.h-0.2)/wid.c;
cex.h<-min(cex.h, 0.75*(W/limit.w)/str.h);
text((1:nc)-0.5, (nr+limit.h)/2, srt=90, label=cnm, cex=cex.h);
if (!is.na(key) & key!='') {
# key name
key.w<-0.6*(space.w-0.2)/strwidth(key, units='inches');
key.h<-0.2*space.h/str.h
text((nc+limit.w)/2, nr, pos=3, label=key, col='purple', cex=min(key.w, key.h));
key.w<-limit.w-nc;
key.h<-limit.h-nr;
key.x<-c(nc + 0.15*key.w, nc + 0.85*key.w);
key.y<-c(nr + 0.4*key.h, nr + 0.4*key.h + min(nr/25, 0.4*key.h));
image(seq(key.x[1], key.x[2], length.out=num.breaks+1), key.y, matrix(breaks, nc=1), col=col, breaks=breaks, add=TRUE);
if (min > 0.01) {
min<-round(min, 3);
max<-round(max, 3);
}
text(nc+0.15*key.w, nr + 0.4*key.h, pos=1, label=min, cex=0.75*cex.h);
text(nc+0.85*key.w, nr + 0.4*key.h, pos=1, label=max, cex=0.75*cex.h);
}
abline(v=0:nc, h=0:nr, lwd=0.25, col='#333333');
box();
str.h<-strheight('', units='inches');
str.h
sz<-0.2;
nr<-nrow(d);
nc<-ncol(d);
block.w<-sz*nc;
block.h<-ratio*sz*nr;
full.w<-block.w + max(nchar(rownames(d)));
full.w
strwidth('abc', units='inches')
strheight('abc', units='inches')
sz<-0.2;
nr<-nrow(d);
nc<-ncol(d);
block.w<-sz*nc;
block.h<-ratio*sz*nr;
full.w<-block.w + 0.12*max(nchar(rownames(d)));
full.h<-block.h + 0.12*max(nchar(colnames(d)));
full.w
full.h
block.h
ratio<-1
sz<-0.2;
nr<-nrow(d);
nc<-ncol(d);
block.w<-sz*nc;
block.h<-ratio*sz*nr;
full.w<-block.w + 0.12*max(nchar(rownames(d)));
full.h<-block.h + 0.12*max(nchar(colnames(d)));
sz<-0.2;
nr<-nrow(d);
nc<-ncol(d);
block.w<-sz*nc;
block.h<-ratio*sz*nr;
full.w<-block.w + ratio*0.12*max(nchar(rownames(d))) + 0.4;
full.h<-block.h + 0.12*max(nchar(colnames(d))) + 0.4;
out<-c(full.w, full.h);
out
out/max(1, max(out)/max.size);
max.size
max.size<-12
out/max(1, max(out)/max.size);
full.w
full.h
saveRDS(d, '~/Desktop/d.rdata')
# Helper function of PlotColoredBlock(), calculate preferred device size for color block heatmap
CalculateColoredBlockSize<-function(d, ratio=1, max.size=12) {
# d         The matix to be plotted
# ratio     Default height-to-width ratio of each block
# max.size  Maximum width and height allowed for the whole plot, in inches
sz<-0.2;
nr<-nrow(d);
nc<-ncol(d);
block.w<-sz*nc;
block.h<-ratio*sz*nr;
full.w<-block.w + ratio*0.12*max(nchar(rownames(d))) + 0.4;
full.h<-block.h + 0.12*max(nchar(colnames(d))) + 0.4;
c(full.w, full.h)/max(1, max(c(full.w, full.h))/max.size);
}
dim(d)
log10(abs(min))
min<-round(min, ceiling(log10(abs(min))));
min
letters()
letters
summary(letters)
quantile(letters)
quantile(letters)
data.frame(a=1:26, b=letters)
data.frame(a=1:26, b=letters)->x
class(x[[1]])
?class
?readRDS
x<-1:100
saveRDS(x, 'x.rds')
serialize(y, 'x.rds')
serialize(x)
serialize(x, NULL)
serialize(x, 'y.rds')
serialize(x, con('y.rds'))
library(Rsamtools)
gr<-GRanges(1:2, IRanges(1:2, 3:4))
gr
elementMetadata(gr)
gr<-GRanges(1:2, IRanges(1:2, 3:4), REF=c('A', 'G'), ALT=c('C', 'T'))
elementMetadata(gr)
elementMetadata(gr)->obj
class(obj)
is.data.frame(obj)
class(gr)
if (cll=='GRanges') cll<-as.data.frame(elementMetadata(obj));
cll<-class(obj);
if (cll=='GRanges') cll<-as.data.frame(elementMetadata(obj));
obj<-gr
cll<-class(obj);
if (cll=='GRanges') cll<-as.data.frame(elementMetadata(obj));
obj
cll<-class(obj);
if (cll=='GRanges') obj<-as.data.frame(elementMetadata(obj));
dim(obj)
class(obj)
GRanges(1:2, IRanges(1, 2))
GRanges(1:2, IRanges(1, 2))->x
elementMetadata(x)->x
ncol(x)
round(0.5)
library(knitr)
?kable
SplitCigar<-function(cigar, op=c('M', 'S', 'H', 'I', 'D')) {
# cigar   Vector of cigar strings
# op      Cigar operations
require(GenomicAlignments);
require(S4Vectors);
lst<-cigarToRleList(cigar);
val<-runValue(lst);
len<-runLength(lst);
ele<-elementLengths(len);
val<-BiocGenerics::unlist(val, use.names=FALSE);
len<-BiocGenerics::unlist(len, use.names=FALSE);
ind<-rep(1:length(ele), ele);
v<-rep(0, length(cigar));
n<-sapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
v[as.integer(names(s))]<-s;
v;
});
if (class(n)!='matrix') n<-matrix(n, nc=length(op));
rownames(n)<-cigar;
colnames(n)<-op;
n;
}
x<-c('50M', '50M')
x
SplitCigar(x)->a
a
a[1,1]
op=c('M', 'S', 'H', 'I', 'D')
cigar<-x
require(GenomicAlignments);
require(S4Vectors);
lst<-cigarToRleList(cigar);
val<-runValue(lst);
len<-runLength(lst);
ele<-elementLengths(len);
val<-BiocGenerics::unlist(val, use.names=FALSE);
len<-BiocGenerics::unlist(len, use.names=FALSE);
ind<-rep(1:length(ele), ele);
v<-rep(0, length(cigar));
n<-sapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
v[as.integer(names(s))]<-s;
v;
});
n
n[1,1]
n<-sapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
v[as.integer(names(s))]<-s;
as.vector(v);
});
n
n1[1,]
n[1,1]
o<-op[1]
i<-which(val==o);
i
s<-sapply(split(len[i], ind[i]), sum);
s
v[as.integer(names(s))]<-s;
v
n<-sapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
v[as.integer(names(s))]<-s;
as.vector(v);
});
class(n)
n[1,1]
n[1, ]
val
len
v
n<-lapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
v[as.integer(names(s))]<-s;
as.vector(v);
});
n
n[[1]]
n[[2]]
o<-op[2]
o
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
v[as.integer(names(s))]<-s;
s
v
v<-rep(0, length(cigar));
v
s
length(s)
v<-rep(0, length(cigar));
n<-lapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
if (length(s)>0) v[as.integer(names(s))]<-s;
v
});
n
n<-sapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
if (length(s)>0) v[as.integer(names(s))]<-s;
v
});
n
n[1,1]
n[1, ]
n[2, ]
class(n)
n[, 1]
i
devtools::install_github("zhezhangsh/DEGandMore");
devtools::install_github("zhezhangsh/RoCA");
devtools::install_github("zhezhangsh/RoCA");
devtools::install_github("zhezhangsh/CHOPseq");
devtools::install_github("zhezhangsh/CHOPseq");
devtools::install_github("zhezhangsh/Rnaseq");
devtools::install_github("zhezhangsh/awsomics");
devtools::install_github("zhezhangsh/rchive");
devtools::install_github("zhezhangsh/GtUtility");
library(RoCA)
CreateReport('~/Desktop/sample_normal.yml')
download.file('https://raw.githubusercontent.com/zhezhangsh/RoCA/master/template/demo/sample_normal/sample_normal.yml', 'sample_normal.yml')
dir()
RoCA::CreateReport('sample_normal.yml')
RoCA::CreateReport('sample_normal.yml')
if (is.null(names(exon))) names(exon)<-1:length(exon);
prop.test(0, 1700, 0.002)
relist
?relist
rm(list=ls())
ls()
.libPaths()
library("RoCA", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
InstallDependency()
InstallDependency
detach("package:RoCA", unload=TRUE)
library("RoCA", lib.loc="~/Library/R/3.2/library")
InstallDependency
detach("package:RoCA", unload=TRUE)
InstallDependency(TRUE)
library("RoCA", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
InstallDependency(TRUE)
detach("package:RoCA", unload=TRUE)
library("RoCA", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
setwd('~/Desktop/RoCA/template/de/cluster_gene/')
dir()
RoCA::CreateReport('cluster_gene.yaml')
RoCA::CreateReport('cluster_gene.yaml')
RoCA::CreateReport('cluster_gene.yaml')
RoCA::CreateReport('cluster_gene.yaml')
RoCA::CreateReport('cluster_gene.yaml')
setwd('../../demo/plot_heat/')
dir()
RoCA::CreateReport('plot_heat.yaml')
RoCA::CreateReport('plot_heat.yaml')
