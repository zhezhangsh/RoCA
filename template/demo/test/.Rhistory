GRanges(1:2, IRanges(1, 2))->x
elementMetadata(x)->x
ncol(x)
round(0.5)
library(knitr)
?kable
SplitCigar<-function(cigar, op=c('M', 'S', 'H', 'I', 'D')) {
# cigar   Vector of cigar strings
# op      Cigar operations
require(GenomicAlignments);
require(S4Vectors);
lst<-cigarToRleList(cigar);
val<-runValue(lst);
len<-runLength(lst);
ele<-elementLengths(len);
val<-BiocGenerics::unlist(val, use.names=FALSE);
len<-BiocGenerics::unlist(len, use.names=FALSE);
ind<-rep(1:length(ele), ele);
v<-rep(0, length(cigar));
n<-sapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
v[as.integer(names(s))]<-s;
v;
});
if (class(n)!='matrix') n<-matrix(n, nc=length(op));
rownames(n)<-cigar;
colnames(n)<-op;
n;
}
x<-c('50M', '50M')
x
SplitCigar(x)->a
a
a[1,1]
op=c('M', 'S', 'H', 'I', 'D')
cigar<-x
require(GenomicAlignments);
require(S4Vectors);
lst<-cigarToRleList(cigar);
val<-runValue(lst);
len<-runLength(lst);
ele<-elementLengths(len);
val<-BiocGenerics::unlist(val, use.names=FALSE);
len<-BiocGenerics::unlist(len, use.names=FALSE);
ind<-rep(1:length(ele), ele);
v<-rep(0, length(cigar));
n<-sapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
v[as.integer(names(s))]<-s;
v;
});
n
n[1,1]
n<-sapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
v[as.integer(names(s))]<-s;
as.vector(v);
});
n
n1[1,]
n[1,1]
o<-op[1]
i<-which(val==o);
i
s<-sapply(split(len[i], ind[i]), sum);
s
v[as.integer(names(s))]<-s;
v
n<-sapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
v[as.integer(names(s))]<-s;
as.vector(v);
});
class(n)
n[1,1]
n[1, ]
val
len
v
n<-lapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
v[as.integer(names(s))]<-s;
as.vector(v);
});
n
n[[1]]
n[[2]]
o<-op[2]
o
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
v[as.integer(names(s))]<-s;
s
v
v<-rep(0, length(cigar));
v
s
length(s)
v<-rep(0, length(cigar));
n<-lapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
if (length(s)>0) v[as.integer(names(s))]<-s;
v
});
n
n<-sapply(op, function(o) {
i<-which(val==o);
s<-sapply(split(len[i], ind[i]), sum);
if (length(s)>0) v[as.integer(names(s))]<-s;
v
});
n
n[1,1]
n[1, ]
n[2, ]
class(n)
n[, 1]
i
devtools::install_github("zhezhangsh/DEGandMore");
devtools::install_github("zhezhangsh/RoCA");
devtools::install_github("zhezhangsh/RoCA");
devtools::install_github("zhezhangsh/CHOPseq");
devtools::install_github("zhezhangsh/CHOPseq");
devtools::install_github("zhezhangsh/Rnaseq");
devtools::install_github("zhezhangsh/awsomics");
devtools::install_github("zhezhangsh/rchive");
devtools::install_github("zhezhangsh/GtUtility");
library(RoCA)
CreateReport('~/Desktop/sample_normal.yml')
download.file('https://raw.githubusercontent.com/zhezhangsh/RoCA/master/template/demo/sample_normal/sample_normal.yml', 'sample_normal.yml')
dir()
RoCA::CreateReport('sample_normal.yml')
RoCA::CreateReport('sample_normal.yml')
if (is.null(names(exon))) names(exon)<-1:length(exon);
prop.test(0, 1700, 0.002)
relist
?relist
rm(list=ls())
ls()
.libPaths()
library("RoCA", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
InstallDependency()
InstallDependency
detach("package:RoCA", unload=TRUE)
library("RoCA", lib.loc="~/Library/R/3.2/library")
InstallDependency
detach("package:RoCA", unload=TRUE)
InstallDependency(TRUE)
library("RoCA", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
InstallDependency(TRUE)
detach("package:RoCA", unload=TRUE)
library("RoCA", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
?readGAlignments
library(GenomicAlignments)
?readGAlignments
bamfile <- system.file("extdata", "ex1.bam", package="Rsamtools",
mustWork=TRUE)
gal1 <- readGAlignments(bamfile)
gal1
names(gal1)
library(GenomicAlignments)
galp1 <- readGAlignmentPairs(bamfile)
head(galp1)
names(galp1)
---
param <- ScanBamParam(flag=scanBamFlag(isProperPair=TRUE,
isDuplicate=FALSE,
isSecondaryAlignment=FALSE))
galp2 <- readGAlignmentPairs(bamfile, use.names=TRUE, param=param)
galp2
head(galp2)
head(names(galp2))
param <- ScanBamParam(tag=c("MF", "Aq", "NM", "UQ", "H0", "H1"),
what=c('flag', 'mapq', 'cigar', "isize")
)
galp2 <- readGAlignmentPairs(bamfile, use.names=TRUE, param=param)
galp2
param <- ScanBamParam(tag=c("MF", "Aq", "NM", "UQ", "H0", "H1"),
what='cigar')
galp2 <- readGAlignmentPairs(bamfile, use.names=TRUE, param=param)
galp2
x<-galp2
str(x)
class(x$first)
class(x@first)
class(x@second)
class(x@last)
class(x)
a<-x@first
a
param <- ScanBamParam(
what=c('flag', 'mapq', 'cigar', "isize")
)
x <- readGAlignmentPairs(bamfile, use.names=TRUE, param=param)
a<-x@first
a
a$flag
a@flag
a[, 'flag']
b<- elementMetadata(a)
b
table(b[, 1])
x <- readGAlignmentPairs(bamfile, use.names=TRUE)
a<-x@first
a
a@cigar
a
x
countOverlaps(x, a)
countOverlaps(x, a)->y
length(x)
length(y)
table(y)
str(a)
seqlengths(a)
seqlengths(x)
install.packages('servr')
getwd()
library(devtools)
?install_github
install_github('zhezhangsh/RoCA/R', quick=TRUE)
require('GenomicAlignments')
require(chipseq)
q()
library(RoCA)
LoadPackage('Agri')
LoadPackage('AnnotationDbi')
getwd()
setwd('~/Documents/RoCA/template/demo/skeleton/')
require('biobase')
require('Biobase')
x
assign('x', 1:10)
x
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'=figure', 'path.tbl'='table');
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'=figure, 'path.tbl'='table');
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table'); # <full.path.to.subfolder>=<subfolder.name>
path <- yml$output;
# <!-- ========================================
# The path and name of the pairing YAML file
# List the R packages required by this analysis
# List the subfolder names in the output folder
# ========================================= -->
name.yaml <- 'skeleton.yaml';
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'awsomics', 'RoCA', 'Biobase');
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table'); # <full.path.to.subfolder>=<subfolder.name>
# <!-- ============================================================
# No need to change the rest code of this chunk for RoCA templates
# ============================================================= -->
## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }
## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));
## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                           			# if the 'yml' variable doesn't exist yet, create it by loading the YAML file
if (file.exists(name.yaml))           	# assume the pairing YAML file exists in the current folder with the same name
yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template
prms <- yml$parameter;
## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
sapply(names(name.subfolders), function(nm) assign(nm, name.subfolders[nm]));
path.r <- f['R'];
path.tbl <- f['table'];
path.fig <- f['figure'];
path.input <- f['input'];
## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
rm(names(name.subfolders))
names(name.subfolders)
ls()
rm(names(name.subfolders))
path.input
rm(path.r)
rm(path.input)
rm(path.tbl)
rm(path.fig)
sapply(names(name.subfolders), function(nm) assign(nm, name.subfolders[nm]));
names(name.subfolders)
f
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
sapply(names(name.subfolders), function(nm) assign(nm, f[name.subfolders[nm]]));
ls()
names(name.subfolders)
assign(names(name.subfolders)[1], 'xyz')
ls()
path.input
sapply(1:length(name.subfolders), function(i) assign(names(name.subfolders)[i], f[name.subfolders[i]]));
ls()
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]);
ls()
path.r
path.tbl
yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template
yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template
a.vector <- readRDS(DownloadFile(yml$input$rds, path.input));
yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template
a.rds <- readRDS(DownloadFile(yml$input$rds, path.input));                    # Import any types of data saved in an .rds file
a.rdata <- eval(parse(text=load(DownloadFile(yml$input$rdata, path.input))));   # Import any types of data saved in an .rdata or .rda file
a.vector <- ImportVector(DownloadFile(yml$input$vector, path.input));
args(read.table)
a.matrix <- read.table(DownloadFile(yml$input$table, path.input), sep='\t');  # Import a table from
?read.table
a.vector
a.robject
# <!--
# Load data files specified by the <input> block in the YAML file.
# RoCA provides a few helper function to import data in common structures and file types.
# Use the DownloadFile function to download file first if remote files are acceptable.
# Read <https://github.com/zhezhangsh/RoCA/wiki/Format-input-data> for more information.
# -->
# Import input data
a.vector <- ImportVector(DownloadFile(yml$input$vector, path.input));         # Import a vector-like data object saved in acceptable file types
a.list <- ImportList(DownloadFile(yml$input$list, path.input));               # Import a list-like data object saved in acceptable file types
a.table <- ImportTable(DownloadFile(yml$input$table, path.input));            # Import a table-like data object saved in acceptable file types
a.robject <- ImportR(DownloadFile(yml$input$rdata, path.input));              # Import any R object saved in an .rds, .rdata or .rda file
a.rds <- readRDS(DownloadFile(yml$input$rds, path.input));                    # Import any R object saved in an .rds file
a.rdata <- eval(parse(text=load(DownloadFile(yml$input$rdata, path.input)))); # Import any R object saved in an .rdata or .rda file
a.matrix <- read.table(DownloadFile(yml$input$table, path.input), sep='\t');  # Import using basic R functions (read.csv, readLine, etc.)
# a.text <- YourParser(DownloadFile(yml$input$log, path.input));              # Import a text file using your own parser
# <!--
# Optionally, save imported data object to output folder
# -->
# save imported data to be included in the output folder
saveRDS(a.vector, paste(path.input, 'a_vector.rds', sep='/'));
a.robject
library(GenomicsRanges)
library(GenomicsRange)
library(GenomicRanges)
chr <- as.data.frame(a.robject);
chr
dim(a.table)
head(a.table)
grp <- unique(a.vector);
chr <- as.data.frame(a.robject);
tbl <- a.table[, a.vector==grp[1], , drop=FALSE];
tbl <- a.table[, a.vector==grp[1], drop=FALSE];
dim(tbl)
chr
grp <- unique(a.vector);
# <!--
# Use this chunk to process imported data to prepare for analysis
# Save processed data that might be used in the future to the output folder or subfolders
# -->
# Process data to prepare for analysis
grp <- unique(a.vector);
chr <- as.data.frame(a.robject);
tbl <- a.table[, a.vector==grp[1], drop=FALSE];
# Save processed data that might be re-used in the future
saveRDS(grp, paste(path.r, 'group_name.rds', sep='/'));
write.csv(tbl, paste(path.tbl, 'subset.csv', sep='/'));
CreateDatatable(chr, paste(path.tbl, 'chromosome.html', sep='/'))
tbl<-t(sapply(1:4, function(i) summary(rnorm(100))));
dim(tbl)
tbl
fn.html
fn.html <- CreateDatatable(chr, paste(path.tbl, 'chromosome.html', sep='/'));
fn.html
fn.html <- TrimPath(CreateDatatable(chr, paste(path.tbl, 'chromosome.html', sep='/')));  # <!-- TrimPath function removes the path -->
getwd()
dir()
CreateReport('skeleton.yaml')
rm(list=ls())
# <!--
# The path and name of the pairing YAML file
# List the R packages required by this analysis
# List the subfolder names in the output folder
# -->
name.yaml <- 'skeleton.yaml';
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'GenomicRanges', 'RoCA', 'awsomics');
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table'); # <full.path.to.subfolder>=<subfolder.name>
# <!--
# Keep the remaining part of this code chunk unchanged for all RoCA templates, k.
# -->
## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }
## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));
## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template
prms <- yml$parameter;
## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]);
## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
# <!--
# Load data files specified by the <input> block in the YAML file.
# RoCA provides a few helper function to import data in common structures and file types.
# Use the DownloadFile function to download file first if remote files are acceptable.
# Read <https://github.com/zhezhangsh/RoCA/wiki/Format-input-data> for more information.
# -->
# Import input data
a.vector <- ImportVector(DownloadFile(yml$input$vector, path.input));         # Import a vector-like data object saved in acceptable file types
a.list <- ImportList(DownloadFile(yml$input$list, path.input));               # Import a list-like data object saved in acceptable file types
a.table <- ImportTable(DownloadFile(yml$input$table, path.input));            # Import a table-like data object saved in acceptable file types
a.robject <- ImportR(DownloadFile(yml$input$rdata, path.input));              # Import any R object saved in an .rds, .rdata or .rda file
a.rds <- readRDS(DownloadFile(yml$input$rds, path.input));                    # Import any R object saved in an .rds file
a.rdata <- eval(parse(text=load(DownloadFile(yml$input$rdata, path.input)))); # Import any R object saved in an .rdata or .rda file
a.matrix <- read.table(DownloadFile(yml$input$table, path.input), sep='\t');  # Import using basic R functions (read.csv, readLine, etc.)
# a.text <- YourParser(DownloadFile(yml$input$log, path.input));              # Import a text file using your own parser
# <!--
# Optionally, save imported data object to output folder
# -->
# save imported data to be included in the output folder
saveRDS(a.vector, paste(path.input, 'a_vector.rds', sep='/'));
# <!--
# Use this chunk to process imported data to prepare for analysis
# Save processed data that might be used in the future to the output folder or subfolders
# Use the CreateDatatable function to write a table in Java DataTables format into an HTML file
# -->
# Process data to prepare for analysis
grp <- unique(a.vector);
chr <- as.data.frame(a.robject);
tbl <- a.table[, a.vector==grp[1], drop=FALSE];
# Save processed data that might be re-used in the future
saveRDS(grp, paste(path.r, 'group_name.rds', sep='/'));
write.csv(tbl, paste(path.tbl, 'subset.csv', sep='/'));
fn.html <- TrimPath(CreateDatatable(chr, paste(path.tbl, 'chromosome.html', sep='/')));  # <!-- TrimPath function removes the path -->
q()
getwd()
# <!--
# The path and name of the pairing YAML file
# List the R packages required by this analysis
# List the subfolder names in the output folder
# -->
name.yaml <- 'skeleton.yaml';
name.packages <- c('rmarkdown', 'knitr', 'yaml', 'DT', 'htmlwidgets', 'GenomicRanges', 'RoCA', 'awsomics');
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table'); # <full.path.to.subfolder>=<subfolder.name>
# <!--
# Keep the remaining part of this code chunk unchanged for all RoCA templates, k.
# -->
## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }
## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));
## By default, before knitting this R Markdown file, the YAML file pairing it has been loaded.
## But, the developer can also provide the option to load the YAML file on the fly.
## So, the template can be run using the "Knit HTML" button in RStudio
if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template
prms <- yml$parameter;
## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]);
## URL to project home
## Use this line to add a link to project home in the report: `r home.url`
home.url <- Link2Home(yml$home);
# <!--
# Load data files specified by the <input> block in the YAML file.
# RoCA provides a few helper function to import data in common structures and file types.
# Use the DownloadFile function to download file first if remote files are acceptable.
# Read <https://github.com/zhezhangsh/RoCA/wiki/Format-input-data> for more information.
# -->
# Import input data
a.vector <- ImportVector(DownloadFile(yml$input$vector, path.input));         # Import a vector-like data object saved in acceptable file types
a.list <- ImportList(DownloadFile(yml$input$list, path.input));               # Import a list-like data object saved in acceptable file types
a.table <- ImportTable(DownloadFile(yml$input$table, path.input));            # Import a table-like data object saved in acceptable file types
a.robject <- ImportR(DownloadFile(yml$input$rdata, path.input));              # Import any R object saved in an .rds, .rdata or .rda file
a.rds <- readRDS(DownloadFile(yml$input$rds, path.input));                    # Import any R object saved in an .rds file
a.rdata <- eval(parse(text=load(DownloadFile(yml$input$rdata, path.input)))); # Import any R object saved in an .rdata or .rda file
a.matrix <- read.table(DownloadFile(yml$input$table, path.input), sep='\t');  # Import using basic R functions (read.csv, readLine, etc.)
# a.text <- YourParser(DownloadFile(yml$input$log, path.input));              # Import a text file using your own parser
# <!--
# Optionally, save imported data object to output folder
# -->
# save imported data to be included in the output folder
saveRDS(a.vector, paste(path.input, 'a_vector.rds', sep='/'));
# <!--
# Use this chunk to process imported data to prepare for analysis
# Save processed data that might be used in the future to the output folder or subfolders
# Use the CreateDatatable function to write a table in Java DataTables format into an HTML file
# -->
# Process data to prepare for analysis
grp <- unique(a.vector);
chr <- as.data.frame(a.robject);
tbl <- a.table[, a.vector==grp[1], drop=FALSE];
# Save processed data that might be re-used in the future
saveRDS(grp, paste(path.r, 'group_name.rds', sep='/'));
write.csv(tbl, paste(path.tbl, 'subset.csv', sep='/'));
fn.html <- TrimPath(CreateDatatable(chr, paste(path.tbl, 'chromosome.html', sep='/')));  # <!-- TrimPath function removes the path -->
rm(list=ls())
