---
title: "Frequency of a DNA motif in a set of sequences"
author: "`r if (exists('yml')) yml$analyst else 'Jim Zhang'`"
date: "`r Sys.Date()`"
output:
  html_document:
    number_sections: yes
    self_contained: no
    toc: yes
    toc_float:
      collapsed: no
---

<div style="border:black 1px solid; padding: 0.5cm 0.5cm">
This analysis reports of the frequency and location of a DNA motif in a given set of sequences, and compares the observed frequency to expected frequency. 

  - The motif is searched in each sequence to report its occurances location in the sequence.
  - For each sequence, the observed frequency is compared to expected frequency, which is calculated based on overall base frequency of the sequence.
  - Over- or under-representation of the motif in each sequence is calculated as the ratio of its observed frequency over expected frequency, and tested by Poisson test.
  - Overall over- or under-representation of the motif in all sequences is summarized.
  - Overall location of motif within all sequences is summarized.
</div>

&nbsp;

```{r global_setup, eval=TRUE, include=FALSE}
name.yaml <- 'motif_frequency.yaml'; 
name.packages <- c('rmarkdown', 'knitr', 'kableExtra', 'yaml', 'DT', 'htmlwidgets', 
                   'Biostrings', 'GenomicRanges', 'RoCA', 'awsomics'); 
name.subfolders <- c('path.input'='input', 'path.r'='R', 'path.fig'='figure', 'path.tbl'='table'); # 

## Default knitr parameters
knitr::opts_chunk$set(dpi=300, dev=c('png', 'pdf'), echo=FALSE, warning=FALSE, message=FALSE);
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

## Load required R packages
loaded <- LoadPackage(name.packages);
if (length(loaded[!loaded])) stop('Error: failed to load package(s) ', paste(names(loaded[!loaded]), collapse=', '));

if (!exists('yml'))                   # if the 'yml' variable doesn't exist yet, create it by loading the YAML file
	if (file.exists(name.yaml))         # assume the pairing YAML file exists in the current folder with the same name
		yml<-yaml.load_file(name.yaml);   # rename the YAML file to fit this template

prms <- yml$parameter;

## Generate directory and sub-directories where the output files will be
f <- GenerateFolder(yml$output, name.subfolders);
path <- yml$output;
for (i in 1:length(name.subfolders)) assign(names(name.subfolders)[i], f[name.subfolders[i]]); 

## Automatical figure/table ordering
OrderFigure(reset=TRUE);
OrderTable(reset=TRUE);

## URL to project home
home.url <- Link2Home(yml$home);
```

`r home.url`

```{r load_data, include=FALSE}
seq <- ImportVector(DownloadFile(yml$input$seq, path.input));
seq <- DNAStringSet(seq);

nms <- names(seq);
if (is.null(nms)) nms <- paste('Seq', 1:length(seq), sep='_'); 
ind <- which(is.na(nms) | nms=='');
if (length(ind) > 0) nms[ind] <- paste('Seq', ind, sep='_');
names(seq) <- nms;

wid <- width(seq);
names(wid) <- names(seq);

mtf <- DNAString(toupper(prms$motif));

saveRDS(seq, paste0(path.r, '/sequence.rds'));
```

# Description

`r WriteDescription(yml$description)`

`r home.url`


# Results

## DNA sequences

```{r summary_seq, include=FALSE}
frq <- alphabetFrequency(seq)[, 1:4];
gc  <- round(100*rowSums(frq[, 2:3])/rowSums(frq), 2);
cg1 <- sapply(gregexpr2('CG', seq), function(ind) length(ind[ind>0]));
cg2 <- sapply(gregexpr2('GC', seq), function(ind) length(ind[ind>0]));
cpg <- 100*(cg1+cg2)/(width(seq)-1);
tbl <- rbind(round(summary(wid), 1), round(summary(gc), 2)); 
rownames(tbl) <- c('Length (bp)', 'GC (%)');
```

`r OrderTable()` Length and GC content of **`r length(seq)`** DNA sequences.

`r kable(tbl, align=rep('c', ncol(tbl))) %>% kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width=FALSE)`

`r home.url`

## Motif frequency in sequences

```{r function, include=FALSE}
reportHit <- function(seq0, seq1, rev_comp) {
  bas <- strsplit(as.character(seq0), '')[[1]];
  if (rev_comp) rev <- strsplit(as.character(reverseComplement(seq0)), '')[[1]];
  len <- width(seq1);
  eff <- len - length(seq0) + 1;
  exp <- sapply(seq1, function(s) { # expected frequency
    ttl <- alphabetFrequency(s);
    frq <- ttl[bas]/sum(ttl);
    exp <- exp((sum(log(frq))));
    if (rev_comp & seq0!=reverseComplement(seq0)) {
      frq <- ttl[rev]/sum(ttl);
      exp <- exp + exp((sum(log(frq))));
    } else exp;
  });
  hit <- lapply(vmatchPattern(seq0, seq1), start);
  if (rev_comp & seq0!=reverseComplement(seq0)) {
    hrv <- lapply(vmatchPattern(reverseComplement(seq0), seq1), start);
    hit <- lapply(1:length(seq1), function(i) c(hit[[i]], -(len[i]-hrv[[i]]-length(seq0)+2)));
  }
  
  cnt <- sapply(hit, length); 
  obs <- cnt/(len-length(seq0)+1); # observed frequency
  loc <- sapply(hit, function(x) mean(abs(x))); 
  pos <- loc/eff;
  pvl <- sapply(1:length(seq1), function(i) poisson.test(cnt[i], eff[i], exp[i])$p.value);
  fdr <- p.adjust(pvl, method='BH');
  stat <- cbind(length=len, count=cnt, expected=exp, observed=obs, ratio=obs/exp, 
                pvalue=pvl, fdr=fdr, relative_position=pos);
  
  list(stat=stat, hit=hit);
}
```

```{r search_motif, include=FALSE}
hit <- reportHit(mtf, seq, prms$reverse);
saveRDS(hit, paste0(path.r, '/all_hits.rds'));
CreateDatatable(FormatNumeric(hit[[1]]), paste0(path.tbl, '/stat_sequence'));
```

```{r plot_freq, include=TRUE, fig.width=6.4, fig.height=6.4, out.width='640px'}
stat <- hit[[1]];
freq <- 100*stat[, 3:4];
mx   <- max(freq);
high <- rownames(freq)[stat[, 6]<=prms$plot$pvalue];
par(mar=c(5,5,2,2));
plot(freq[, 1], freq[, 2], pch=18, cex=1.5, col='#88888888', xlim=c(0, mx), ylim=c(0, mx), cex.lab=1.5,
     xlab='Expected frequency (%)', ylab='Observed frequency (%)');
title(main=paste('Correlation coefficient =', round(cor(freq[, 1], freq[, 2]), 3)), cex.main=1.25);
if (length(high)>0) points(freq[high, 1], freq[high, 2], pch=18, cex=1.5, col='#FF8888');
abline(0, 1, lty=2, col='#8888FF', lwd=1.5);

if (prms$reverse) 
  l0 <- 'Both of the original and reverse-complemented sequence of the motif were counted' else 
    l0 <- 'Only the original, not the reverse-complemented, sequence of the motif was counted';
```

`r OrderFigure()` Expected vs. observed frequency of motif **`r prms$motif`** in sequences. Each diamond represents one sequence and its expected frequency of the motif is calculated according to its base frequency. `r l0` Difference between expected and observed frequencies was tested by Poisson test and the sequences with p value less than `r prms$plot$pvalue` are highlighted.

  > [Details about individual sequences](table/stat_sequence.html)

## Motif location in sequences

```{r plot_position, include=TRUE, fig.width=6.4, fig.height=4.8, out.width='640px'}
loc <- hit[[2]];
len <- rep(stat[, 'length'], sapply(loc, length));
pos <- (abs(unlist(loc))-1)/(len-len0);

brk <- c(5, 10, 20, 50, 100);
brk <- min(brk[brk>=(min(length(pos), 10*max(brk))/10)]);
par(mar=c(5,5,2,2));
hist(pos, breaks = seq(0, 1, 1/brk), ylab='Count', xlab='Position in sequences', cex.lab=1.5,
     main='', xaxt='n', xaxs='i', yaxs='i', col='#88888888');
axis(1, at=c(0, 0.5, 1), label=c('Start', 'Center', 'End'));
```

`r OrderFigure()` Distribution of matches to motif within the sequences, all of them combined. Sequence length was adjusted so the positions are relative.

## Summary

```{r summary, include=FALSE}
len0 <- length(mtf);
len1 <- width(seq);
len2 <- sum(len1-len0+1);

ttl0 <- sum((len1-len0+1)*stat[, 'expected']);
ttl1 <- sum(stat[, 'count']);
pvl1 <- poisson.test(ttl1, sum(len1-len0+1), ttl0/len2)$p.value[[1]];

cnt2 <- length(pos[pos>=0.25 & pos<=0.75]);
pvl2 <- suppressWarnings(ks.test(pos, 'punif', 0, 1)$p.value[[1]]);
```

  - Motif to search: **`r prms$motif`**
  - Search reverse-complement motif: **`r prms$reverse`**
  - Total number of sequences: **`r length(seq)`**
  - Total number of bases: **`r format(sum(len1), big.mark=',', scientific=FALSE)`**
  - Total number of matches (_expected_): **`r round(ttl0, 2)`** 
  - Total number of matches (_observed_): **`r ttl1`** 
  - Observed/expected: **`r round(ttl1/ttl0, 2)`** (p=`r format(pvl1, digit=3)`, Exact Poisson test)
  - Number of over-representing sequences: **`r nrow(stat[stat[, 'ratio']>1, , drop=FALSE])`**
  - Number of over-representing and significant sequences (_p<=0.05_): **`r nrow(stat[stat[, 'ratio']>1 & stat[, 'pvalue']<=0.05, , drop=FALSE])`**
  - Matches near the center (_0.25 to 0.75_): **`r cnt2`** (p=`r format(pvl1, digit=3)`, uniform test)
  
***

# Appendix 

Check out the **[RoCA home page](http://zhezhangsh.github.io/RoCA)** for more information.  

## Reproduce this report

To reproduce this report: 

  1. Find the data analysis template you want to use and an example of its pairing YAML file  [here](https://github.com/zhezhangsh/RoCA/wiki/Templates-and-examples) and download the YAML example to your working directory

  2. To generate a new report using your own input data and parameter, edit the following items in the YAML file:

    - _output_        : where you want to put the output files
    - _home_          : the URL if you have a home page for your project
    - _analyst_       : your name
    - _description_   : background information about your project, analysis, etc.
    - _input_         : where are your input data, read instruction for preparing them
    - _parameter_     : parameters for this analysis; read instruction about how to prepare input data

  3. Run the code below within ***R Console*** or ***RStudio***, preferablly with a new R session:

```{r reproduce_report, eval=FALSE, echo=TRUE}
if (!require(devtools)) { install.packages('devtools'); require(devtools); }
if (!require(RCurl)) { install.packages('RCurl'); require(RCurl); }
if (!require(RoCA)) { install_github('zhezhangsh/RoCAR'); require(RoCA); }

CreateReport(filename.yaml);  # filename.yaml is the YAML file you just downloaded and edited
```

If there is no complaint, go to the _output_ folder and open the ***index.html*** file to view report. 

## Session information

```{r session_info, echo=FALSE}
sessionInfo(); 
```

`r home.url`

***
_END OF DOCUMENT_
